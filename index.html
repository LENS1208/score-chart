<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FXå–å¼•è©•ä¾¡ã‚¹ã‚³ã‚¢ - ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒãƒ£ãƒ¼ãƒˆãƒ„ãƒ¼ãƒ«</title>
    <style>
/* CSSå¤‰æ•°ã§è‰²ã‚’ç®¡ç† */
:root {
    /* ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ */
    --bg-primary: #ffffff;
    --bg-secondary: #fafafa;
    --bg-tertiary: #f5f5f5;
    --border-color: #ebebeb;
    --text-primary: #333;
    --text-secondary: #666;
    --text-muted: #999;
    --positive-color: #007eff;
    --negative-color: #ff2800;
    --neutral-color: #6b7280;
    
    /* ã‚«ãƒ¼ãƒ‰ç”¨ */
    --card-bg: #ffffff;
    --card-border: #ebebeb;
    --card-shadow: 0 2px 8px rgba(0,0,0,0.06);
    --hover-shadow: 0 8px 24px rgba(0,0,0,0.1);
    
    /* ãƒœã‚¿ãƒ³ç”¨ */
    --button-bg: #007eff;
    --button-hover-shadow: 0 4px 12px rgba(0, 126, 255, 0.3);
    
    /* Chart.jsç”¨ã®ã‚°ãƒªãƒƒãƒ‰ç·šã®è‰² */
    --chart-grid-color: rgba(0, 0, 0, 0.1);
    --chart-text-color: #666;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ */
@media (prefers-color-scheme: dark) {
    :root {
        --bg-primary: #000000;
        --bg-secondary: #181818;
        --bg-tertiary: #232323;
        --border-color: #373737;
        --text-primary: #e0e0e0;
        --text-secondary: #aaa;
        --text-muted: #777;
        --positive-color: #00c8ff;
        --negative-color: #ff3200;
        
        --card-bg: #181818;
        --card-border: #373737;
        --card-shadow: 0 2px 8px rgba(0,0,0,0.4);
        --hover-shadow: 0 8px 24px rgba(0, 200, 255, 0.15);
        
        --button-bg: #00c8ff;
        --button-hover-shadow: 0 4px 12px rgba(0, 200, 255, 0.3);
        
        /* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ç”¨ã®Chart.jsã‚°ãƒªãƒƒãƒ‰ç·š */
        --chart-grid-color: rgba(255, 255, 255, 0.2);
        --chart-text-color: #aaa;
    }
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰æ‰‹å‹•åˆ‡ã‚Šæ›¿ãˆç”¨ */
body.dark-mode {
    --bg-primary: #000000;
    --bg-secondary: #181818;
    --bg-tertiary: #232323;
    --border-color: #373737;
    --text-primary: #e0e0e0;
    --text-secondary: #aaa;
    --text-muted: #777;
    --positive-color: #00c8ff;
    --negative-color: #ff3200;
    
    --card-bg: #181818;
    --card-border: #373737;
    --card-shadow: 0 2px 8px rgba(0,0,0,0.4);
    --hover-shadow: 0 8px 24px rgba(0, 200, 255, 0.15);
    
    --button-bg: #00c8ff;
    --button-hover-shadow: 0 4px 12px rgba(0, 200, 255, 0.3);
    
    /* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ç”¨ã®Chart.jsã‚°ãƒªãƒƒãƒ‰ç·š */
    --chart-grid-color: rgba(255, 255, 255, 0.2);
    --chart-text-color: #aaa;
}

/* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
}

body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans JP', sans-serif;
    background: var(--bg-primary);
    min-height: 100vh; 
    color: var(--text-primary);
    line-height: 1.6;
    transition: background-color 0.3s ease, color 0.3s ease;
}

.container { 
    max-width: 1200px; 
    margin: 0 auto; 
    padding: 40px 20px; 
}

/* ãƒ˜ãƒƒãƒ€ãƒ¼ */
header { 
    text-align: center; 
    margin-bottom: 40px;
    padding: 30px 20px;
    background: var(--bg-secondary);
    border-radius: 12px;
    border: 1px solid var(--border-color);
    position: relative;
}

h1 { 
    font-size: 2em; 
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--text-primary);
    letter-spacing: 0.02em;
}

header p {
    color: var(--text-secondary);
    font-size: 0.95em;
}

h2 {
    font-size: 1.3em;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 20px;
}

h3 {
    font-size: 1.1em;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 16px;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ */
.theme-toggle {
    position: absolute;
    top: 20px;
    right: 20px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.85em;
    color: var(--text-secondary);
}

.theme-toggle:hover {
    background: var(--border-color);
}

.theme-toggle svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
}

.theme-toggle-text {
    display: none;
}

@media (min-width: 768px) {
    .theme-toggle-text {
        display: inline;
    }
}

/* ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
.upload-section { 
    background: var(--bg-secondary);
    border-radius: 12px; 
    padding: 24px; 
    margin-bottom: 24px;
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}

.upload-section h2 {
    font-size: 1.1em;
    margin-bottom: 16px;
    color: var(--text-primary);
    font-weight: 600;
}

.file-info { 
    margin-top: 16px; 
    padding: 12px 16px; 
    background: var(--bg-tertiary);
    border-radius: 8px;
    font-size: 0.9em;
    border: 1px solid var(--border-color);
}

.file-info h4 { 
    color: var(--text-primary);
    margin-bottom: 4px; 
    font-size: 0.9em;
    font-weight: 600;
}

.file-info div { 
    color: var(--text-secondary);
    font-size: 0.85em; 
}

/* ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
.file-input-wrapper { 
    position: relative; 
    overflow: hidden; 
    display: inline-block; 
    cursor: pointer; 
    background: var(--button-bg);
    color: white; 
    padding: 10px 24px; 
    border-radius: 8px;
    font-size: 0.9em;
    font-weight: 500;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border: none;
}

.file-input-wrapper:hover {
    transform: translateY(-1px);
    box-shadow: var(--button-hover-shadow);
}

#fileInput { 
    display: none;
}

#fileName {
    margin-top: 12px;
    color: var(--text-secondary);
    font-size: 0.9em;
}

/* ãƒ‡ãƒ¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
.demo-controls {
    background: var(--bg-secondary);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 24px;
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}

.demo-controls h3 {
    font-size: 1em;
    color: var(--text-primary);
    margin-bottom: 12px;
    font-weight: 600;
}

.demo-controls button {
    background: var(--button-bg);
    color: white;
    border: none;
    padding: 8px 20px;
    border-radius: 8px;
    cursor: pointer;
    margin: 4px;
    font-size: 0.9em;
    font-weight: 500;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.demo-controls button:hover {
    transform: translateY(-1px);
    box-shadow: var(--button-hover-shadow);
}

/* ãƒ¡ã‚¤ãƒ³ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
#analysisResults {
    display: none;
}

.top-section {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 24px;
}

/* ç·åˆã‚¹ã‚³ã‚¢ã‚«ãƒ¼ãƒ‰ */
.overall-score { 
    background: var(--bg-secondary);
    border-radius: 12px; 
    padding: 32px; 
    text-align: center; 
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
    min-height: 250px;
}

.overall-score h2 { 
    font-size: 1em;
    font-weight: 500;
    margin-bottom: 16px;
    color: var(--text-secondary);
}

.overall-score .score { 
    font-size: 4.5em; 
    font-weight: 700; 
    margin-bottom: 8px;
    color: var(--positive-color);
    line-height: 1;
}

.overall-score .rating { 
    font-size: 0.9em;
    color: var(--text-secondary);
    font-weight: 500;
}

/* ãƒãƒ£ãƒ¼ãƒˆã‚³ãƒ³ãƒ†ãƒŠ */
.chart-container { 
    background: var(--bg-secondary);
    border-radius: 12px; 
    padding: 24px; 
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
    margin-bottom: 24px;
}

.chart-container h3 { 
    color: var(--text-primary);
    margin-bottom: 20px; 
    font-size: 1.1em; 
    font-weight: 600;
    display: flex; 
    align-items: center; 
    gap: 8px; 
}

/* ã‚¹ã‚³ã‚¢ã‚°ãƒªãƒƒãƒ‰ */
.score-grid { 
    display: grid; 
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); 
    gap: 16px; 
    margin-top: 20px; 
}

/* ã‚¹ã‚³ã‚¢ã‚«ãƒ¼ãƒ‰ */
.score-card { 
    background: var(--card-bg);
    border-radius: 12px; 
    padding: 20px; 
    border: 1px solid var(--border-color);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    position: relative;
}

.score-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--hover-shadow);
}

.score-header { 
    display: flex; 
    justify-content: space-between; 
    align-items: flex-start; 
    margin-bottom: 16px; 
}

.score-title { 
    font-weight: 500; 
    color: var(--text-secondary);
    font-size: 0.9em; 
}

.score-value { 
    font-size: 2.5em; 
    font-weight: 700; 
    color: var(--positive-color);
    line-height: 1;
}

/* ã‚¹ã‚³ã‚¢ãƒ¬ãƒ™ãƒ«ã«ã‚ˆã‚‹è‰²åˆ†ã‘ */
.score-value[data-score-level="low"] {
    color: var(--negative-color);
}

.score-value[data-score-level="mid"] {
    color: var(--neutral-color);
}

.score-value[data-score-level="high"] {
    color: var(--positive-color);
}

.score-metrics { 
    margin-top: 12px; 
}

.metric-item { 
    display: flex; 
    justify-content: space-between; 
    margin-bottom: 8px; 
    font-size: 0.85em; 
}

.metric-label { 
    color: var(--text-secondary);
}

.metric-value { 
    font-weight: 600; 
    color: var(--text-primary);
}

/* ãƒˆãƒ¬ãƒ³ãƒ‰ãƒœã‚¿ãƒ³ */
.trend-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.trend-button {
    padding: 6px 16px;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background: var(--bg-primary);
    color: var(--text-secondary);
    font-size: 0.85em;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.trend-button:hover {
    border-color: var(--positive-color);
    color: var(--positive-color);
}

.trend-button.active {
    background: var(--button-bg);
    border-color: var(--button-bg);
    color: white;
}

/* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° */
.loading { 
    display: none; 
    text-align: center; 
    padding: 20px; 
    color: var(--text-secondary);
}

.spinner { 
    border: 3px solid var(--border-color);
    border-top: 3px solid var(--positive-color);
    border-radius: 50%; 
    width: 40px; 
    height: 40px; 
    animation: spin 1s linear infinite; 
    margin: 0 auto 12px; 
}

@keyframes spin { 
    0% { transform: rotate(0deg); } 
    100% { transform: rotate(360deg); } 
}

/* ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
.error-message { 
    background: rgba(255, 40, 0, 0.1);
    color: var(--negative-color);
    padding: 12px 16px; 
    border-radius: 8px; 
    margin-top: 16px; 
    display: none;
    border: 1px solid rgba(255, 40, 0, 0.2);
    font-size: 0.9em;
}

/* ãƒ˜ãƒ«ãƒ—ã‚¢ã‚¤ã‚³ãƒ³ */
.help-icon { 
    cursor: pointer; 
    color: var(--text-muted);
    font-size: 0.9em; 
    opacity: 0.7; 
    transition: opacity 0.2s; 
}

.help-icon:hover { 
    opacity: 1; 
    color: var(--text-secondary);
}

/* Canvasè¦ç´ ã®ã‚¹ã‚¿ã‚¤ãƒ« */
canvas {
    max-width: 100%;
    height: auto !important;
}

/* Chart.jsã®ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œç”¨ã®ã‚¯ãƒ©ã‚¹ */
body.dark-mode canvas,
@media (prefers-color-scheme: dark) {
    canvas {
        filter: brightness(1.1);
    }
}

/* è©³ç´°åˆ†æãƒ¢ãƒ¼ãƒ€ãƒ« */
.detail-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.detail-modal-content {
    background: var(--card-bg);
    border-radius: 15px;
    max-width: 900px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 25px 50px rgba(0,0,0,0.3);
    animation: modalSlideIn 0.3s ease;
}

@keyframes modalSlideIn {
    from { 
        opacity: 0; 
        transform: scale(0.8) translateY(50px); 
    }
    to { 
        opacity: 1; 
        transform: scale(1) translateY(0); 
    }
}

.detail-modal-header {
    background: var(--button-bg);
    color: white;
    padding: 25px 30px;
    border-radius: 15px 15px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.detail-modal-title {
    font-size: 1.5em;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 15px;
}

.detail-modal-score {
    font-size: 2.5em;
    font-weight: bold;
    background: rgba(255,255,255,0.2);
    padding: 10px 20px;
    border-radius: 10px;
}

.detail-modal-close {
    cursor: pointer;
    font-size: 2em;
    opacity: 0.8;
    transition: opacity 0.2s;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255,255,255,0.1);
}

.detail-modal-close:hover {
    opacity: 1;
    background: rgba(255,255,255,0.2);
}

.detail-modal-body {
    padding: 30px;
}

.detail-section {
    margin-bottom: 35px;
}

.detail-section h3 {
    color: var(--positive-color);
    font-size: 1.3em;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 2px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 10px;
}

.detail-section-icon {
    width: 24px;
    height: 24px;
    background: var(--positive-color);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 0.8em;
    font-weight: bold;
}

.analysis-block {
    background: var(--bg-tertiary);
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 20px;
    border-left: 4px solid var(--positive-color);
}

.analysis-block h4 {
    color: var(--text-primary);
    font-size: 1.1em;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.analysis-text {
    color: var(--text-secondary);
    line-height: 1.7;
    font-size: 0.95em;
}

.highlight-number {
    background: var(--positive-color);
    color: white;
    padding: 2px 8px;
    border-radius: 5px;
    font-weight: bold;
}

.example-trade {
    background: rgba(0, 126, 255, 0.1);
    border-left: 4px solid var(--positive-color);
    padding: 15px;
    border-radius: 0 8px 8px 0;
    margin: 15px 0;
}

.example-trade-header {
    font-weight: bold;
    color: var(--positive-color);
    margin-bottom: 8px;
}

.example-trade-content {
    font-size: 0.9em;
    color: var(--text-secondary);
}

.strength-weakness-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
}

.strength-card {
    background: rgba(34, 197, 94, 0.1);
    border-left: 4px solid #22c55e;
    padding: 20px;
    border-radius: 8px;
}

.weakness-card {
    background: rgba(239, 68, 68, 0.1);
    border-left: 4px solid #ef4444;
    padding: 20px;
    border-radius: 8px;
}

.strength-card h4 {
    color: #15803d;
    margin-bottom: 12px;
}

.weakness-card h4 {
    color: #dc2626;
    margin-bottom: 12px;
}

.improvement-tips {
    background: rgba(245, 158, 11, 0.1);
    border-left: 4px solid #f59e0b;
    padding: 20px;
    border-radius: 8px;
    margin-top: 20px;
}

.improvement-tips h4 {
    color: #d97706;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.improvement-list {
    list-style: none;
    padding: 0;
}

.improvement-list li {
    padding: 8px 0;
    color: var(--text-secondary);
    display: flex;
    align-items: flex-start;
    gap: 8px;
}

.improvement-list li::before {
    content: "ğŸ’¡";
    font-size: 1.2em;
}

/* ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼è¿½åŠ  */
.progress-bar {
    width: 100%;
    height: 4px;
    background: var(--border-color);
    border-radius: 2px;
    margin-top: 10px;
    overflow: hidden;
    display: none;
}

.progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--positive-color), var(--positive-color));
    border-radius: 2px;
    transition: width 0.3s ease;
    width: 0%;
}

/* ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
.export-section {
    background: var(--bg-secondary);
    border-radius: 15px;
    padding: 20px;
    margin-top: 20px;
    box-shadow: var(--card-shadow);
    display: none;
}

.export-section h3 {
    color: var(--text-primary);
    margin-bottom: 15px;
}

.export-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.export-button {
    background: #10b981;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 25px;
    cursor: pointer;
    transition: transform 0.2s;
}

.export-button:hover {
    transform: translateY(-2px);
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
@media (max-width: 768px) {
    .container {
        padding: 20px 16px;
    }

    .top-section {
        grid-template-columns: 1fr;
    }
    
    .score-grid {
        grid-template-columns: 1fr;
    }
    
    h1 {
        font-size: 1.5em;
    }
    
    .overall-score .score {
        font-size: 3.5em;
    }

    .score-value {
        font-size: 2em;
    }

    .theme-toggle {
        top: 10px;
        right: 10px;
        padding: 6px 10px;
    }
    
    .strength-weakness-grid {
        grid-template-columns: 1fr;
    }
}

/* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-tertiary);
}

::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-secondary);
}
    </style>
</head>
<body class="dark-mode">
    <div class="container">
        <header>
            <h1>FXå–å¼•è©•ä¾¡ã‚¹ã‚³ã‚¢</h1>
            <p>å–å¼•ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰5ã¤ã®è©•ä¾¡è»¸ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’åˆ†æ</p>
            <button class="theme-toggle" onclick="toggleTheme()">
                <svg viewBox="0 0 24 24" id="theme-icon">
                    <path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>
                </svg>
                <span class="theme-toggle-text">ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰</span>
            </button>
        </header>

        <div class="upload-section">
            <h2>å–å¼•å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h2>
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".html,.htm" />
                <label for="fileInput">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
            </div>
            <div id="fileName"></div>
            <div class="progress-bar" id="progressBar">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
            <div id="fileInfo" class="file-info" style="display: none;">
                <h4>å–å¼•å±¥æ­´æƒ…å ±</h4>
                <div id="tradePeriod"></div>
                <div id="tradeCount"></div>
            </div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>åˆ†æä¸­...</p>
            </div>
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="demo-controls">
            <h3>ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ã§ãƒ†ã‚¹ãƒˆ</h3>
            <button onclick="generateGoodPerformanceData()">å„ªç§€ãªãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ‡ãƒ¼ã‚¿</button>
            <button onclick="generateAveragePerformanceData()">å¹³å‡çš„ãªãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ‡ãƒ¼ã‚¿</button>
            <button onclick="generatePoorPerformanceData()">æ”¹å–„ãŒå¿…è¦ãªãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ‡ãƒ¼ã‚¿</button>
        </div>

        <div id="analysisResults" style="display: none;">
            <div class="top-section">
                <div class="overall-score">
                    <h2>ç·åˆè©•ä¾¡ã‚¹ã‚³ã‚¢ï¼ˆå…¨æœŸé–“ï¼‰</h2>
                    <div class="score" id="overallScore">0.0</div>
                    <div class="rating" id="overallRating">è©•ä¾¡ã‚’è¨ˆç®—ä¸­...</div>
                </div>

                <div class="chart-container">
                    <h3>è©•ä¾¡ã‚¹ã‚³ã‚¢ ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒãƒ£ãƒ¼ãƒˆï¼ˆå…¨æœŸé–“ç·åˆè©•ä¾¡ï¼‰<span class="help-icon" onclick="showHelp('ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒãƒ£ãƒ¼ãƒˆ')">?</span></h3>
                    <canvas id="radarChart" style="max-height: 350px;"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3>ã‚¹ã‚³ã‚¢è©³ç´°ï¼ˆå…¨æœŸé–“ç·åˆè©•ä¾¡ï¼‰</h3>
                <div class="score-grid" id="scoreGrid">
                    <!-- ã‚¹ã‚³ã‚¢ã‚«ãƒ¼ãƒ‰ãŒå‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
                </div>
            </div>

            <div class="chart-container">
                <h3>ã‚¹ã‚³ã‚¢æ¨ç§»åˆ†æ<span class="help-icon" onclick="showHelp('ã‚¹ã‚³ã‚¢æ¨ç§»')">?</span></h3>
                <div class="trend-buttons">
                    <button class="trend-button active" data-metric="overall">ç·åˆã‚¹ã‚³ã‚¢</button>
                    <button class="trend-button" data-metric="entry">ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“</button>
                    <button class="trend-button" data-metric="drawdown">ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§</button>
                    <button class="trend-button" data-metric="riskreward">ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›</button>
                    <button class="trend-button" data-metric="riskmanagement">ãƒªã‚¹ã‚¯ç®¡ç†åŠ›</button>
                    <button class="trend-button" data-metric="stability">åç›Šå®‰å®šåŠ›</button>
                </div>
                <canvas id="trendChart"></canvas>
            </div>
        </div>
    </div>

    <!-- è©³ç´°åˆ†æãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div class="detail-modal" id="detailModal">
        <div class="detail-modal-content">
            <div class="detail-modal-header">
                <div class="detail-modal-title">
                    <span id="modalScoreTitle">ã‚¨ãƒ³ãƒˆãƒªãƒ¼ç²¾åº¦åŠ›</span>
                    <div class="detail-modal-score" id="modalScoreValue">7.8</div>
                </div>
                <div class="detail-modal-close" id="modalClose">&times;</div>
            </div>
            <div class="detail-modal-body" id="modalBody">
                <!-- è©³ç´°å†…å®¹ãŒå‹•çš„ã«æŒ¿å…¥ã•ã‚Œã¾ã™ -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let allTrades = [];
        let activeCharts = [];

        // DOMè¦ç´ ã®å–å¾—
        const fileInput = document.getElementById('fileInput');
        const fileNameEl = document.getElementById('fileName');
        const fileInfoEl = document.getElementById('fileInfo');
        const tradePeriodEl = document.getElementById('tradePeriod');
        const tradeCountEl = document.getElementById('tradeCount');
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('errorMessage');
        const analysisResultsEl = document.getElementById('analysisResults');
        const overallScoreEl = document.getElementById('overallScore');
        const overallRatingEl = document.getElementById('overallRating');
        const scoreGridEl = document.getElementById('scoreGrid');
        const detailModal = document.getElementById('detailModal');
        const modalClose = document.getElementById('modalClose');
        const modalScoreTitle = document.getElementById('modalScoreTitle');
        const modalScoreValue = document.getElementById('modalScoreValue');
        const modalBody = document.getElementById('modalBody');
        let currentTrendMetric = 'overall';

        // ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            const icon = document.getElementById('theme-icon');
            const text = document.querySelector('.theme-toggle-text');
            
            if (isDark) {
                icon.innerHTML = '<path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>';
                text.textContent = 'ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰';
            } else {
                icon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
                text.textContent = 'ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰';
            }
            
            // Chart.jsã®ãƒãƒ£ãƒ¼ãƒˆã‚’å†æç”»
            updateChartsTheme();
        }

        // åˆæœŸåŒ–æ™‚ã«ã‚‚ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã®ãƒãƒ£ãƒ¼ãƒˆãƒ†ãƒ¼ãƒã‚’é©ç”¨
        document.addEventListener('DOMContentLoaded', function() {
            updateChartsTheme();
        });

        // Chart.jsã®ãƒ†ãƒ¼ãƒæ›´æ–°
        function updateChartsTheme() {
            activeCharts.forEach(chart => {
                if (chart && chart.options) {
                    const isDark = document.body.classList.contains('dark-mode');
                    const gridColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
                    const textColor = isDark ? '#aaa' : '#666';
                    
                    if (chart.options.scales) {
                        Object.values(chart.options.scales).forEach(scale => {
                            if (scale.grid) scale.grid.color = gridColor;
                            if (scale.ticks) scale.ticks.color = textColor;
                            if (scale.title) scale.title.color = textColor;
                        });
                    }
                    
                    chart.update();
                }
            });
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        fileInput.addEventListener('change', handleFileUpload);
        modalClose.addEventListener('click', closeDetailModal);
        detailModal.addEventListener('click', (e) => {
            if (e.target === detailModal) closeDetailModal();
        });

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºåˆ¶é™ï¼ˆ10MBï¼‰
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxSize) {
                showError('ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒ10MBã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚ã‚ˆã‚Šå°ã•ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                fileInput.value = '';
                return;
            }

            // ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ãƒã‚§ãƒƒã‚¯
            if (!file.name.match(/\.(html|htm)$/i)) {
                showError('HTMLãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.html ã¾ãŸã¯ .htmï¼‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                fileInput.value = '';
                return;
            }

            resetAnalysisView();
            fileNameEl.textContent = `é¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«: ${file.name}`;
            setLoading(true);

            const reader = new FileReader();
            reader.onerror = () => {
                showError('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                setLoading(false);
            };
            reader.onload = (e) => {
                try {
                    parseMT4History(e.target.result);
                } catch (error) {
                    console.error('Parse error:', error);
                    showError('ãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ­£ã—ã„MT4/MT5ã®å–å¼•å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                    setLoading(false);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        function parseMT4History(htmlContent) {
            try {
                console.log('HTML content length:', htmlContent.length);
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                
                let parsedTrades = [];
                
                // ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰è§£æ
                const tables = doc.querySelectorAll('table');
                console.log('Found tables:', tables.length);
                
                for (let table of tables) {
                    const tableTrades = parseTableData(table);
                    if (tableTrades.length > 0) {
                        parsedTrades = parsedTrades.concat(tableTrades);
                        console.log(`Parsed ${tableTrades.length} trades from table`);
                    }
                }
                
                // ä»£æ›¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè§£æ
                if (parsedTrades.length === 0) {
                    parsedTrades = parseAlternativeFormat(htmlContent);
                }
                
                // æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹è§£æ
                if (parsedTrades.length === 0) {
                    parsedTrades = parseWithRegex(htmlContent);
                }
                
                console.log(`Total parsed trades: ${parsedTrades.length}`);
                onFileParsed(parsedTrades);
                
            } catch (error) {
                console.error('Parse error:', error);
                showError('ãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            } finally {
                setLoading(false);
            }
        }

        function parseTableData(table) {
            const rows = table.querySelectorAll('tr');
            if (rows.length < 2) return [];
            
            const parsedTrades = [];
            let headerMapping = {};
            let dataStartIndex = -1;

            // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’æ¢ã™
            for (let i = 0; i < Math.min(15, rows.length); i++) {
                const cells = rows[i].querySelectorAll('td, th');
                if (cells.length < 8) continue;
                
                const cellTexts = Array.from(cells).map(cell => 
                    cell.textContent.trim().toLowerCase().replace(/\s+/g, ' ')
                );
                
                // ãƒ˜ãƒƒãƒ€ãƒ¼æ¤œå‡º
                const hasTicket = cellTexts.some(text => 
                    text.includes('ticket') || text.includes('order') || text.includes('#')
                );
                const hasTime = cellTexts.some(text => 
                    text.includes('time') || text.includes('date') || text.includes('é–‹å§‹') || text.includes('çµ‚äº†')
                );
                const hasType = cellTexts.some(text => 
                    text.includes('type') || text.includes('å£²è²·') || text.includes('buy') || text.includes('sell')
                );
                const hasProfit = cellTexts.some(text => 
                    text.includes('profit') || text.includes('æç›Š') || text.includes('pl') || text.includes('pnl')
                );
                
                if ((hasTicket || hasTime) && (hasType || hasProfit)) {
                    console.log('Header found at row:', i, cellTexts);
                    
                    // ãƒ˜ãƒƒãƒ€ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æ§‹ç¯‰
                    cellTexts.forEach((text, idx) => {
                        if (text.includes('ticket') || text.includes('order') || text === '#' || 
                            (text.includes('no') && text.length < 5)) {
                            headerMapping.ticket = idx;
                        }
                        if (text.includes('open') && text.includes('time') || 
                            text.includes('é–‹å§‹') || text.includes('start')) {
                            headerMapping.openTime = idx;
                        }
                        if (text.includes('close') && text.includes('time') || 
                            text.includes('çµ‚äº†') || text.includes('end')) {
                            headerMapping.closeTime = idx;
                        }
                        if (text.includes('type') || text.includes('å£²è²·') || 
                            (text.includes('buy') || text.includes('sell')) && text.length < 10) {
                            headerMapping.type = idx;
                        }
                        if (text.includes('size') || text.includes('lots') || text.includes('volume') || 
                            text.includes('ãƒ­ãƒƒãƒˆ') || text.includes('æ•°é‡')) {
                            headerMapping.size = idx;
                        }
                        if (text.includes('symbol') || text.includes('item') || text.includes('pair') || 
                            text.includes('é€šè²¨') || text.includes('éŠ˜æŸ„')) {
                            headerMapping.symbol = idx;
                        }
                        if (text.includes('open') && text.includes('price') || 
                            text.includes('é–‹å§‹ä¾¡æ ¼') || text.includes('å§‹å€¤')) {
                            headerMapping.openPrice = idx;
                        }
                        if (text.includes('close') && text.includes('price') || 
                            text.includes('çµ‚äº†ä¾¡æ ¼') || text.includes('çµ‚å€¤')) {
                            headerMapping.closePrice = idx;
                        }
                        if (text.includes('profit') || text.includes('æç›Š') || text.includes('pl') || 
                            text.includes('pnl') || text.includes('p/l')) {
                            headerMapping.profit = idx;
                        }
                    });
                    
                    dataStartIndex = i + 1;
                    break;
                }
            }

            if (dataStartIndex === -1) {
                console.log('No header found');
                return [];
            }

            console.log('Header mapping:', headerMapping);

            // ãƒ‡ãƒ¼ã‚¿è¡Œã‚’è§£æ
            for (let i = dataStartIndex; i < rows.length; i++) {
                const cells = rows[i].querySelectorAll('td');
                if (cells.length < 8) continue;
                
                const cellTexts = Array.from(cells).map(cell => cell.textContent.trim());
                
                // ãƒã‚±ãƒƒãƒˆç•ªå·ã®æ¤œè¨¼
                const ticketText = cellTexts[headerMapping.ticket] || '';
                if (headerMapping.ticket !== undefined && !/\d/.test(ticketText)) continue;
                
                // å–å¼•ã‚¿ã‚¤ãƒ—ã®æ¤œè¨¼
                const type = (cellTexts[headerMapping.type] || '').toLowerCase();
                const isBuyOrSell = type.includes('buy') || type.includes('sell') || 
                                  type.includes('è³¼å…¥') || type.includes('å£²å´');
                
                // æç›Šãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
                let profit = 0;
                if (headerMapping.profit !== undefined) {
                    const profitText = cellTexts[headerMapping.profit] || '';
                    const profitMatch = profitText.match(/-?\d+(?:\.\d+)?/);
                    if (profitMatch) {
                        profit = parseFloat(profitMatch[0]);
                    }
                } else {
                    const lastCellText = cellTexts[cellTexts.length - 1] || '';
                    const profitMatch = lastCellText.match(/-?\d+(?:\.\d+)?/);
                    if (profitMatch) {
                        profit = parseFloat(profitMatch[0]);
                    }
                }
                
                if (isNaN(profit)) continue;

                // æ—¥æ™‚ã®è§£æ
                const openTime = parseDateTime(cellTexts[headerMapping.openTime]);
                const closeTime = parseDateTime(cellTexts[headerMapping.closeTime]) || 
                                parseDateTime(cellTexts[headerMapping.openTime]);
                
                if (!openTime) continue;

                // é€šè²¨ãƒšã‚¢ã®å–å¾—
                let symbol = cellTexts[headerMapping.symbol] || 'UNKNOWN';
                if (symbol === 'UNKNOWN' && cellTexts.length > 5) {
                    for (let cell of cellTexts) {
                        if (/^[A-Z]{6}$/.test(cell) || /^[A-Z]{3}\/[A-Z]{3}$/.test(cell)) {
                            symbol = cell;
                            break;
                        }
                    }
                }

                const trade = {
                    ticket: ticketText,
                    openTime,
                    closeTime: closeTime || openTime,
                    type: isBuyOrSell ? (type.includes('buy') || type.includes('è³¼å…¥') ? 'buy' : 'sell') : 'unknown',
                    size: parseFloat(cellTexts[headerMapping.size] || '1') || 1,
                    symbol: symbol,
                    openPrice: parseFloat(cellTexts[headerMapping.openPrice] || '0') || 0,
                    closePrice: parseFloat(cellTexts[headerMapping.closePrice] || '0') || 0,
                    profit,
                    isWin: profit > 0,
                    duration: closeTime && closeTime > openTime ? closeTime.getTime() - openTime.getTime() : 3600000
                };

                parsedTrades.push(trade);
                console.log(`Parsed trade ${parsedTrades.length}:`, trade);
            }
            
            return parsedTrades;
        }

        // ä»£æ›¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè§£æ
        function parseAlternativeFormat(htmlContent) {
            console.log('Trying alternative format parsing...');
            const trades = [];
            
            const lines = htmlContent.split(/\n|<br>|<\/tr>/).filter(line => line.trim());
            
            for (let line of lines) {
                const dateMatch = line.match(/\d{4}[./-]\d{2}[./-]\d{2}/);
                const profitMatch = line.match(/-?\d+\.?\d*/g);
                const symbolMatch = line.match(/[A-Z]{6}|[A-Z]{3}\/[A-Z]{3}/);
                
                if (dateMatch && profitMatch && profitMatch.length > 0) {
                    const profit = parseFloat(profitMatch[profitMatch.length - 1]);
                    if (!isNaN(profit)) {
                        trades.push({
                            openTime: new Date(dateMatch[0]),
                            closeTime: new Date(dateMatch[0]),
                            profit,
                            symbol: symbolMatch ? symbolMatch[0] : 'UNKNOWN',
                            isWin: profit > 0,
                            type: Math.random() > 0.5 ? 'buy' : 'sell',
                            size: 1,
                            duration: 3600000
                        });
                    }
                }
            }
            
            console.log(`Alternative format found ${trades.length} trades`);
            return trades;
        }

        // æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹è§£æ
        function parseWithRegex(htmlContent) {
            console.log('Trying regex parsing...');
            const trades = [];
            
            const patterns = [
                /(\d{4}[./-]\d{2}[./-]\d{2}).*?([A-Z]{6}|[A-Z]{3}\/[A-Z]{3}).*?(-?\d+\.?\d*)/g,
                /(-?\d+\.?\d+)/g
            ];
            
            for (let pattern of patterns) {
                const matches = [...htmlContent.matchAll(pattern)];
                
                for (let match of matches) {
                    if (match.length >= 2) {
                        const profit = parseFloat(match[match.length - 1]);
                        if (!isNaN(profit) && Math.abs(profit) > 0.01) {
                            trades.push({
                                openTime: new Date(),
                                closeTime: new Date(),
                                profit,
                                symbol: match[2] || 'UNKNOWN',
                                isWin: profit > 0,
                                type: Math.random() > 0.5 ? 'buy' : 'sell',
                                size: 1,
                                duration: 3600000
                            });
                        }
                    }
                }
                
                if (trades.length > 0) break;
            }
            
            console.log(`Regex parsing found ${trades.length} trades`);
            return trades.slice(0, 200);
        }

        function parseDateTime(dateStr) {
            if (!dateStr) return null;
            
            const patterns = [
                /(\d{4})[./](\d{2})[./](\d{2})\s+(\d{2}):(\d{2})/,
                /(\d{4})[\/](\d{2})[\/](\d{2})\s+(\d{2}):(\d{2})/,
                /(\d{2})[./](\d{2})[./](\d{4})\s+(\d{2}):(\d{2})/,
                /(\d{2})[\/](\d{2})[\/](\d{4})\s+(\d{2}):(\d{2})/,
                /(\d{4})[-](\d{2})[-](\d{2})\s+(\d{2}):(\d{2})/
            ];
            
            for (let pattern of patterns) {
                const match = dateStr.match(pattern);
                if (match) {
                    let year, month, day, hour, minute;
                    
                    if (pattern.source.startsWith('(\\d{4})')) {
                        [, year, month, day, hour, minute] = match.map(Number);
                    } else {
                        if (pattern.source.includes('[./]')) {
                            [, day, month, year, hour, minute] = match.map(Number);
                        } else {
                            [, month, day, year, hour, minute] = match.map(Number);
                        }
                    }
                    
                    const date = new Date(year, month - 1, day, hour || 0, minute || 0);
                    if (!isNaN(date.getTime()) && year > 1990 && year < 2030) {
                        return date;
                    }
                }
            }
            
            const isoDate = new Date(dateStr);
            if (!isNaN(isoDate.getTime())) {
                return isoDate;
            }
            
            return null;
        }

        function onFileParsed(parsedTrades) {
            console.log('Parsed trades received:', parsedTrades.length);
            
            if (parsedTrades && parsedTrades.length > 0) {
                const cleanedTrades = parsedTrades.filter(trade => {
                    // åŸºæœ¬çš„ãªæ¤œè¨¼ã®ã¿
                    if (trade.profit === undefined || isNaN(trade.profit)) return false;
                    if (!trade.openTime || !(trade.openTime instanceof Date) || isNaN(trade.openTime.getTime())) return false;
                    
                    // å–å¼•æ™‚é–“ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                    if (trade.duration && trade.duration < 0) {
                        console.warn('è² ã®å–å¼•æ™‚é–“ã‚’æ¤œå‡º:', trade.duration);
                        trade.duration = Math.abs(trade.duration);
                    }
                    
                    // æ—¥ä»˜ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆ2000å¹´ã€œ2030å¹´ï¼‰
                    const year = trade.openTime.getFullYear();
                    if (year < 2000 || year > 2030) {
                        console.warn('ç•°å¸¸ãªæ—¥ä»˜ã‚’æ¤œå‡º:', trade.openTime);
                        return false;
                    }
                    
                    // é€šè²¨ãƒšã‚¢ã®æ­£è¦åŒ–
                    if (trade.symbol === 'UNKNOWN' || !trade.symbol) {
                        trade.symbol = 'USDJPY'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
                    }
                    
                    return true;
                });
                
                console.log(`Cleaned trades: ${cleanedTrades.length}/${parsedTrades.length}`);
                
                if (cleanedTrades.length === 0) {
                    showError('æœ‰åŠ¹ãªå–å¼•ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                    return;
                }
                
                // æœ€ä½å–å¼•æ•°ã®ãƒã‚§ãƒƒã‚¯
                if (cleanedTrades.length < 10) {
                    if (!confirm(`å–å¼•ãƒ‡ãƒ¼ã‚¿ãŒ${cleanedTrades.length}ä»¶ã¨å°‘ãªã„ã§ã™ãŒã€åˆ†æã‚’ç¶šã‘ã¾ã™ã‹ï¼Ÿ\nï¼ˆç²¾åº¦ãŒä½ä¸‹ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼‰`)) {
                        return;
                    }
                }
                
                allTrades = cleanedTrades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
                
                const totalProfit = allTrades.reduce((sum, t) => sum + t.profit, 0);
                const winTrades = allTrades.filter(t => t.isWin);
                const winRate = (winTrades.length / allTrades.length * 100).toFixed(1);
                
                console.log(`è§£æå®Œäº†: ${allTrades.length}å–å¼•, å‹ç‡${winRate}%, ç·æç›Š${totalProfit.toFixed(2)}`);
                
                displayFileInfo(allTrades);
                calculateAndDisplayScores(allTrades);
            } else {
                showError('ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚MT4/MT5ã®å–å¼•å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            }
        }

        function displayFileInfo(trades) {
            if (trades.length === 0) return;
            
            const startDate = new Date(Math.min(...trades.map(t => t.openTime.getTime())));
            const endDate = new Date(Math.max(...trades.map(t => t.closeTime.getTime())));
            const daysDiff = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
            
            const formatDate = (date) => {
                return `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
            };
            
            let periodDescription = '';
            if (daysDiff <= 7) {
                periodDescription = 'ï¼ˆæ—¥åˆ¥æ¨ç§»ã§åˆ†æï¼‰';
            } else if (daysDiff <= 35) {
                periodDescription = 'ï¼ˆé€±åˆ¥æ¨ç§»ã§åˆ†æï¼‰';
            } else if (daysDiff <= 120) {
                periodDescription = 'ï¼ˆæœˆåˆ¥æ¨ç§»ã§åˆ†æï¼‰';
            } else {
                periodDescription = 'ï¼ˆå››åŠæœŸåˆ¥æ¨ç§»ã§åˆ†æï¼‰';
            }
            
            tradePeriodEl.textContent = `æœŸé–“: ${formatDate(startDate)} ï½ ${formatDate(endDate)} ${periodDescription}`;
            tradeCountEl.textContent = `ç·å–å¼•æ•°: ${trades.length}å›ï¼ˆ${daysDiff}æ—¥é–“ï¼‰`;
            fileInfoEl.style.display = 'block';
        }

        // è©•ä¾¡ã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateScores(trades) {
            const winTrades = trades.filter(t => t.isWin);
            const lossTrades = trades.filter(t => !t.isWin);
            const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
            const winRate = trades.length > 0 ? winTrades.length / trades.length : 0;

            const entryAccuracy = calculateEntryAccuracy(trades, winRate);
            const drawdownResistance = calculateDrawdownResistance(trades, totalProfit);
            const riskRewardPower = calculateRiskRewardPower(winTrades, lossTrades);
            const riskManagement = calculateRiskManagement(trades, lossTrades);
            const profitStability = calculateProfitStability(trades);

            return {
                entryAccuracy,
                drawdownResistance,
                riskRewardPower,
                riskManagement,
                profitStability
            };
        }

        function calculateEntryAccuracy(trades, winRate) {
            if (trades.length === 0) return { 
                score: 0, 
                metrics: { 
                    'å‹ç‡': '0%', 
                    'ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦': '0ç‚¹', 
                    'ç·åˆåˆ¤å®š': 'ãƒ‡ãƒ¼ã‚¿ãªã—' 
                } 
            };
            
            const winRateScore = Math.min(winRate * 150, 100);
            const sessionScore = calculateSessionScore(trades);
            
            const hourlyWinRates = {};
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (!hourlyWinRates[hour]) hourlyWinRates[hour] = { wins: 0, total: 0 };
                hourlyWinRates[hour].total++;
                if (trade.isWin) hourlyWinRates[hour].wins++;
            });
            
            const hourlyRates = Object.values(hourlyWinRates)
                .filter(data => data.total >= 3)
                .map(data => data.wins / data.total);
            
            let stabilityScore = 50;
            if (hourlyRates.length > 1) {
                const avgRate = hourlyRates.reduce((sum, rate) => sum + rate, 0) / hourlyRates.length;
                const variance = hourlyRates.reduce((sum, rate) => sum + Math.pow(rate - avgRate, 2), 0) / hourlyRates.length;
                const cv = Math.sqrt(variance) / avgRate;
                stabilityScore = Math.max(20, 100 - (cv * 150));
            }
            
            const finalScore = Math.min((winRateScore * 0.5 + sessionScore * 0.25 + stabilityScore * 0.25), 100) / 10;
            
            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    'å‹ç‡': `${(winRate * 100).toFixed(1)}%`,
                    'ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦': `${sessionScore.toFixed(0)}ç‚¹`,
                    'ç·åˆåˆ¤å®š': finalScore >= 7 ? 'å„ªç§€' : finalScore >= 5 ? 'è‰¯å¥½' : 'è¦æ”¹å–„'
                }
            };
        }

        function calculateSessionScore(trades) {
            if (trades.length === 0) return 0;
            
            let sessionTrades = 0;
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if ((hour >= 9 && hour <= 15) || (hour >= 16 && hour <= 18) || hour >= 22 || hour <= 1) {
                    sessionTrades++;
                }
            });
            const sessionRatio = sessionTrades / trades.length;
            return Math.min(sessionRatio * 120, 100);
        }

        function calculateDrawdownResistance(trades, totalProfit) {
            if (trades.length === 0) return { score: 0, metrics: { 'æœ€å¤§DD': 'Â¥0', 'DDç‡': '0%', 'å›å¾©åŠ›': 'ãƒ‡ãƒ¼ã‚¿ãªã—' } };
            
            let peak = 0;
            let maxDrawdown = 0;
            let cumulative = 0;
            
            trades.forEach(trade => {
                cumulative += trade.profit;
                if (cumulative > peak) peak = cumulative;
                const drawdown = peak - cumulative;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });

            let score = 100;
            if (peak > 0) {
                const drawdownRatio = maxDrawdown / peak;
                score = Math.max(0, 100 - (drawdownRatio * 200));
            }

            const drawdownRatio = peak > 0 ? maxDrawdown / peak : 0;

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    'æœ€å¤§DD': `Â¥${Math.round(maxDrawdown).toLocaleString()}`,
                    'DDç‡': `${(drawdownRatio * 100).toFixed(1)}%`,
                    'å›å¾©åŠ›': score >= 70 ? 'å„ªç§€' : score >= 50 ? 'è‰¯å¥½' : 'è¦æ”¹å–„'
                }
            };
        }

        function calculateRiskRewardPower(winTrades, lossTrades) {
            if (winTrades.length === 0 && lossTrades.length === 0) {
                return { 
                    score: 0, 
                    metrics: { 
                        'RRæ¯”': '0.00', 
                        'å¹³å‡åˆ©ç›Š': 'Â¥0', 
                        'å¹³å‡æå¤±': 'Â¥0' 
                    } 
                };
            }
            
            const avgWin = winTrades.length > 0 ? 
                winTrades.reduce((sum, t) => sum + Math.abs(t.profit), 0) / winTrades.length : 0;
            const avgLoss = lossTrades.length > 0 ? 
                Math.abs(lossTrades.reduce((sum, t) => sum + t.profit, 0) / lossTrades.length) : 0;

            let score = 0;
            let riskRewardRatio = 0;
            
            if (avgLoss > 0 && avgWin > 0) {
                riskRewardRatio = avgWin / avgLoss;
                
                if (riskRewardRatio >= 3.0) score = 100;
                else if (riskRewardRatio >= 2.5) score = 90;
                else if (riskRewardRatio >= 2.0) score = 80;
                else if (riskRewardRatio >= 1.5) score = 70;
                else if (riskRewardRatio >= 1.2) score = 60;
                else if (riskRewardRatio >= 1.0) score = 50;
                else if (riskRewardRatio >= 0.8) score = 40;
                else if (riskRewardRatio >= 0.6) score = 30;
                else if (riskRewardRatio >= 0.4) score = 20;
                else score = 10;
                
                const winRate = winTrades.length / (winTrades.length + lossTrades.length);
                if (winRate > 0.6 && riskRewardRatio >= 1.0) {
                    score = Math.min(score + 10, 100);
                }
                
            } else if (winTrades.length > 0 && lossTrades.length === 0) {
                // æå¤±ãŒãªã„å ´åˆ
                score = 95;
                riskRewardRatio = 999;
            } else if (winTrades.length === 0 && lossTrades.length > 0) {
                // åˆ©ç›ŠãŒãªã„å ´åˆ
                score = 0;
                riskRewardRatio = 0;
            }

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    'RRæ¯”': riskRewardRatio === 999 ? 'âˆ' : riskRewardRatio === 0 ? '0.00' : riskRewardRatio.toFixed(2),
                    'å¹³å‡åˆ©ç›Š': `Â¥${Math.round(avgWin).toLocaleString()}`,
                    'å¹³å‡æå¤±': `Â¥${Math.round(avgLoss).toLocaleString()}`
                }
            };
        }

        function calculateRiskManagement(trades, lossTrades) {
            if (trades.length === 0) {
                return { score: 0, metrics: { 'æåˆ‡ã‚Šå¾¹åº•åº¦': '0%', 'æœ€å¤§æå¤±': 'Â¥0', 'ãƒªã‚¹ã‚¯ç®¡ç†': 'ãƒ‡ãƒ¼ã‚¿ãªã—' } };
            }
            
            if (lossTrades.length === 0) {
                // æå¤±ãŒãªã„å ´åˆã®é©åˆ‡ãªè¡¨ç¾
                return {
                    score: 9.5, // æº€ç‚¹ã§ã¯ãªã9.5ç‚¹
                    metrics: {
                        'æåˆ‡ã‚Šå¾¹åº•åº¦': 'æå¤±ãªã—',
                        'æœ€å¤§æå¤±': 'Â¥0',
                        'ãƒªã‚¹ã‚¯ç®¡ç†': 'å„ªç§€'
                    }
                };
            }

            const losses = lossTrades.map(t => Math.abs(t.profit));
            const maxLoss = Math.max(...losses);
            const avgLoss = losses.reduce((sum, loss) => sum + loss, 0) / losses.length;
            
            const bigLossThreshold = avgLoss * 3;
            const bigLossCount = losses.filter(loss => loss > bigLossThreshold).length;
            const bigLossRatio = bigLossCount / lossTrades.length;
            
            const lossVariance = losses.reduce((sum, loss) => sum + Math.pow(loss - avgLoss, 2), 0) / losses.length;
            const lossStdDev = Math.sqrt(lossVariance);
            const lossCV = avgLoss > 0 ? lossStdDev / avgLoss : 0;
            
            let score = 100;
            score -= (bigLossRatio * 50);
            score -= Math.min(lossCV * 30, 30);
            score = Math.max(0, score);

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    'æåˆ‡ã‚Šå¾¹åº•åº¦': `${((1 - bigLossRatio) * 100).toFixed(1)}%`,
                    'æœ€å¤§æå¤±': `Â¥${Math.round(maxLoss).toLocaleString()}`,
                    'ãƒªã‚¹ã‚¯ç®¡ç†': score >= 70 ? 'å„ªç§€' : score >= 50 ? 'è‰¯å¥½' : 'è¦æ”¹å–„'
                }
            };
        }

        function calculateProfitStability(trades) {
            if (trades.length === 0) {
                return { 
                    score: 0, 
                    metrics: { 
                        'å®‰å®šåº¦': 'ãƒ‡ãƒ¼ã‚¿ãªã—', 
                        'å¹³å‡æœˆåˆ©': 'Â¥0', 
                        'æ¨™æº–åå·®': 'Â¥0' 
                    } 
                };
            }
            
            const dateRange = trades[trades.length - 1].openTime.getTime() - trades[0].openTime.getTime();
            const daysDiff = dateRange / (1000 * 60 * 60 * 24);
            
            if (daysDiff < 30) {
                return calculateWeeklyStability(trades, daysDiff);
            } else if (daysDiff < 90) {
                return calculatePartialMonthlyStability(trades, daysDiff);
            } else {
                return calculateFullMonthlyStability(trades, daysDiff);
            }
        }
        
        function calculateWeeklyStability(trades, daysDiff) {
            const weeklyProfits = {};
            trades.forEach(trade => {
                const weekKey = Math.floor((trade.openTime.getTime() - trades[0].openTime.getTime()) / (7 * 24 * 60 * 60 * 1000));
                if (!weeklyProfits[weekKey]) weeklyProfits[weekKey] = 0;
                weeklyProfits[weekKey] += trade.profit;
            });
            
            const profits = Object.values(weeklyProfits);
            if (profits.length < 2) {
                const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
                return { 
                    score: totalProfit >= 0 ? 5.0 : 2.5, 
                    metrics: { 
                        'æœŸé–“': `${daysDiff.toFixed(0)}æ—¥é–“`,
                        'ç·æç›Š': `Â¥${Math.round(totalProfit).toLocaleString()}`,
                        'å®‰å®šåº¦': 'æœŸé–“ä¸è¶³'
                    } 
                };
            }
            
            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else {
                stability = 0.1;
            }
            
            const plusWeeks = profits.filter(p => p > 0).length;
            const plusRatio = plusWeeks / profits.length;
            
            const finalScore = Math.min((stability * 60 + plusRatio * 40), 100) / 10;
            
            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    'é€±æ¬¡å®‰å®šåº¦': `${(stability * 100).toFixed(1)}%`,
                    'å¹³å‡é€±åˆ©': `Â¥${Math.round(mean).toLocaleString()}`,
                    'ãƒ—ãƒ©ã‚¹é€±ç‡': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }
        
        function calculatePartialMonthlyStability(trades, daysDiff) {
            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            const profits = Object.values(monthlyProfits);
            const monthCount = profits.length;
            
            if (monthCount < 2) {
                const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
                return { 
                    score: totalProfit >= 0 ? 5.5 : 3.0, 
                    metrics: { 
                        'æœŸé–“': `${(daysDiff / 30).toFixed(1)}ãƒ¶æœˆ`,
                        'ç·æç›Š': `Â¥${Math.round(totalProfit).toLocaleString()}`,
                        'å®‰å®šåº¦': 'æœŸé–“ã‚„ã‚„ä¸è¶³'
                    } 
                };
            }

            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else {
                stability = 0.1;
            }
            
            const plusMonths = profits.filter(p => p > 0).length;
            const plusRatio = plusMonths / monthCount;
            
            const finalScore = Math.min((stability * 65 + plusRatio * 35), 100) / 10;

            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    'æœˆæ¬¡å®‰å®šåº¦': `${(stability * 100).toFixed(1)}%`,
                    'å¹³å‡æœˆåˆ©': `Â¥${Math.round(mean).toLocaleString()}`,
                    'ãƒ—ãƒ©ã‚¹æœˆç‡': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }
        
        function calculateFullMonthlyStability(trades, daysDiff) {
            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            const profits = Object.values(monthlyProfits);
            const monthCount = profits.length;

            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else if (mean === 0) {
                stability = stdDev < 1000 ? 0.5 : 0.2;
            } else {
                stability = 0.1;
            }
            
            const plusMonths = profits.filter(p => p > 0).length;
            const plusRatio = plusMonths / monthCount;
            
            const periodBonus = Math.min((monthCount - 3) * 2, 10) / 10;
            
            const finalScore = Math.min((stability * 70 + plusRatio * 30), 100) / 10 + periodBonus;

            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    'æœˆæ¬¡å®‰å®šåº¦': `${(stability * 100).toFixed(1)}%`,
                    'å¹³å‡æœˆåˆ©': `Â¥${Math.round(mean).toLocaleString()}`,
                    'ãƒ—ãƒ©ã‚¹æœˆç‡': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }

        function calculateAndDisplayScores(trades) {
            const scores = calculateScores(trades);
            
            const overallScore = (
                scores.entryAccuracy.score +
                scores.drawdownResistance.score +
                scores.riskRewardPower.score +
                scores.riskManagement.score +
                scores.profitStability.score
            ) / 5;

            let rating = '';
            if (overallScore >= 8) rating = 'Sç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆå“è¶Šï¼‰';
            else if (overallScore >= 7) rating = 'Aç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆå„ªç§€ï¼‰';
            else if (overallScore >= 6) rating = 'Bç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆè‰¯å¥½ï¼‰';
            else if (overallScore >= 5) rating = 'Cç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆå¹³å‡ï¼‰';
            else if (overallScore >= 4) rating = 'Dç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆè¦æ”¹å–„ï¼‰';
            else rating = 'Eç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆå¤§å¹…æ”¹å–„å¿…è¦ï¼‰';

            overallScoreEl.textContent = overallScore.toFixed(1);
            overallRatingEl.textContent = rating;

            createScoreCards(scores);
            createRadarChart(scores);
            createTrendChart(trades, scores);

            analysisResultsEl.style.display = 'block';
        }

        function createScoreCards(scores) {
            const scoreData = [
                { name: 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“', data: scores.entryAccuracy },
                { name: 'ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§', data: scores.drawdownResistance },
                { name: 'ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›', data: scores.riskRewardPower },
                { name: 'ãƒªã‚¹ã‚¯ç®¡ç†åŠ›', data: scores.riskManagement },
                { name: 'åç›Šå®‰å®šåŠ›', data: scores.profitStability }
            ];

            scoreGridEl.innerHTML = scoreData.map((item, index) => {
                const scoreLevel = item.data.score >= 7 ? 'high' : item.data.score >= 4 ? 'mid' : 'low';
                return `
                <div class="score-card" onclick="showDetailModal('${item.name}', ${item.data.score}, ${index})">
                    <div class="score-header">
                        <div class="score-title">${item.name}</div>
                        <div class="score-value" data-score-level="${scoreLevel}">${item.data.score}</div>
                    </div>
                    <div class="score-metrics">
                        ${Object.entries(item.data.metrics).map(([key, value]) => `
                            <div class="metric-item">
                                <span class="metric-label">${key}:</span>
                                <span class="metric-value">${value}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            }).join('');
        }

        function createRadarChart(scores) {
            const ctx = document.getElementById('radarChart').getContext('2d');
            
            activeCharts.forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            activeCharts = [];

            if (typeof Chart === 'undefined') {
                console.error('Chart.js ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            const isDark = document.body.classList.contains('dark-mode');
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDark ? '#aaa' : '#666';

            const chartLabels = [
                'ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“',
                'ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§', 
                'ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›',
                'ãƒªã‚¹ã‚¯ç®¡ç†åŠ›',
                'åç›Šå®‰å®šåŠ›'
            ];

            const chart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'è©•ä¾¡ã‚¹ã‚³ã‚¢',
                        data: [
                            scores.entryAccuracy.score,
                            scores.drawdownResistance.score,
                            scores.riskRewardPower.score,
                            scores.riskManagement.score,
                            scores.profitStability.score
                        ],
                        fill: true,
                        backgroundColor: isDark ? 'rgba(0, 200, 255, 0.2)' : 'rgba(0, 126, 255, 0.2)',
                        borderColor: isDark ? 'rgba(0, 200, 255, 1)' : 'rgba(0, 126, 255, 1)',
                        pointBackgroundColor: isDark ? 'rgba(0, 200, 255, 1)' : 'rgba(0, 126, 255, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: isDark ? 'rgba(0, 200, 255, 1)' : 'rgba(0, 126, 255, 1)',
                        borderWidth: 2,
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 10,
                            ticks: {
                                stepSize: 2,
                                font: {
                                    size: 11
                                },
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            },
                            angleLines: {
                                color: gridColor
                            },
                            pointLabels: {
                                font: {
                                    size: 12,
                                    weight: '500'
                                },
                                color: textColor
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            activeCharts.push(chart);
        }

        function createTrendChart(trades, scores) {
            const timeAxisInfo = determineTimeAxis(trades);
            const periodScores = calculatePeriodScores(trades, timeAxisInfo);
            
            updateTrendButtons(timeAxisInfo);
            
            // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰æ–°è¦è¿½åŠ 
            document.querySelectorAll('.trend-button').forEach(button => {
                // å¤ã„ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆã‚¯ãƒ­ãƒ¼ãƒ³ã§ç½®ãæ›ãˆï¼‰
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);
                
                newButton.addEventListener('click', function() {
                    document.querySelectorAll('.trend-button').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    currentTrendMetric = this.dataset.metric;
                    updateTrendChart(periodScores, timeAxisInfo);
                });
            });
            
            updateTrendChart(periodScores, timeAxisInfo);
        }

        function determineTimeAxis(trades) {
            if (!trades || trades.length === 0) {
                return { type: 'demo', unit: 'æœŸé–“', periods: 4 };
            }

            const startDate = new Date(Math.min(...trades.map(t => t.openTime.getTime())));
            const endDate = new Date(Math.max(...trades.map(t => t.openTime.getTime())));
            const daysDiff = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);
            
            console.log(`Data period: ${daysDiff.toFixed(0)} days`);

            if (daysDiff <= 7) {
                return { 
                    type: 'daily', 
                    unit: 'æ—¥åˆ¥', 
                    periods: Math.max(3, Math.ceil(daysDiff)),
                    startDate,
                    endDate
                };
            } else if (daysDiff <= 35) {
                return { 
                    type: 'weekly', 
                    unit: 'é€±åˆ¥', 
                    periods: Math.max(3, Math.ceil(daysDiff / 7)),
                    startDate,
                    endDate
                };
            } else if (daysDiff <= 120) {
                return { 
                    type: 'monthly', 
                    unit: 'æœˆåˆ¥', 
                    periods: Math.max(2, Math.ceil(daysDiff / 30)),
                    startDate,
                    endDate
                };
            } else {
                return { 
                    type: 'quarterly', 
                    unit: 'å››åŠæœŸåˆ¥', 
                    periods: Math.max(2, Math.ceil(daysDiff / 90)),
                    startDate,
                    endDate
                };
            }
        }

        function updateTrendButtons(timeAxisInfo) {
            const trendButtonsContainer = document.querySelector('.trend-buttons');
            trendButtonsContainer.innerHTML = `
                <button class="trend-button active" data-metric="overall">ç·åˆã‚¹ã‚³ã‚¢</button>
                <button class="trend-button" data-metric="entry">ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“</button>
                <button class="trend-button" data-metric="drawdown">ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§</button>
                <button class="trend-button" data-metric="riskreward">ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›</button>
                <button class="trend-button" data-metric="riskmanagement">ãƒªã‚¹ã‚¯ç®¡ç†åŠ›</button>
                <button class="trend-button" data-metric="stability">åç›Šå®‰å®šåŠ›</button>
            `;
            
            const chartTitle = document.querySelector('.chart-container h3');
            if (chartTitle && chartTitle.textContent.includes('ã‚¹ã‚³ã‚¢æ¨ç§»åˆ†æ')) {
                chartTitle.innerHTML = `ã‚¹ã‚³ã‚¢æ¨ç§»åˆ†æï¼ˆ${timeAxisInfo.unit}æ¨ç§»ï¼‰<span class="help-icon" onclick="showHelp('ã‚¹ã‚³ã‚¢æ¨ç§»')">?</span>`;
            }
        }

        function calculatePeriodScores(trades, timeAxisInfo) {
            if (!trades || trades.length === 0 || timeAxisInfo.type === 'demo') {
                return null;
            }

            const periodData = {};
            
            trades.forEach(trade => {
                let periodKey;
                
                switch(timeAxisInfo.type) {
                    case 'daily':
                        periodKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}-${String(trade.openTime.getDate()).padStart(2, '0')}`;
                        break;
                    case 'weekly':
                        const weekStart = new Date(trade.openTime);
                        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                        periodKey = `${weekStart.getFullYear()}-W${Math.ceil(weekStart.getDate() / 7)}`;
                        break;
                    case 'monthly':
                        periodKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                        break;
                    case 'quarterly':
                        const quarter = Math.ceil((trade.openTime.getMonth() + 1) / 3);
                        periodKey = `${trade.openTime.getFullYear()}-Q${quarter}`;
                        break;
                }
                
                if (!periodData[periodKey]) {
                    periodData[periodKey] = [];
                }
                periodData[periodKey].push(trade);
            });

            const periodScores = {};
            Object.entries(periodData).forEach(([period, periodTrades]) => {
                if (periodTrades.length >= 3) {
                    const scores = calculateScores(periodTrades);
                    periodScores[period] = {
                        overall: (scores.entryAccuracy.score + scores.drawdownResistance.score + 
                                scores.riskRewardPower.score + scores.riskManagement.score + 
                                scores.profitStability.score) / 5,
                        entry: scores.entryAccuracy.score,
                        drawdown: scores.drawdownResistance.score,
                        riskreward: scores.riskRewardPower.score,
                        riskmanagement: scores.riskManagement.score,
                        stability: scores.profitStability.score,
                        tradeCount: periodTrades.length,
                        totalProfit: periodTrades.reduce((sum, t) => sum + t.profit, 0)
                    };
                }
            });

            console.log('Period scores calculated:', periodScores);
            return periodScores;
        }

        function updateTrendChart(periodScores = null, timeAxisInfo = null) {
            const ctx = document.getElementById('trendChart').getContext('2d');
            
            if (typeof Chart === 'undefined') {
                console.error('Chart.js ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const existingChart = activeCharts.find(chart => chart && chart.canvas && chart.canvas.id === 'trendChart');
            if (existingChart && typeof existingChart.destroy === 'function') {
                existingChart.destroy();
                activeCharts = activeCharts.filter(chart => !chart || !chart.canvas || chart.canvas.id !== 'trendChart');
            }
            
            let data, labels, label, color;
            
            if (periodScores && Object.keys(periodScores).length > 0 && timeAxisInfo) {
                const periods = Object.keys(periodScores).sort();
                
                data = periods.map(period => {
                    const periodData = periodScores[period];
                    return periodData ? periodData[currentTrendMetric] || 0 : 0;
                });
                
                labels = periods.map(period => formatPeriodLabel(period, timeAxisInfo.type));
                
                console.log('Using real data:', { periods, data, labels });
            } else {
                data = getDemoTrendData(currentTrendMetric);
                labels = ['æœŸé–“1', 'æœŸé–“2', 'æœŸé–“3', 'æœŸé–“4'];
                console.log('Using demo data');
            }
            
            switch(currentTrendMetric) {
                case 'entry':
                    label = 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“';
                    color = 'rgba(34, 197, 94, 1)';
                    break;
                case 'drawdown':
                    label = 'ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§';
                    color = 'rgba(239, 68, 68, 1)';
                    break;
                case 'riskreward':
                    label = 'ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›';
                    color = 'rgba(168, 85, 247, 1)';
                    break;
                case 'riskmanagement':
                    label = 'ãƒªã‚¹ã‚¯ç®¡ç†åŠ›';
                    color = 'rgba(245, 158, 11, 1)';
                    break;
                case 'stability':
                    label = 'åç›Šå®‰å®šåŠ›';
                    color = 'rgba(6, 182, 212, 1)';
                    break;
                default:
                    label = 'ç·åˆã‚¹ã‚³ã‚¢';
                    color = 'rgba(102, 126, 234, 1)';
            }
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        borderColor: color,
                        backgroundColor: color.replace('1)', '0.1)'),
                        tension: 0.4,
                        fill: true,
                        pointBackgroundColor: color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 10,
                            title: {
                                display: true,
                                text: 'ã‚¹ã‚³ã‚¢',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: timeAxisInfo ? timeAxisInfo.unit : 'æœŸé–“',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    if (periodScores && timeAxisInfo) {
                                        const periods = Object.keys(periodScores).sort();
                                        const period = periods[context.dataIndex];
                                        const periodData = periodScores[period];
                                        if (periodData) {
                                            return [
                                                `å–å¼•æ•°: ${periodData.tradeCount}å›`,
                                                `æç›Š: Â¥${Math.round(periodData.totalProfit).toLocaleString()}`
                                            ];
                                        }
                                    }
                                    return [];
                                }
                            }
                        }
                    }
                }
            });

            activeCharts.push(chart);
        }

        function formatPeriodLabel(period, type) {
            switch(type) {
                case 'daily':
                    const [year, month, day] = period.split('-');
                    return `${month}/${day}`;
                case 'weekly':
                    const [weekYear, week] = period.split('-W');
                    return `${weekYear}å¹´${week}é€±`;
                case 'monthly':
                    const [monthYear, monthNum] = period.split('-');
                    return `${monthYear}/${monthNum}`;
                case 'quarterly':
                    const [qYear, quarter] = period.split('-Q');
                    return `${qYear}å¹´Q${quarter}`;
                default:
                    return period;
            }
        }

        function getDemoTrendData(metric) {
            const demoData = {
                overall: [6.2, 6.8, 7.1, 7.5],
                entry: [7.2, 7.5, 7.6, 7.8],
                drawdown: [5.8, 6.0, 6.1, 6.2],
                riskreward: [8.0, 8.2, 8.3, 8.4],
                riskmanagement: [5.2, 5.5, 5.7, 5.8],
                stability: [6.5, 6.7, 6.8, 6.9]
            };
            return demoData[metric] || demoData.overall;
        }

        // ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆé–¢æ•°
        function generateGoodPerformanceData() {
            const trades = [];
            for (let i = 0; i < 150; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 43200000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.25) * 15000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY'][Math.floor(Math.random() * 3)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        function generateAveragePerformanceData() {
            const trades = [];
            for (let i = 0; i < 100; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 86400000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.45) * 12000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY'][Math.floor(Math.random() * 4)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        function generatePoorPerformanceData() {
            const trades = [];
            for (let i = 0; i < 80; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 172800000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.65) * 18000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY', 'USDCHF'][Math.floor(Math.random() * 5)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function resetAnalysisView() {
            analysisResultsEl.style.display = 'none';
            errorEl.style.display = 'none';
            fileInfoEl.style.display = 'none';
            
            // ã‚ˆã‚Šç¢ºå®Ÿãªãƒãƒ£ãƒ¼ãƒˆå‰Šé™¤ã¨ãƒ¡ãƒ¢ãƒªè§£æ”¾
            activeCharts.forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    try {
                        chart.destroy();
                        // canvasè¦ç´ ã‚‚ã‚¯ãƒªã‚¢
                        if (chart.canvas) {
                            const ctx = chart.canvas.getContext('2d');
                            ctx.clearRect(0, 0, chart.canvas.width, chart.canvas.height);
                        }
                    } catch (e) {
                        console.warn('ãƒãƒ£ãƒ¼ãƒˆå‰Šé™¤ã‚¨ãƒ©ãƒ¼:', e);
                    }
                }
            });
            activeCharts = [];
            
            // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚‚ãƒªã‚»ãƒƒãƒˆ
            fileInput.value = '';
            fileNameEl.textContent = '';
        }

        function setLoading(isLoading) {
            loadingEl.style.display = isLoading ? 'block' : 'none';
        }

        function showError(message) {
            errorEl.style.display = 'block';
            errorEl.textContent = message;
        }

        function showHelp(title) {
            const helpTexts = {
                'ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒãƒ£ãƒ¼ãƒˆ': '5ã¤ã®è©•ä¾¡è»¸ã§å…¨æœŸé–“ã®ç·åˆçš„ãªãƒˆãƒ¬ãƒ¼ãƒ‰èƒ½åŠ›ã‚’0-10ç‚¹ã§è©•ä¾¡ã—ã¾ã™ã€‚å…¨å–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆã—ã¦ç®—å‡ºã—ãŸåŒ…æ‹¬çš„ãªè©•ä¾¡ã§ã™ã€‚',
                'ã‚¹ã‚³ã‚¢æ¨ç§»': 'æœŸé–“åˆ¥ã®ã‚¹ã‚³ã‚¢å¤‰åŒ–ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿é‡ã«å¿œã˜ã¦æ—¥åˆ¥ãƒ»é€±åˆ¥ãƒ»æœˆåˆ¥ãƒ»å››åŠæœŸåˆ¥ã§è‡ªå‹•èª¿æ•´ã•ã‚Œã¾ã™ã€‚å³è‚©ä¸ŠãŒã‚Šãªã‚‰æ”¹å–„å‚¾å‘ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚'
            };
            alert(helpTexts[title] || 'èª¬æ˜ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }

        // è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºæ©Ÿèƒ½
        function showDetailModal(scoreName, scoreValue, scoreIndex) {
            modalScoreTitle.textContent = scoreName;
            modalScoreValue.textContent = scoreValue;
            
            const detailContent = generateDetailContent(scoreName, scoreValue, scoreIndex);
            modalBody.innerHTML = detailContent;
            
            detailModal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function closeDetailModal() {
            detailModal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function generateDetailContent(scoreName, scoreValue, scoreIndex) {
            const analysisData = getAnalysisData(scoreIndex, allTrades);
            
            return `
                <div class="detail-section">
                    <h3><span class="detail-section-icon">${scoreIndex + 1}</span>æ¡ç‚¹æ ¹æ‹ ã®è©³ç´°</h3>
                    ${analysisData.calculations.map(calc => `
                        <div class="analysis-block">
                            <h4>ğŸ“Š ${calc.title}</h4>
                            <div class="analysis-text">${calc.content}</div>
                            ${calc.examples ? calc.examples.map(example => `
                                <div class="example-trade">
                                    <div class="example-trade-header">${example.title}</div>
                                    <div class="example-trade-content">${example.content}</div>
                                </div>
                            `).join('') : ''}
                        </div>
                    `).join('')}
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">ğŸ“ˆ</span>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è©•ä¾¡</h3>
                    <div class="strength-weakness-grid">
                        <div class="strength-card">
                            <h4>ğŸ¯ ã‚ãªãŸã®å¼·ã¿</h4>
                            <ul>
                                ${analysisData.strengths.map(strength => `<li>${strength}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="weakness-card">
                            <h4>âš ï¸ æ”¹å–„ã™ã¹ãèª²é¡Œ</h4>
                            <ul>
                                ${analysisData.weaknesses.map(weakness => `<li>${weakness}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">ğŸš€</span>ã‚¹ã‚³ã‚¢å‘ä¸Šã®ãŸã‚ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹</h3>
                    <div class="improvement-tips">
                        <h4>ğŸ’¡ å…·ä½“çš„ãªæ”¹å–„ç­–</h4>
                        <ul class="improvement-list">
                            ${analysisData.improvements.map(tip => `<li>${tip}</li>`).join('')}
                        </ul>
                    </div>
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">ğŸ“‹</span>ã‚¹ã‚³ã‚¢èª¬æ˜</h3>
                    <div class="analysis-block">
                        <div class="analysis-text">${analysisData.description}</div>
                    </div>
                </div>
            `;
        }

        function getAnalysisData(scoreIndex, trades = []) {
            if (!trades || trades.length === 0) {
                return getTemplateAnalysisData(scoreIndex);
            }

            const stats = calculateRealTimeStats(trades);
            
            switch(scoreIndex) {
                case 0: return getEntryAnalysis(stats, trades);
                case 1: return getDrawdownAnalysis(stats, trades);
                case 2: return getRiskRewardAnalysis(stats, trades);
                case 3: return getRiskManagementAnalysis(stats, trades);
                case 4: return getStabilityAnalysis(stats, trades);
                default: return getTemplateAnalysisData(scoreIndex);
            }
        }

        function calculateRealTimeStats(trades) {
            const winTrades = trades.filter(t => t.isWin);
            const lossTrades = trades.filter(t => !t.isWin);
            const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
            const winRate = trades.length > 0 ? (winTrades.length / trades.length) : 0;
            
            const hourlyStats = {};
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (!hourlyStats[hour]) hourlyStats[hour] = { total: 0, wins: 0, profit: 0 };
                hourlyStats[hour].total++;
                if (trade.isWin) hourlyStats[hour].wins++;
                hourlyStats[hour].profit += trade.profit;
            });

            let tokyoTrades = 0, londonTrades = 0, nyTrades = 0, otherTrades = 0;
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (hour >= 9 && hour <= 15) tokyoTrades++;
                else if (hour >= 16 && hour <= 18) londonTrades++;
                else if (hour >= 22 || hour <= 1) nyTrades++;
                else otherTrades++;
            });

            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            let peak = 0, maxDrawdown = 0, cumulative = 0;
            trades.forEach(trade => {
                cumulative += trade.profit;
                if (cumulative > peak) peak = cumulative;
                const drawdown = peak - cumulative;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });

            const profits = winTrades.map(t => t.profit);
            const losses = lossTrades.map(t => Math.abs(t.profit));
            
            // ç©ºé…åˆ—å¯¾ç­–ã‚’è¿½åŠ 
            const maxWin = profits.length > 0 ? Math.max(...profits) : 0;
            const maxLoss = losses.length > 0 ? Math.max(...losses) : 0;
            const avgWin = profits.length > 0 ? profits.reduce((sum, p) => sum + p, 0) / profits.length : 0;
            const avgLoss = losses.length > 0 ? losses.reduce((sum, p) => sum + p, 0) / losses.length : 0;

            return {
                totalTrades: trades.length,
                winTrades: winTrades.length,
                lossTrades: lossTrades.length,
                totalProfit,
                winRate,
                maxWin,
                maxLoss,
                avgWin,
                avgLoss,
                maxDrawdown,
                peak,
                hourlyStats,
                sessions: { tokyo: tokyoTrades, london: londonTrades, ny: nyTrades, other: otherTrades },
                monthlyProfits: Object.values(monthlyProfits),
                dateRange: {
                    start: trades.length > 0 ? trades[0].openTime : null,
                    end: trades.length > 0 ? trades[trades.length - 1].openTime : null
                }
            };
        }

        function getEntryAnalysis(stats, trades) {
            const sessionTotal = stats.sessions.tokyo + stats.sessions.london + stats.sessions.ny;
            const sessionRatio = (sessionTotal / stats.totalTrades * 100).toFixed(1);
            
            const bestHours = Object.entries(stats.hourlyStats)
                .filter(([hour, data]) => data.total >= 3)
                .sort((a, b) => (b[1].wins / b[1].total) - (a[1].wins / a[1].total))
                .slice(0, 3);

            return {
                calculations: [
                    {
                        title: "å‹ç‡åˆ†æ",
                        content: `ã‚ãªãŸã®å‹ç‡ã¯<span class="highlight-number">${(stats.winRate * 100).toFixed(1)}%</span>ï¼ˆ${stats.winTrades}å‹${stats.lossTrades}æ•—ï¼‰ã§ã™ã€‚<br>ãƒ»ç·å–å¼•æ•°: ${stats.totalTrades}å›<br>ãƒ»ä¸€èˆ¬çš„ãªç›®å®‰ã®50%ã¨æ¯”è¼ƒã—ã¦${stats.winRate >= 0.5 ? 'ä¸Šå›ã‚‹å„ªç§€' : 'æ”¹å–„ãŒå¿…è¦'}ãªæ•°å€¤<br>ãƒ»å‹ã¡å–å¼•å¹³å‡: Â¥${Math.round(stats.avgWin).toLocaleString()}<br>â†’ å‹ç‡ã‚¹ã‚³ã‚¢: <span class="highlight-number">${Math.min(stats.winRate * 150, 100).toFixed(1)}/100ç‚¹</span>`,
                        examples: bestHours.length > 0 ? [
                            {
                                title: "æœ€ã‚‚æˆç¸¾ã®è‰¯ã„æ™‚é–“å¸¯",
                                content: `${bestHours[0][0]}æ™‚å°: å‹ç‡${(bestHours[0][1].wins / bestHours[0][1].total * 100).toFixed(1)}% (${bestHours[0][1].wins}å‹${bestHours[0][1].total - bestHours[0][1].wins}æ•—)`
                            }
                        ] : []
                    },
                    {
                        title: "å¸‚å ´ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦",
                        content: `ä¸»è¦å¸‚å ´æ™‚é–“ã§ã®å–å¼•åˆ†æï¼š<br>ãƒ»æ±äº¬æ™‚é–“ï¼ˆ9-15æ™‚ï¼‰: ${stats.sessions.tokyo}å›å–å¼•ï¼ˆ${(stats.sessions.tokyo / stats.totalTrades * 100).toFixed(1)}%ï¼‰<br>ãƒ»ãƒ­ãƒ³ãƒ‰ãƒ³æ™‚é–“ï¼ˆ16-18æ™‚ï¼‰: ${stats.sessions.london}å›å–å¼•ï¼ˆ${(stats.sessions.london / stats.totalTrades * 100).toFixed(1)}%ï¼‰<br>ãƒ»NYæ™‚é–“ï¼ˆ22-1æ™‚ï¼‰: ${stats.sessions.ny}å›å–å¼•ï¼ˆ${(stats.sessions.ny / stats.totalTrades * 100).toFixed(1)}%ï¼‰<br>ãƒ»ãã®ä»–æ™‚é–“å¸¯: ${stats.sessions.other}å›å–å¼•ï¼ˆ${(stats.sessions.other / stats.totalTrades * 100).toFixed(1)}%ï¼‰<br><br>â†’ <span class="highlight-number">${sessionRatio}%</span>ãŒä¸»è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã§ã®å–å¼•<br>â†’ ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦: <span class="highlight-number">${Math.min(sessionTotal / stats.totalTrades * 120, 100).toFixed(1)}/100ç‚¹</span>`
                    }
                ],
                strengths: [
                    stats.winRate >= 0.6 ? `å‹ç‡${(stats.winRate * 100).toFixed(1)}%ã¨ã„ã†é«˜ã„ç²¾åº¦ã‚’ç¶­æŒ` : `${stats.totalTrades}å›ã®å–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’è“„ç©`,
                    sessionTotal / stats.totalTrades >= 0.7 ? "ä¸»è¦å¸‚å ´æ™‚é–“ã‚’ç‹™ã£ãŸæˆ¦ç•¥çš„å–å¼•" : "å–å¼•æ™‚é–“ã®åˆ†æ•£ãŒã§ãã¦ã„ã‚‹",
                    stats.avgWin > stats.avgLoss ? "å¹³å‡åˆ©ç›ŠãŒå¹³å‡æå¤±ã‚’ä¸Šå›ã‚‹" : "æå¤±ç®¡ç†ã‚’æ„è­˜ã—ãŸå–å¼•"
                ],
                weaknesses: [
                    stats.sessions.other / stats.totalTrades > 0.3 ? `é–‘æ•£æ™‚é–“å¸¯ã§ã®å–å¼•ãŒ${(stats.sessions.other / stats.totalTrades * 100).toFixed(1)}%å­˜åœ¨` : "æ™‚é–“å¸¯ã®åã‚ŠãŒè¦‹ã‚‰ã‚Œã‚‹",
                    stats.winRate < 0.5 ? "å‹ç‡ãŒ50%ã‚’ä¸‹å›ã£ã¦ã„ã‚‹" : "å‹ç‡ã«ã•ã‚‰ãªã‚‹å‘ä¸Šä½™åœ°",
                    "ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®æœ€é©åŒ–ä½™åœ°"
                ],
                improvements: [
                    sessionTotal / stats.totalTrades < 0.8 ? "ä¸»è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã§ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼æ©Ÿä¼šã‚’å¢—ã‚„ã™" : "ç¾åœ¨ã®æ™‚é–“å¸¯æˆ¦ç•¥ã‚’ç¶™ç¶š",
                    "çµŒæ¸ˆæŒ‡æ¨™ç™ºè¡¨æ™‚é–“ã‚’äº‹å‰ãƒã‚§ãƒƒã‚¯ã—ã¦æˆ¦ç•¥çš„ã«ã‚¨ãƒ³ãƒˆãƒªãƒ¼",
                    stats.sessions.other > 5 ? "é–‘æ•£æ™‚é–“å¸¯ï¼ˆæ·±å¤œ2-6æ™‚ï¼‰ã®å–å¼•ã‚’æ§ãˆã‚‹" : "å–å¼•æ™‚é–“ã®æœ€é©åŒ–ã‚’ç¶™ç¶š",
                    `æœˆæ¬¡ç›®æ¨™å‹ç‡ã‚’${Math.max(60, (stats.winRate * 100) + 5).toFixed(0)}%ã«è¨­å®šã—ã¦æ„è­˜å‘ä¸Š`
                ],
                description: `ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“ã¯ã€ã‚ãªãŸã®ã€Œå£²è²·ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®çš„ç¢ºã•ã€ã‚’è©•ä¾¡ã—ã¾ã™ã€‚ç¾åœ¨ã®ã‚¹ã‚³ã‚¢ã¯å®Ÿéš›ã®å–å¼•ãƒ‡ãƒ¼ã‚¿${stats.totalTrades}å›åˆ†ã‹ã‚‰ç®—å‡ºã•ã‚Œã¦ãŠã‚Šã€å‹ç‡${(stats.winRate * 100).toFixed(1)}%ã¨å¸‚å ´ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦${sessionRatio}%ã‚’åŸºã«è©•ä¾¡ã—ã¦ã„ã¾ã™ã€‚`
            };
        }

        function getDrawdownAnalysis(stats, trades) {
            const drawdownRatio = stats.peak > 0 ? (stats.maxDrawdown / stats.peak * 100) : 0;
            
            return {
                calculations: [
                    {
                        title: "æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³åˆ†æ",
                        content: `è³‡ç”£æ¨ç§»ã®è©³ç´°åˆ†æï¼š<br>ãƒ»æœ€é«˜åˆ°é”åˆ©ç›Š: <span class="highlight-number">Â¥${Math.round(stats.peak).toLocaleString()}</span><br>ãƒ»æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³: <span class="highlight-number">Â¥${Math.round(stats.maxDrawdown).toLocaleString()}</span><br>ãƒ»ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ç‡: <span class="highlight-number">${drawdownRatio.toFixed(1)}%</span><br>ãƒ»ç¾åœ¨ã®ç·æç›Š: Â¥${Math.round(stats.totalProfit).toLocaleString()}<br><br>${drawdownRatio > 30 ? 'å¤§ããªãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ãŒç™ºç”Ÿã—ã¦ã„ã¾ã™' : drawdownRatio > 15 ? 'ä¸­ç¨‹åº¦ã®ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ã§ã™' : 'è‰¯å¥½ãªãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ç®¡ç†ã§ã™'}`,
                        examples: stats.maxLoss > 0 ? [
                            {
                                title: "ãƒªã‚¹ã‚¯ç®¡ç†ã®å‚è€ƒå€¤",
                                content: `æœ€å¤§æå¤±é¡: Â¥${Math.round(stats.maxLoss).toLocaleString()}`
                            }
                        ] : []
                    }
                ],
                strengths: [
                    drawdownRatio <= 15 ? "å„ªç§€ãªãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ç®¡ç†ï¼ˆ15%ä»¥ä¸‹ï¼‰" : drawdownRatio <= 30 ? "é©åˆ‡ãªãƒªã‚¹ã‚¯ç®¡ç†ã‚’å®Ÿæ–½" : "å¤§ããªè³‡é‡‘æ¸›å°‘ã‹ã‚‰ã®å›å¾©çµŒé¨“",
                    stats.totalProfit > 0 ? "æœ€çµ‚çš„ã«ãƒ—ãƒ©ã‚¹åæ”¯ã‚’é”æˆ" : "ç¶™ç¶šçš„ãªå–å¼•å®Ÿç¸¾"
                ],
                weaknesses: [
                    drawdownRatio > 30 ? "å¤§å¹…ãªãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ãŒç™ºç”Ÿ" : drawdownRatio > 15 ? "ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ã®æ”¹å–„ä½™åœ°ã‚ã‚Š" : "ã•ã‚‰ãªã‚‹ãƒªã‚¹ã‚¯ç®¡ç†ã®å¼·åŒ–",
                    "è³‡é‡‘ç®¡ç†ãƒ«ãƒ¼ãƒ«ã®è¦‹ç›´ã—å¿…è¦"
                ],
                improvements: [
                    "1å–å¼•ã‚ãŸã‚Šã®ãƒªã‚¹ã‚¯ã‚’è³‡é‡‘ã®2%ä»¥ä¸‹ã«è¨­å®š",
                    drawdownRatio > 20 ? "ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³20%ã§å–å¼•é‡ã‚’åŠæ¸›ã•ã›ã‚‹ãƒ«ãƒ¼ãƒ«å°å…¥" : "ç¾åœ¨ã®ãƒªã‚¹ã‚¯ç®¡ç†ã‚’ç¶™ç¶š",
                    "é€£æ•—æ™‚ã®å†·å´æœŸé–“ã‚’è¨­ã‘ã‚‹ï¼ˆ3é€£æ•—ã§1æ—¥ä¼‘ã‚€ç­‰ï¼‰",
                    "é€±æ¬¡ãƒ»æœˆæ¬¡ã§ã®æœ€å¤§æå¤±é¡ã‚’äº‹å‰ã«æ±ºã‚ã¦ãŠã"
                ],
                description: `ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§ã¯ã€è³‡é‡‘ã®æœ€å¤§æ¸›å°‘å¹…ã‚’è©•ä¾¡ã—ã¾ã™ã€‚å„ªã‚ŒãŸãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ã¯15%ä»¥ä¸‹ã€ä¸€èˆ¬çš„ã«ã¯30%ä»¥ä¸‹ãŒæœ›ã¾ã—ã„ã¨ã•ã‚Œã¾ã™ã€‚ã‚ãªãŸã®ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ç‡ã¯${drawdownRatio.toFixed(1)}%ã§ã™ã€‚`
            };
        }

        function getRiskRewardAnalysis(stats, trades) {
            const rrRatio = stats.avgLoss > 0 ? stats.avgWin / stats.avgLoss : 0;
            
            return {
                calculations: [
                    {
                        title: "ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”ç‡ã®è©³ç´°",
                        content: `åç›Šæ€§ã®åˆ†æï¼š<br>ãƒ»å¹³å‡åˆ©ç›Š: <span class="highlight-number">Â¥${Math.round(stats.avgWin).toLocaleString()}</span><br>ãƒ»å¹³å‡æå¤±: <span class="highlight-number">Â¥${Math.round(stats.avgLoss).toLocaleString()}</span><br>ãƒ»ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”: <span class="highlight-number">${rrRatio.toFixed(2)}</span><br><br>${rrRatio >= 2 ? 'å„ªç§€ãªãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”' : rrRatio >= 1 ? 'é©æ­£ãªãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”' : 'æ”¹å–„ãŒå¿…è¦ãªãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”'}`,
                        examples: [
                            {
                                title: "æœ€å¤§åˆ©ç›Šã¨æœ€å¤§æå¤±",
                                content: `æœ€å¤§åˆ©ç›Š: Â¥${Math.round(stats.maxWin).toLocaleString()}<br>æœ€å¤§æå¤±: Â¥${Math.round(stats.maxLoss).toLocaleString()}`
                            }
                        ]
                    }
                ],
                strengths: [
                    rrRatio >= 2 ? "ç†æƒ³çš„ãªãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”ï¼ˆ2ä»¥ä¸Šï¼‰" : rrRatio >= 1 ? "ãƒ—ãƒ©ã‚¹ã®ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”" : "æ”¹å–„ã®ä½™åœ°ã‚ã‚Š",
                    stats.maxWin > stats.maxLoss * 2 ? "å¤§ããªåˆ©ç›Šã‚’ç‹™ãˆã‚‹å–å¼•ã‚¹ã‚¿ã‚¤ãƒ«" : "å®‰å®šã—ãŸå–å¼•ã‚¹ã‚¿ã‚¤ãƒ«"
                ],
                weaknesses: [
                    rrRatio < 1 ? "æå¤±ãŒåˆ©ç›Šã‚’ä¸Šå›ã‚‹å‚¾å‘" : rrRatio < 2 ? "ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”ã®æ”¹å–„ä½™åœ°" : "ã•ã‚‰ãªã‚‹å‘ä¸Šã®å¯èƒ½æ€§",
                    "åˆ©ç›Šç¢ºå®šã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°æœ€é©åŒ–"
                ],
                improvements: [
                    "åˆ©ç›Šç›®æ¨™ã‚’æåˆ‡ã‚Šå¹…ã®2å€ä»¥ä¸Šã«è¨­å®š",
                    rrRatio < 1.5 ? "éƒ¨åˆ†åˆ©ç›Šç¢ºå®šæˆ¦ç•¥ã®å°å…¥ï¼ˆåŠåˆ†ã¯æ—©ã‚ã«ç¢ºå®šï¼‰" : "ç¾åœ¨ã®åˆ©ç¢ºæˆ¦ç•¥ã‚’ç¶™ç¶š",
                    "ãƒˆãƒ¬ãƒ¼ãƒªãƒ³ã‚°ã‚¹ãƒˆãƒƒãƒ—ã®æ´»ç”¨ã§åˆ©ç›Šã‚’ä¼¸ã°ã™",
                    "ã‚¨ãƒ³ãƒˆãƒªãƒ¼å‰ã«ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”ã‚’å¿…ãšç¢ºèª"
                ],
                description: `ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›ã¯ã€1å›ã®æå¤±ã«å¯¾ã—ã¦ã©ã‚Œã ã‘ã®åˆ©ç›Šã‚’å¾—ã¦ã„ã‚‹ã‹ã‚’è©•ä¾¡ã—ã¾ã™ã€‚ç†æƒ³ã¯2.0ä»¥ä¸Šã€æœ€ä½ã§ã‚‚1.0ä»¥ä¸ŠãŒå¿…è¦ã§ã™ã€‚ã‚ãªãŸã®æ¯”ç‡ã¯${rrRatio.toFixed(2)}ã§ã™ã€‚`
            };
        }

        function getRiskManagementAnalysis(stats, trades) {
            const consistencyScore = stats.lossTrades > 0 ? 
                (1 - (stats.maxLoss - stats.avgLoss) / stats.avgLoss) * 100 : 100;
            
            return {
                calculations: [
                    {
                        title: "æå¤±ç®¡ç†ã®ä¸€è²«æ€§",
                        content: `ãƒªã‚¹ã‚¯ç®¡ç†ã®åˆ†æï¼š<br>ãƒ»å¹³å‡æå¤±: <span class="highlight-number">Â¥${Math.round(stats.avgLoss).toLocaleString()}</span><br>ãƒ»æœ€å¤§æå¤±: <span class="highlight-number">Â¥${Math.round(stats.maxLoss).toLocaleString()}</span><br>ãƒ»æå¤±ã®ä¸€è²«æ€§: <span class="highlight-number">${consistencyScore.toFixed(1)}%</span><br><br>${consistencyScore >= 70 ? 'ä¸€è²«ã—ãŸãƒªã‚¹ã‚¯ç®¡ç†' : 'æå¤±é¡ã«ã°ã‚‰ã¤ããŒã‚ã‚Šã¾ã™'}`
                    }
                ],
                strengths: [
                    consistencyScore >= 70 ? "ä¸€è²«ã—ãŸæåˆ‡ã‚Šå®Ÿè¡Œ" : "æåˆ‡ã‚Šãƒ«ãƒ¼ãƒ«ã®å­˜åœ¨",
                    stats.lossTrades < stats.winTrades ? "å‹ã¡å–å¼•ãŒè² ã‘å–å¼•ã‚’ä¸Šå›ã‚‹" : "ç¶™ç¶šçš„ãªå–å¼•å®Ÿæ–½"
                ],
                weaknesses: [
                    consistencyScore < 70 ? "æå¤±é¡ã®ã°ã‚‰ã¤ããŒå¤§ãã„" : "ã•ã‚‰ãªã‚‹ä¸€è²«æ€§ã®å‘ä¸Š",
                    stats.maxLoss > stats.avgLoss * 2 ? "å¤§ããªæå¤±ãŒç™ºç”Ÿ" : "ãƒªã‚¹ã‚¯ç®¡ç†ã®æœ€é©åŒ–ä½™åœ°"
                ],
                improvements: [
                    "å…¨å–å¼•ã§å›ºå®šï¼…ã®æåˆ‡ã‚Šãƒ«ãƒ¼ãƒ«å¾¹åº•",
                    "ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚¸ãƒ³ã‚°è¨ˆç®—ãƒ„ãƒ¼ãƒ«ã®æ´»ç”¨",
                    consistencyScore < 80 ? "æ„Ÿæƒ…çš„ãªæåˆ‡ã‚Šå›é¿ã‚’é˜²ããŸã‚è‡ªå‹•æåˆ‡ã‚Šè¨­å®š" : "ç¾åœ¨ã®æåˆ‡ã‚Šãƒ«ãƒ¼ãƒ«ã‚’ç¶™ç¶š",
                    "å–å¼•æ—¥èªŒã§æåˆ‡ã‚Šç†ç”±ã‚’è¨˜éŒ²ãƒ»åˆ†æ"
                ],
                description: `ãƒªã‚¹ã‚¯ç®¡ç†åŠ›ã¯ã€æå¤±ã‚’ä¸€å®šç¯„å›²å†…ã«æŠ‘ãˆã‚‹èƒ½åŠ›ã‚’è©•ä¾¡ã—ã¾ã™ã€‚å„ªã‚ŒãŸãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ã¯å¸¸ã«ä¸€è²«ã—ãŸæåˆ‡ã‚Šã‚’å®Ÿè¡Œã—ã¾ã™ã€‚ã‚ãªãŸã®ä¸€è²«æ€§ã‚¹ã‚³ã‚¢ã¯${consistencyScore.toFixed(1)}%ã§ã™ã€‚`
            };
        }

        function getStabilityAnalysis(stats, trades) {
            const profitableMonths = stats.monthlyProfits.filter(p => p > 0).length;
            const totalMonths = stats.monthlyProfits.length;
            const profitRate = totalMonths > 0 ? (profitableMonths / totalMonths * 100) : 0;
            
            return {
                calculations: [
                    {
                        title: "åç›Šã®å®‰å®šæ€§åˆ†æ",
                        content: `æœŸé–“åˆ¥åç›Šã®åˆ†æï¼š<br>ãƒ»åˆ†ææœŸé–“: ${totalMonths}ãƒ¶æœˆ<br>ãƒ»ãƒ—ãƒ©ã‚¹æœˆ: <span class="highlight-number">${profitableMonths}ãƒ¶æœˆ</span><br>ãƒ»ãƒã‚¤ãƒŠã‚¹æœˆ: ${totalMonths - profitableMonths}ãƒ¶æœˆ<br>ãƒ»ãƒ—ãƒ©ã‚¹æœˆç‡: <span class="highlight-number">${profitRate.toFixed(1)}%</span><br><br>${profitRate >= 70 ? 'å®‰å®šã—ãŸåç›Šæ€§' : profitRate >= 50 ? 'æ”¹å–„ã®ä½™åœ°ã‚ã‚Š' : 'åç›Šã®å®‰å®šåŒ–ãŒå¿…è¦'}`
                    }
                ],
                strengths: [
                    profitRate >= 70 ? "é«˜ã„æœˆæ¬¡ãƒ—ãƒ©ã‚¹ç‡" : profitRate >= 50 ? "åŠæ•°ä»¥ä¸Šã®æœˆã§ãƒ—ãƒ©ã‚¹" : "ç¶™ç¶šçš„ãªå–å¼•å®Ÿç¸¾",
                    stats.totalProfit > 0 ? "ãƒˆãƒ¼ã‚¿ãƒ«ã§ãƒ—ãƒ©ã‚¹åæ”¯" : "çµŒé¨“ã®è“„ç©"
                ],
                weaknesses: [
                    profitRate < 70 ? "æœˆæ¬¡åç›Šã®å®‰å®šæ€§å‘ä¸ŠãŒå¿…è¦" : "ã•ã‚‰ãªã‚‹å®‰å®šæ€§ã®è¿½æ±‚",
                    "åç›Šã®ã°ã‚‰ã¤ãå‰Šæ¸›"
                ],
                improvements: [
                    "æœˆé–“å–å¼•å›æ•°ã®ç›®æ¨™è¨­å®šï¼ˆæœ€ä½20å›ç­‰ï¼‰",
                    profitRate < 60 ? "è² ã‘æœˆã®åŸå› åˆ†æã¨å¯¾ç­–ç«‹æ¡ˆ" : "ç¾åœ¨ã®å–å¼•ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç¶™ç¶š",
                    "è¤‡æ•°ã®å–å¼•æˆ¦ç•¥ã‚’çµ„ã¿åˆã‚ã›ã¦ãƒªã‚¹ã‚¯åˆ†æ•£",
                    "å¸‚å ´ç’°å¢ƒã«å¿œã˜ãŸå–å¼•é‡èª¿æ•´ãƒ«ãƒ¼ãƒ«ã®å°å…¥"
                ],
                description: `åç›Šå®‰å®šåŠ›ã¯ã€ç¶™ç¶šçš„ã«åˆ©ç›Šã‚’å‡ºã™èƒ½åŠ›ã‚’è©•ä¾¡ã—ã¾ã™ã€‚ãƒ—ãƒ­ãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ã¯70%ä»¥ä¸Šã®æœˆã§ãƒ—ãƒ©ã‚¹ã‚’ç¶­æŒã—ã¾ã™ã€‚ã‚ãªãŸã®ãƒ—ãƒ©ã‚¹æœˆç‡ã¯${profitRate.toFixed(1)}%ã§ã™ã€‚`
            };
        }

        function getTemplateAnalysisData(scoreIndex) {
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
            const templates = [
                {
                    calculations: [{
                        title: "ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“ã®è©•ä¾¡",
                        content: "ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã‚‹ãŸã‚ã€è©³ç´°ãªåˆ†æãŒã§ãã¾ã›ã‚“ã€‚å–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚"
                    }],
                    strengths: ["åˆ†æã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“"],
                    weaknesses: ["ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„"],
                    improvements: ["å–å¼•å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦åˆ†æã‚’é–‹å§‹"],
                    description: "ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“ã®è©³ç´°åˆ†æã«ã¯ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ã§ã™ã€‚"
                }
            ];
            
            return templates[0];
        }
    </script>
</body>
</html>
