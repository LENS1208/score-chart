<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FX取引評価スコア - レーダーチャートツール</title>
    <style>
/* CSS変数で色を管理 */
:root {
    /* ライトモード */
    --bg-primary: #ffffff;
    --bg-secondary: #fafafa;
    --bg-tertiary: #f5f5f5;
    --border-color: #ebebeb;
    --text-primary: #333;
    --text-secondary: #666;
    --text-muted: #999;
    --positive-color: #007eff;
    --negative-color: #ff2800;
    --neutral-color: #6b7280;
    
    /* カード用 */
    --card-bg: #ffffff;
    --card-border: #ebebeb;
    --card-shadow: 0 2px 8px rgba(0,0,0,0.06);
    --hover-shadow: 0 8px 24px rgba(0,0,0,0.1);
    
    /* ボタン用 */
    --button-bg: #007eff;
    --button-hover-shadow: 0 4px 12px rgba(0, 126, 255, 0.3);
    
    /* Chart.js用のグリッド線の色 */
    --chart-grid-color: rgba(0, 0, 0, 0.1);
    --chart-text-color: #666;
}

/* ダークモード */
@media (prefers-color-scheme: dark) {
    :root {
        --bg-primary: #000000;
        --bg-secondary: #181818;
        --bg-tertiary: #232323;
        --border-color: #373737;
        --text-primary: #e0e0e0;
        --text-secondary: #aaa;
        --text-muted: #777;
        --positive-color: #00c8ff;
        --negative-color: #ff3200;
        
        --card-bg: #181818;
        --card-border: #373737;
        --card-shadow: 0 2px 8px rgba(0,0,0,0.4);
        --hover-shadow: 0 8px 24px rgba(0, 200, 255, 0.15);
        
        --button-bg: #00c8ff;
        --button-hover-shadow: 0 4px 12px rgba(0, 200, 255, 0.3);
        
        /* ダークモード用のChart.jsグリッド線 */
        --chart-grid-color: rgba(255, 255, 255, 0.2);
        --chart-text-color: #aaa;
    }
}

/* ダークモード手動切り替え用 */
body.dark-mode {
    --bg-primary: #000000;
    --bg-secondary: #181818;
    --bg-tertiary: #232323;
    --border-color: #373737;
    --text-primary: #e0e0e0;
    --text-secondary: #aaa;
    --text-muted: #777;
    --positive-color: #00c8ff;
    --negative-color: #ff3200;
    
    --card-bg: #181818;
    --card-border: #373737;
    --card-shadow: 0 2px 8px rgba(0,0,0,0.4);
    --hover-shadow: 0 8px 24px rgba(0, 200, 255, 0.15);
    
    --button-bg: #00c8ff;
    --button-hover-shadow: 0 4px 12px rgba(0, 200, 255, 0.3);
    
    /* ダークモード用のChart.jsグリッド線 */
    --chart-grid-color: rgba(255, 255, 255, 0.2);
    --chart-text-color: #aaa;
}

/* 基本スタイル */
* { 
    margin: 0; 
    padding: 0; 
    box-sizing: border-box; 
}

body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans JP', sans-serif;
    background: var(--bg-primary);
    min-height: 100vh; 
    color: var(--text-primary);
    line-height: 1.6;
    transition: background-color 0.3s ease, color 0.3s ease;
}

.container { 
    max-width: 1200px; 
    margin: 0 auto; 
    padding: 40px 20px; 
}

/* ヘッダー */
header { 
    text-align: center; 
    margin-bottom: 40px;
    padding: 30px 20px;
    background: var(--bg-secondary);
    border-radius: 12px;
    border: 1px solid var(--border-color);
    position: relative;
}

h1 { 
    font-size: 2em; 
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--text-primary);
    letter-spacing: 0.02em;
}

header p {
    color: var(--text-secondary);
    font-size: 0.95em;
}

h2 {
    font-size: 1.3em;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 20px;
}

h3 {
    font-size: 1.1em;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 16px;
}

/* ダークモード切り替えボタン */
.theme-toggle {
    position: absolute;
    top: 20px;
    right: 20px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.85em;
    color: var(--text-secondary);
}

.theme-toggle:hover {
    background: var(--border-color);
}

.theme-toggle svg {
    width: 18px;
    height: 18px;
    fill: currentColor;
}

.theme-toggle-text {
    display: none;
}

@media (min-width: 768px) {
    .theme-toggle-text {
        display: inline;
    }
}

/* アップロードセクション */
.upload-section { 
    background: var(--bg-secondary);
    border-radius: 12px; 
    padding: 24px; 
    margin-bottom: 24px;
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}

.upload-section h2 {
    font-size: 1.1em;
    margin-bottom: 16px;
    color: var(--text-primary);
    font-weight: 600;
}

.file-info { 
    margin-top: 16px; 
    padding: 12px 16px; 
    background: var(--bg-tertiary);
    border-radius: 8px;
    font-size: 0.9em;
    border: 1px solid var(--border-color);
}

.file-info h4 { 
    color: var(--text-primary);
    margin-bottom: 4px; 
    font-size: 0.9em;
    font-weight: 600;
}

.file-info div { 
    color: var(--text-secondary);
    font-size: 0.85em; 
}

/* ボタンスタイル */
.file-input-wrapper { 
    position: relative; 
    overflow: hidden; 
    display: inline-block; 
    cursor: pointer; 
    background: var(--button-bg);
    color: white; 
    padding: 10px 24px; 
    border-radius: 8px;
    font-size: 0.9em;
    font-weight: 500;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border: none;
}

.file-input-wrapper:hover {
    transform: translateY(-1px);
    box-shadow: var(--button-hover-shadow);
}

#fileInput { 
    display: none;
}

#fileName {
    margin-top: 12px;
    color: var(--text-secondary);
    font-size: 0.9em;
}

/* デモコントロール */
.demo-controls {
    background: var(--bg-secondary);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 24px;
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}

.demo-controls h3 {
    font-size: 1em;
    color: var(--text-primary);
    margin-bottom: 12px;
    font-weight: 600;
}

.demo-controls button {
    background: var(--button-bg);
    color: white;
    border: none;
    padding: 8px 20px;
    border-radius: 8px;
    cursor: pointer;
    margin: 4px;
    font-size: 0.9em;
    font-weight: 500;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.demo-controls button:hover {
    transform: translateY(-1px);
    box-shadow: var(--button-hover-shadow);
}

/* メインセクション */
#analysisResults {
    display: none;
}

.top-section {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
    margin-bottom: 24px;
}

/* 総合スコアカード */
.overall-score { 
    background: var(--bg-secondary);
    border-radius: 12px; 
    padding: 32px; 
    text-align: center; 
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
    min-height: 250px;
}

.overall-score h2 { 
    font-size: 1em;
    font-weight: 500;
    margin-bottom: 16px;
    color: var(--text-secondary);
}

.overall-score .score { 
    font-size: 4.5em; 
    font-weight: 700; 
    margin-bottom: 8px;
    color: var(--positive-color);
    line-height: 1;
}

.overall-score .rating { 
    font-size: 0.9em;
    color: var(--text-secondary);
    font-weight: 500;
}

/* チャートコンテナ */
.chart-container { 
    background: var(--bg-secondary);
    border-radius: 12px; 
    padding: 24px; 
    border: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
    margin-bottom: 24px;
}

.chart-container h3 { 
    color: var(--text-primary);
    margin-bottom: 20px; 
    font-size: 1.1em; 
    font-weight: 600;
    display: flex; 
    align-items: center; 
    gap: 8px; 
}

/* スコアグリッド */
.score-grid { 
    display: grid; 
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); 
    gap: 16px; 
    margin-top: 20px; 
}

/* スコアカード */
.score-card { 
    background: var(--card-bg);
    border-radius: 12px; 
    padding: 20px; 
    border: 1px solid var(--border-color);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    position: relative;
}

.score-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--hover-shadow);
}

.score-header { 
    display: flex; 
    justify-content: space-between; 
    align-items: flex-start; 
    margin-bottom: 16px; 
}

.score-title { 
    font-weight: 500; 
    color: var(--text-secondary);
    font-size: 0.9em; 
}

.score-value { 
    font-size: 2.5em; 
    font-weight: 700; 
    color: var(--positive-color);
    line-height: 1;
}

/* スコアレベルによる色分け */
.score-value[data-score-level="low"] {
    color: var(--negative-color);
}

.score-value[data-score-level="mid"] {
    color: var(--neutral-color);
}

.score-value[data-score-level="high"] {
    color: var(--positive-color);
}

.score-metrics { 
    margin-top: 12px; 
}

.metric-item { 
    display: flex; 
    justify-content: space-between; 
    margin-bottom: 8px; 
    font-size: 0.85em; 
}

.metric-label { 
    color: var(--text-secondary);
}

.metric-value { 
    font-weight: 600; 
    color: var(--text-primary);
}

/* トレンドボタン */
.trend-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.trend-button {
    padding: 6px 16px;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    background: var(--bg-primary);
    color: var(--text-secondary);
    font-size: 0.85em;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.trend-button:hover {
    border-color: var(--positive-color);
    color: var(--positive-color);
}

.trend-button.active {
    background: var(--button-bg);
    border-color: var(--button-bg);
    color: white;
}

/* ローディング */
.loading { 
    display: none; 
    text-align: center; 
    padding: 20px; 
    color: var(--text-secondary);
}

.spinner { 
    border: 3px solid var(--border-color);
    border-top: 3px solid var(--positive-color);
    border-radius: 50%; 
    width: 40px; 
    height: 40px; 
    animation: spin 1s linear infinite; 
    margin: 0 auto 12px; 
}

@keyframes spin { 
    0% { transform: rotate(0deg); } 
    100% { transform: rotate(360deg); } 
}

/* エラーメッセージ */
.error-message { 
    background: rgba(255, 40, 0, 0.1);
    color: var(--negative-color);
    padding: 12px 16px; 
    border-radius: 8px; 
    margin-top: 16px; 
    display: none;
    border: 1px solid rgba(255, 40, 0, 0.2);
    font-size: 0.9em;
}

/* ヘルプアイコン */
.help-icon { 
    cursor: pointer; 
    color: var(--text-muted);
    font-size: 0.9em; 
    opacity: 0.7; 
    transition: opacity 0.2s; 
}

.help-icon:hover { 
    opacity: 1; 
    color: var(--text-secondary);
}

/* Canvas要素のスタイル */
canvas {
    max-width: 100%;
    height: auto !important;
}

/* Chart.jsのダークモード対応用のクラス */
body.dark-mode canvas,
@media (prefers-color-scheme: dark) {
    canvas {
        filter: brightness(1.1);
    }
}

/* 詳細分析モーダル */
.detail-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.detail-modal-content {
    background: var(--card-bg);
    border-radius: 15px;
    max-width: 900px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 25px 50px rgba(0,0,0,0.3);
    animation: modalSlideIn 0.3s ease;
}

@keyframes modalSlideIn {
    from { 
        opacity: 0; 
        transform: scale(0.8) translateY(50px); 
    }
    to { 
        opacity: 1; 
        transform: scale(1) translateY(0); 
    }
}

.detail-modal-header {
    background: var(--button-bg);
    color: white;
    padding: 25px 30px;
    border-radius: 15px 15px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.detail-modal-title {
    font-size: 1.5em;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 15px;
}

.detail-modal-score {
    font-size: 2.5em;
    font-weight: bold;
    background: rgba(255,255,255,0.2);
    padding: 10px 20px;
    border-radius: 10px;
}

.detail-modal-close {
    cursor: pointer;
    font-size: 2em;
    opacity: 0.8;
    transition: opacity 0.2s;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(255,255,255,0.1);
}

.detail-modal-close:hover {
    opacity: 1;
    background: rgba(255,255,255,0.2);
}

.detail-modal-body {
    padding: 30px;
}

.detail-section {
    margin-bottom: 35px;
}

.detail-section h3 {
    color: var(--positive-color);
    font-size: 1.3em;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 2px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 10px;
}

.detail-section-icon {
    width: 24px;
    height: 24px;
    background: var(--positive-color);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 0.8em;
    font-weight: bold;
}

.analysis-block {
    background: var(--bg-tertiary);
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 20px;
    border-left: 4px solid var(--positive-color);
}

.analysis-block h4 {
    color: var(--text-primary);
    font-size: 1.1em;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.analysis-text {
    color: var(--text-secondary);
    line-height: 1.7;
    font-size: 0.95em;
}

.highlight-number {
    background: var(--positive-color);
    color: white;
    padding: 2px 8px;
    border-radius: 5px;
    font-weight: bold;
}

.example-trade {
    background: rgba(0, 126, 255, 0.1);
    border-left: 4px solid var(--positive-color);
    padding: 15px;
    border-radius: 0 8px 8px 0;
    margin: 15px 0;
}

.example-trade-header {
    font-weight: bold;
    color: var(--positive-color);
    margin-bottom: 8px;
}

.example-trade-content {
    font-size: 0.9em;
    color: var(--text-secondary);
}

.strength-weakness-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
}

.strength-card {
    background: rgba(34, 197, 94, 0.1);
    border-left: 4px solid #22c55e;
    padding: 20px;
    border-radius: 8px;
}

.weakness-card {
    background: rgba(239, 68, 68, 0.1);
    border-left: 4px solid #ef4444;
    padding: 20px;
    border-radius: 8px;
}

.strength-card h4 {
    color: #15803d;
    margin-bottom: 12px;
}

.weakness-card h4 {
    color: #dc2626;
    margin-bottom: 12px;
}

.improvement-tips {
    background: rgba(245, 158, 11, 0.1);
    border-left: 4px solid #f59e0b;
    padding: 20px;
    border-radius: 8px;
    margin-top: 20px;
}

.improvement-tips h4 {
    color: #d97706;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
}

.improvement-list {
    list-style: none;
    padding: 0;
}

.improvement-list li {
    padding: 8px 0;
    color: var(--text-secondary);
    display: flex;
    align-items: flex-start;
    gap: 8px;
}

.improvement-list li::before {
    content: "💡";
    font-size: 1.2em;
}

/* プログレスバー追加 */
.progress-bar {
    width: 100%;
    height: 4px;
    background: var(--border-color);
    border-radius: 2px;
    margin-top: 10px;
    overflow: hidden;
    display: none;
}

.progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--positive-color), var(--positive-color));
    border-radius: 2px;
    transition: width 0.3s ease;
    width: 0%;
}

/* エクスポートセクション */
.export-section {
    background: var(--bg-secondary);
    border-radius: 15px;
    padding: 20px;
    margin-top: 20px;
    box-shadow: var(--card-shadow);
    display: none;
}

.export-section h3 {
    color: var(--text-primary);
    margin-bottom: 15px;
}

.export-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.export-button {
    background: #10b981;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 25px;
    cursor: pointer;
    transition: transform 0.2s;
}

.export-button:hover {
    transform: translateY(-2px);
}

/* レスポンシブ */
@media (max-width: 768px) {
    .container {
        padding: 20px 16px;
    }

    .top-section {
        grid-template-columns: 1fr;
    }
    
    .score-grid {
        grid-template-columns: 1fr;
    }
    
    h1 {
        font-size: 1.5em;
    }
    
    .overall-score .score {
        font-size: 3.5em;
    }

    .score-value {
        font-size: 2em;
    }

    .theme-toggle {
        top: 10px;
        right: 10px;
        padding: 6px 10px;
    }
    
    .strength-weakness-grid {
        grid-template-columns: 1fr;
    }
}

/* スクロールバー */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-tertiary);
}

::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-secondary);
}
    </style>
</head>
<body class="dark-mode">
    <div class="container">
        <header>
            <h1>FX取引評価スコア</h1>
            <p>取引データから5つの評価軸でパフォーマンスを分析</p>
            <button class="theme-toggle" onclick="toggleTheme()">
                <svg viewBox="0 0 24 24" id="theme-icon">
                    <path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>
                </svg>
                <span class="theme-toggle-text">ライトモード</span>
            </button>
        </header>

        <div class="upload-section">
            <h2>取引履歴ファイルをアップロード</h2>
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".html,.htm" />
                <label for="fileInput">ファイルを選択</label>
            </div>
            <div id="fileName"></div>
            <div class="progress-bar" id="progressBar">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
            <div id="fileInfo" class="file-info" style="display: none;">
                <h4>取引履歴情報</h4>
                <div id="tradePeriod"></div>
                <div id="tradeCount"></div>
            </div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>分析中...</p>
            </div>
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="demo-controls">
            <h3>デモデータでテスト</h3>
            <button onclick="generateGoodPerformanceData()">優秀なトレーダーデータ</button>
            <button onclick="generateAveragePerformanceData()">平均的なトレーダーデータ</button>
            <button onclick="generatePoorPerformanceData()">改善が必要なトレーダーデータ</button>
        </div>

        <div id="analysisResults" style="display: none;">
            <div class="top-section">
                <div class="overall-score">
                    <h2>総合評価スコア（全期間）</h2>
                    <div class="score" id="overallScore">0.0</div>
                    <div class="rating" id="overallRating">評価を計算中...</div>
                </div>

                <div class="chart-container">
                    <h3>評価スコア レーダーチャート（全期間総合評価）<span class="help-icon" onclick="showHelp('レーダーチャート')">?</span></h3>
                    <canvas id="radarChart" style="max-height: 350px;"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3>スコア詳細（全期間総合評価）</h3>
                <div class="score-grid" id="scoreGrid">
                    <!-- スコアカードが動的に追加されます -->
                </div>
            </div>

            <div class="chart-container">
                <h3>スコア推移分析<span class="help-icon" onclick="showHelp('スコア推移')">?</span></h3>
                <div class="trend-buttons">
                    <button class="trend-button active" data-metric="overall">総合スコア</button>
                    <button class="trend-button" data-metric="entry">エントリー技術</button>
                    <button class="trend-button" data-metric="drawdown">ドローダウン耐性</button>
                    <button class="trend-button" data-metric="riskreward">リスクリワード力</button>
                    <button class="trend-button" data-metric="riskmanagement">リスク管理力</button>
                    <button class="trend-button" data-metric="stability">収益安定力</button>
                </div>
                <canvas id="trendChart"></canvas>
            </div>
        </div>
    </div>

    <!-- 詳細分析モーダル -->
    <div class="detail-modal" id="detailModal">
        <div class="detail-modal-content">
            <div class="detail-modal-header">
                <div class="detail-modal-title">
                    <span id="modalScoreTitle">エントリー精度力</span>
                    <div class="detail-modal-score" id="modalScoreValue">7.8</div>
                </div>
                <div class="detail-modal-close" id="modalClose">&times;</div>
            </div>
            <div class="detail-modal-body" id="modalBody">
                <!-- 詳細内容が動的に挿入されます -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        // グローバル変数
        let allTrades = [];
        let activeCharts = [];

        // DOM要素の取得
        const fileInput = document.getElementById('fileInput');
        const fileNameEl = document.getElementById('fileName');
        const fileInfoEl = document.getElementById('fileInfo');
        const tradePeriodEl = document.getElementById('tradePeriod');
        const tradeCountEl = document.getElementById('tradeCount');
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('errorMessage');
        const analysisResultsEl = document.getElementById('analysisResults');
        const overallScoreEl = document.getElementById('overallScore');
        const overallRatingEl = document.getElementById('overallRating');
        const scoreGridEl = document.getElementById('scoreGrid');
        const detailModal = document.getElementById('detailModal');
        const modalClose = document.getElementById('modalClose');
        const modalScoreTitle = document.getElementById('modalScoreTitle');
        const modalScoreValue = document.getElementById('modalScoreValue');
        const modalBody = document.getElementById('modalBody');
        let currentTrendMetric = 'overall';

        // ダークモード切り替え
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            const icon = document.getElementById('theme-icon');
            const text = document.querySelector('.theme-toggle-text');
            
            if (isDark) {
                icon.innerHTML = '<path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>';
                text.textContent = 'ライトモード';
            } else {
                icon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
                text.textContent = 'ダークモード';
            }
            
            // Chart.jsのチャートを再描画
            updateChartsTheme();
        }

        // 初期化時にもダークモードのチャートテーマを適用
        document.addEventListener('DOMContentLoaded', function() {
            updateChartsTheme();
        });

        // Chart.jsのテーマ更新
        function updateChartsTheme() {
            activeCharts.forEach(chart => {
                if (chart && chart.options) {
                    const isDark = document.body.classList.contains('dark-mode');
                    const gridColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
                    const textColor = isDark ? '#aaa' : '#666';
                    
                    if (chart.options.scales) {
                        Object.values(chart.options.scales).forEach(scale => {
                            if (scale.grid) scale.grid.color = gridColor;
                            if (scale.ticks) scale.ticks.color = textColor;
                            if (scale.title) scale.title.color = textColor;
                        });
                    }
                    
                    chart.update();
                }
            });
        }

        // イベントリスナー
        fileInput.addEventListener('change', handleFileUpload);
        modalClose.addEventListener('click', closeDetailModal);
        detailModal.addEventListener('click', (e) => {
            if (e.target === detailModal) closeDetailModal();
        });

        // ファイルアップロード処理
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // ファイルサイズ制限（10MB）
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxSize) {
                showError('ファイルサイズが10MBを超えています。より小さいファイルを選択してください。');
                fileInput.value = '';
                return;
            }

            // ファイル形式チェック
            if (!file.name.match(/\.(html|htm)$/i)) {
                showError('HTMLファイル（.html または .htm）を選択してください。');
                fileInput.value = '';
                return;
            }

            resetAnalysisView();
            fileNameEl.textContent = `選択されたファイル: ${file.name}`;
            setLoading(true);

            const reader = new FileReader();
            reader.onerror = () => {
                showError('ファイルの読み込みに失敗しました。');
                setLoading(false);
            };
            reader.onload = (e) => {
                try {
                    parseMT4History(e.target.result);
                } catch (error) {
                    console.error('Parse error:', error);
                    showError('ファイルの解析中にエラーが発生しました。正しいMT4/MT5の取引履歴ファイルか確認してください。');
                    setLoading(false);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        function parseMT4History(htmlContent) {
            try {
                console.log('HTML content length:', htmlContent.length);
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                
                let parsedTrades = [];
                
                // テーブルから解析
                const tables = doc.querySelectorAll('table');
                console.log('Found tables:', tables.length);
                
                for (let table of tables) {
                    const tableTrades = parseTableData(table);
                    if (tableTrades.length > 0) {
                        parsedTrades = parsedTrades.concat(tableTrades);
                        console.log(`Parsed ${tableTrades.length} trades from table`);
                    }
                }
                
                // 代替フォーマット解析
                if (parsedTrades.length === 0) {
                    parsedTrades = parseAlternativeFormat(htmlContent);
                }
                
                // 正規表現による解析
                if (parsedTrades.length === 0) {
                    parsedTrades = parseWithRegex(htmlContent);
                }
                
                console.log(`Total parsed trades: ${parsedTrades.length}`);
                onFileParsed(parsedTrades);
                
            } catch (error) {
                console.error('Parse error:', error);
                showError('ファイルの解析中にエラーが発生しました。ファイル形式を確認してください。');
            } finally {
                setLoading(false);
            }
        }

        function parseTableData(table) {
            const rows = table.querySelectorAll('tr');
            if (rows.length < 2) return [];
            
            const parsedTrades = [];
            let headerMapping = {};
            let dataStartIndex = -1;

            // ヘッダー行を探す
            for (let i = 0; i < Math.min(15, rows.length); i++) {
                const cells = rows[i].querySelectorAll('td, th');
                if (cells.length < 8) continue;
                
                const cellTexts = Array.from(cells).map(cell => 
                    cell.textContent.trim().toLowerCase().replace(/\s+/g, ' ')
                );
                
                // ヘッダー検出
                const hasTicket = cellTexts.some(text => 
                    text.includes('ticket') || text.includes('order') || text.includes('#')
                );
                const hasTime = cellTexts.some(text => 
                    text.includes('time') || text.includes('date') || text.includes('開始') || text.includes('終了')
                );
                const hasType = cellTexts.some(text => 
                    text.includes('type') || text.includes('売買') || text.includes('buy') || text.includes('sell')
                );
                const hasProfit = cellTexts.some(text => 
                    text.includes('profit') || text.includes('損益') || text.includes('pl') || text.includes('pnl')
                );
                
                if ((hasTicket || hasTime) && (hasType || hasProfit)) {
                    console.log('Header found at row:', i, cellTexts);
                    
                    // ヘッダーマッピングを構築
                    cellTexts.forEach((text, idx) => {
                        if (text.includes('ticket') || text.includes('order') || text === '#' || 
                            (text.includes('no') && text.length < 5)) {
                            headerMapping.ticket = idx;
                        }
                        if (text.includes('open') && text.includes('time') || 
                            text.includes('開始') || text.includes('start')) {
                            headerMapping.openTime = idx;
                        }
                        if (text.includes('close') && text.includes('time') || 
                            text.includes('終了') || text.includes('end')) {
                            headerMapping.closeTime = idx;
                        }
                        if (text.includes('type') || text.includes('売買') || 
                            (text.includes('buy') || text.includes('sell')) && text.length < 10) {
                            headerMapping.type = idx;
                        }
                        if (text.includes('size') || text.includes('lots') || text.includes('volume') || 
                            text.includes('ロット') || text.includes('数量')) {
                            headerMapping.size = idx;
                        }
                        if (text.includes('symbol') || text.includes('item') || text.includes('pair') || 
                            text.includes('通貨') || text.includes('銘柄')) {
                            headerMapping.symbol = idx;
                        }
                        if (text.includes('open') && text.includes('price') || 
                            text.includes('開始価格') || text.includes('始値')) {
                            headerMapping.openPrice = idx;
                        }
                        if (text.includes('close') && text.includes('price') || 
                            text.includes('終了価格') || text.includes('終値')) {
                            headerMapping.closePrice = idx;
                        }
                        if (text.includes('profit') || text.includes('損益') || text.includes('pl') || 
                            text.includes('pnl') || text.includes('p/l')) {
                            headerMapping.profit = idx;
                        }
                    });
                    
                    dataStartIndex = i + 1;
                    break;
                }
            }

            if (dataStartIndex === -1) {
                console.log('No header found');
                return [];
            }

            console.log('Header mapping:', headerMapping);

            // データ行を解析
            for (let i = dataStartIndex; i < rows.length; i++) {
                const cells = rows[i].querySelectorAll('td');
                if (cells.length < 8) continue;
                
                const cellTexts = Array.from(cells).map(cell => cell.textContent.trim());
                
                // チケット番号の検証
                const ticketText = cellTexts[headerMapping.ticket] || '';
                if (headerMapping.ticket !== undefined && !/\d/.test(ticketText)) continue;
                
                // 取引タイプの検証
                const type = (cellTexts[headerMapping.type] || '').toLowerCase();
                const isBuyOrSell = type.includes('buy') || type.includes('sell') || 
                                  type.includes('購入') || type.includes('売却');
                
                // 損益データの検証
                let profit = 0;
                if (headerMapping.profit !== undefined) {
                    const profitText = cellTexts[headerMapping.profit] || '';
                    const profitMatch = profitText.match(/-?\d+(?:\.\d+)?/);
                    if (profitMatch) {
                        profit = parseFloat(profitMatch[0]);
                    }
                } else {
                    const lastCellText = cellTexts[cellTexts.length - 1] || '';
                    const profitMatch = lastCellText.match(/-?\d+(?:\.\d+)?/);
                    if (profitMatch) {
                        profit = parseFloat(profitMatch[0]);
                    }
                }
                
                if (isNaN(profit)) continue;

                // 日時の解析
                const openTime = parseDateTime(cellTexts[headerMapping.openTime]);
                const closeTime = parseDateTime(cellTexts[headerMapping.closeTime]) || 
                                parseDateTime(cellTexts[headerMapping.openTime]);
                
                if (!openTime) continue;

                // 通貨ペアの取得
                let symbol = cellTexts[headerMapping.symbol] || 'UNKNOWN';
                if (symbol === 'UNKNOWN' && cellTexts.length > 5) {
                    for (let cell of cellTexts) {
                        if (/^[A-Z]{6}$/.test(cell) || /^[A-Z]{3}\/[A-Z]{3}$/.test(cell)) {
                            symbol = cell;
                            break;
                        }
                    }
                }

                const trade = {
                    ticket: ticketText,
                    openTime,
                    closeTime: closeTime || openTime,
                    type: isBuyOrSell ? (type.includes('buy') || type.includes('購入') ? 'buy' : 'sell') : 'unknown',
                    size: parseFloat(cellTexts[headerMapping.size] || '1') || 1,
                    symbol: symbol,
                    openPrice: parseFloat(cellTexts[headerMapping.openPrice] || '0') || 0,
                    closePrice: parseFloat(cellTexts[headerMapping.closePrice] || '0') || 0,
                    profit,
                    isWin: profit > 0,
                    duration: closeTime && closeTime > openTime ? closeTime.getTime() - openTime.getTime() : 3600000
                };

                parsedTrades.push(trade);
                console.log(`Parsed trade ${parsedTrades.length}:`, trade);
            }
            
            return parsedTrades;
        }

        // 代替フォーマット解析
        function parseAlternativeFormat(htmlContent) {
            console.log('Trying alternative format parsing...');
            const trades = [];
            
            const lines = htmlContent.split(/\n|<br>|<\/tr>/).filter(line => line.trim());
            
            for (let line of lines) {
                const dateMatch = line.match(/\d{4}[./-]\d{2}[./-]\d{2}/);
                const profitMatch = line.match(/-?\d+\.?\d*/g);
                const symbolMatch = line.match(/[A-Z]{6}|[A-Z]{3}\/[A-Z]{3}/);
                
                if (dateMatch && profitMatch && profitMatch.length > 0) {
                    const profit = parseFloat(profitMatch[profitMatch.length - 1]);
                    if (!isNaN(profit)) {
                        trades.push({
                            openTime: new Date(dateMatch[0]),
                            closeTime: new Date(dateMatch[0]),
                            profit,
                            symbol: symbolMatch ? symbolMatch[0] : 'UNKNOWN',
                            isWin: profit > 0,
                            type: Math.random() > 0.5 ? 'buy' : 'sell',
                            size: 1,
                            duration: 3600000
                        });
                    }
                }
            }
            
            console.log(`Alternative format found ${trades.length} trades`);
            return trades;
        }

        // 正規表現による解析
        function parseWithRegex(htmlContent) {
            console.log('Trying regex parsing...');
            const trades = [];
            
            const patterns = [
                /(\d{4}[./-]\d{2}[./-]\d{2}).*?([A-Z]{6}|[A-Z]{3}\/[A-Z]{3}).*?(-?\d+\.?\d*)/g,
                /(-?\d+\.?\d+)/g
            ];
            
            for (let pattern of patterns) {
                const matches = [...htmlContent.matchAll(pattern)];
                
                for (let match of matches) {
                    if (match.length >= 2) {
                        const profit = parseFloat(match[match.length - 1]);
                        if (!isNaN(profit) && Math.abs(profit) > 0.01) {
                            trades.push({
                                openTime: new Date(),
                                closeTime: new Date(),
                                profit,
                                symbol: match[2] || 'UNKNOWN',
                                isWin: profit > 0,
                                type: Math.random() > 0.5 ? 'buy' : 'sell',
                                size: 1,
                                duration: 3600000
                            });
                        }
                    }
                }
                
                if (trades.length > 0) break;
            }
            
            console.log(`Regex parsing found ${trades.length} trades`);
            return trades.slice(0, 200);
        }

        function parseDateTime(dateStr) {
            if (!dateStr) return null;
            
            const patterns = [
                /(\d{4})[./](\d{2})[./](\d{2})\s+(\d{2}):(\d{2})/,
                /(\d{4})[\/](\d{2})[\/](\d{2})\s+(\d{2}):(\d{2})/,
                /(\d{2})[./](\d{2})[./](\d{4})\s+(\d{2}):(\d{2})/,
                /(\d{2})[\/](\d{2})[\/](\d{4})\s+(\d{2}):(\d{2})/,
                /(\d{4})[-](\d{2})[-](\d{2})\s+(\d{2}):(\d{2})/
            ];
            
            for (let pattern of patterns) {
                const match = dateStr.match(pattern);
                if (match) {
                    let year, month, day, hour, minute;
                    
                    if (pattern.source.startsWith('(\\d{4})')) {
                        [, year, month, day, hour, minute] = match.map(Number);
                    } else {
                        if (pattern.source.includes('[./]')) {
                            [, day, month, year, hour, minute] = match.map(Number);
                        } else {
                            [, month, day, year, hour, minute] = match.map(Number);
                        }
                    }
                    
                    const date = new Date(year, month - 1, day, hour || 0, minute || 0);
                    if (!isNaN(date.getTime()) && year > 1990 && year < 2030) {
                        return date;
                    }
                }
            }
            
            const isoDate = new Date(dateStr);
            if (!isNaN(isoDate.getTime())) {
                return isoDate;
            }
            
            return null;
        }

        function onFileParsed(parsedTrades) {
            console.log('Parsed trades received:', parsedTrades.length);
            
            if (parsedTrades && parsedTrades.length > 0) {
                const cleanedTrades = parsedTrades.filter(trade => {
                    // 基本的な検証のみ
                    if (trade.profit === undefined || isNaN(trade.profit)) return false;
                    if (!trade.openTime || !(trade.openTime instanceof Date) || isNaN(trade.openTime.getTime())) return false;
                    
                    // 取引時間の妥当性チェック
                    if (trade.duration && trade.duration < 0) {
                        console.warn('負の取引時間を検出:', trade.duration);
                        trade.duration = Math.abs(trade.duration);
                    }
                    
                    // 日付の妥当性チェック（2000年〜2030年）
                    const year = trade.openTime.getFullYear();
                    if (year < 2000 || year > 2030) {
                        console.warn('異常な日付を検出:', trade.openTime);
                        return false;
                    }
                    
                    // 通貨ペアの正規化
                    if (trade.symbol === 'UNKNOWN' || !trade.symbol) {
                        trade.symbol = 'USDJPY'; // デフォルト値
                    }
                    
                    return true;
                });
                
                console.log(`Cleaned trades: ${cleanedTrades.length}/${parsedTrades.length}`);
                
                if (cleanedTrades.length === 0) {
                    showError('有効な取引データが見つかりませんでした。ファイル内容を確認してください。');
                    return;
                }
                
                // 最低取引数のチェック
                if (cleanedTrades.length < 10) {
                    if (!confirm(`取引データが${cleanedTrades.length}件と少ないですが、分析を続けますか？\n（精度が低下する可能性があります）`)) {
                        return;
                    }
                }
                
                allTrades = cleanedTrades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
                
                const totalProfit = allTrades.reduce((sum, t) => sum + t.profit, 0);
                const winTrades = allTrades.filter(t => t.isWin);
                const winRate = (winTrades.length / allTrades.length * 100).toFixed(1);
                
                console.log(`解析完了: ${allTrades.length}取引, 勝率${winRate}%, 総損益${totalProfit.toFixed(2)}`);
                
                displayFileInfo(allTrades);
                calculateAndDisplayScores(allTrades);
            } else {
                showError('ファイルから取引データを抽出できませんでした。MT4/MT5の取引履歴ファイルを確認してください。');
            }
        }

        function displayFileInfo(trades) {
            if (trades.length === 0) return;
            
            const startDate = new Date(Math.min(...trades.map(t => t.openTime.getTime())));
            const endDate = new Date(Math.max(...trades.map(t => t.closeTime.getTime())));
            const daysDiff = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
            
            const formatDate = (date) => {
                return `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
            };
            
            let periodDescription = '';
            if (daysDiff <= 7) {
                periodDescription = '（日別推移で分析）';
            } else if (daysDiff <= 35) {
                periodDescription = '（週別推移で分析）';
            } else if (daysDiff <= 120) {
                periodDescription = '（月別推移で分析）';
            } else {
                periodDescription = '（四半期別推移で分析）';
            }
            
            tradePeriodEl.textContent = `期間: ${formatDate(startDate)} ～ ${formatDate(endDate)} ${periodDescription}`;
            tradeCountEl.textContent = `総取引数: ${trades.length}回（${daysDiff}日間）`;
            fileInfoEl.style.display = 'block';
        }

        // 評価スコア計算
        function calculateScores(trades) {
            const winTrades = trades.filter(t => t.isWin);
            const lossTrades = trades.filter(t => !t.isWin);
            const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
            const winRate = trades.length > 0 ? winTrades.length / trades.length : 0;

            const entryAccuracy = calculateEntryAccuracy(trades, winRate);
            const drawdownResistance = calculateDrawdownResistance(trades, totalProfit);
            const riskRewardPower = calculateRiskRewardPower(winTrades, lossTrades);
            const riskManagement = calculateRiskManagement(trades, lossTrades);
            const profitStability = calculateProfitStability(trades);

            return {
                entryAccuracy,
                drawdownResistance,
                riskRewardPower,
                riskManagement,
                profitStability
            };
        }

        function calculateEntryAccuracy(trades, winRate) {
            if (trades.length === 0) return { 
                score: 0, 
                metrics: { 
                    '勝率': '0%', 
                    'セッション適合度': '0点', 
                    '総合判定': 'データなし' 
                } 
            };
            
            const winRateScore = Math.min(winRate * 150, 100);
            const sessionScore = calculateSessionScore(trades);
            
            const hourlyWinRates = {};
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (!hourlyWinRates[hour]) hourlyWinRates[hour] = { wins: 0, total: 0 };
                hourlyWinRates[hour].total++;
                if (trade.isWin) hourlyWinRates[hour].wins++;
            });
            
            const hourlyRates = Object.values(hourlyWinRates)
                .filter(data => data.total >= 3)
                .map(data => data.wins / data.total);
            
            let stabilityScore = 50;
            if (hourlyRates.length > 1) {
                const avgRate = hourlyRates.reduce((sum, rate) => sum + rate, 0) / hourlyRates.length;
                const variance = hourlyRates.reduce((sum, rate) => sum + Math.pow(rate - avgRate, 2), 0) / hourlyRates.length;
                const cv = Math.sqrt(variance) / avgRate;
                stabilityScore = Math.max(20, 100 - (cv * 150));
            }
            
            const finalScore = Math.min((winRateScore * 0.5 + sessionScore * 0.25 + stabilityScore * 0.25), 100) / 10;
            
            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    '勝率': `${(winRate * 100).toFixed(1)}%`,
                    'セッション適合度': `${sessionScore.toFixed(0)}点`,
                    '総合判定': finalScore >= 7 ? '優秀' : finalScore >= 5 ? '良好' : '要改善'
                }
            };
        }

        function calculateSessionScore(trades) {
            if (trades.length === 0) return 0;
            
            let sessionTrades = 0;
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if ((hour >= 9 && hour <= 15) || (hour >= 16 && hour <= 18) || hour >= 22 || hour <= 1) {
                    sessionTrades++;
                }
            });
            const sessionRatio = sessionTrades / trades.length;
            return Math.min(sessionRatio * 120, 100);
        }

        function calculateDrawdownResistance(trades, totalProfit) {
            if (trades.length === 0) return { score: 0, metrics: { '最大DD': '¥0', 'DD率': '0%', '回復力': 'データなし' } };
            
            let peak = 0;
            let maxDrawdown = 0;
            let cumulative = 0;
            
            trades.forEach(trade => {
                cumulative += trade.profit;
                if (cumulative > peak) peak = cumulative;
                const drawdown = peak - cumulative;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });

            let score = 100;
            if (peak > 0) {
                const drawdownRatio = maxDrawdown / peak;
                score = Math.max(0, 100 - (drawdownRatio * 200));
            }

            const drawdownRatio = peak > 0 ? maxDrawdown / peak : 0;

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    '最大DD': `¥${Math.round(maxDrawdown).toLocaleString()}`,
                    'DD率': `${(drawdownRatio * 100).toFixed(1)}%`,
                    '回復力': score >= 70 ? '優秀' : score >= 50 ? '良好' : '要改善'
                }
            };
        }

        function calculateRiskRewardPower(winTrades, lossTrades) {
            if (winTrades.length === 0 && lossTrades.length === 0) {
                return { 
                    score: 0, 
                    metrics: { 
                        'RR比': '0.00', 
                        '平均利益': '¥0', 
                        '平均損失': '¥0' 
                    } 
                };
            }
            
            const avgWin = winTrades.length > 0 ? 
                winTrades.reduce((sum, t) => sum + Math.abs(t.profit), 0) / winTrades.length : 0;
            const avgLoss = lossTrades.length > 0 ? 
                Math.abs(lossTrades.reduce((sum, t) => sum + t.profit, 0) / lossTrades.length) : 0;

            let score = 0;
            let riskRewardRatio = 0;
            
            if (avgLoss > 0 && avgWin > 0) {
                riskRewardRatio = avgWin / avgLoss;
                
                if (riskRewardRatio >= 3.0) score = 100;
                else if (riskRewardRatio >= 2.5) score = 90;
                else if (riskRewardRatio >= 2.0) score = 80;
                else if (riskRewardRatio >= 1.5) score = 70;
                else if (riskRewardRatio >= 1.2) score = 60;
                else if (riskRewardRatio >= 1.0) score = 50;
                else if (riskRewardRatio >= 0.8) score = 40;
                else if (riskRewardRatio >= 0.6) score = 30;
                else if (riskRewardRatio >= 0.4) score = 20;
                else score = 10;
                
                const winRate = winTrades.length / (winTrades.length + lossTrades.length);
                if (winRate > 0.6 && riskRewardRatio >= 1.0) {
                    score = Math.min(score + 10, 100);
                }
                
            } else if (winTrades.length > 0 && lossTrades.length === 0) {
                // 損失がない場合
                score = 95;
                riskRewardRatio = 999;
            } else if (winTrades.length === 0 && lossTrades.length > 0) {
                // 利益がない場合
                score = 0;
                riskRewardRatio = 0;
            }

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    'RR比': riskRewardRatio === 999 ? '∞' : riskRewardRatio === 0 ? '0.00' : riskRewardRatio.toFixed(2),
                    '平均利益': `¥${Math.round(avgWin).toLocaleString()}`,
                    '平均損失': `¥${Math.round(avgLoss).toLocaleString()}`
                }
            };
        }

        function calculateRiskManagement(trades, lossTrades) {
            if (trades.length === 0) {
                return { score: 0, metrics: { '損切り徹底度': '0%', '最大損失': '¥0', 'リスク管理': 'データなし' } };
            }
            
            if (lossTrades.length === 0) {
                // 損失がない場合の適切な表現
                return {
                    score: 9.5, // 満点ではなく9.5点
                    metrics: {
                        '損切り徹底度': '損失なし',
                        '最大損失': '¥0',
                        'リスク管理': '優秀'
                    }
                };
            }

            const losses = lossTrades.map(t => Math.abs(t.profit));
            const maxLoss = Math.max(...losses);
            const avgLoss = losses.reduce((sum, loss) => sum + loss, 0) / losses.length;
            
            const bigLossThreshold = avgLoss * 3;
            const bigLossCount = losses.filter(loss => loss > bigLossThreshold).length;
            const bigLossRatio = bigLossCount / lossTrades.length;
            
            const lossVariance = losses.reduce((sum, loss) => sum + Math.pow(loss - avgLoss, 2), 0) / losses.length;
            const lossStdDev = Math.sqrt(lossVariance);
            const lossCV = avgLoss > 0 ? lossStdDev / avgLoss : 0;
            
            let score = 100;
            score -= (bigLossRatio * 50);
            score -= Math.min(lossCV * 30, 30);
            score = Math.max(0, score);

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    '損切り徹底度': `${((1 - bigLossRatio) * 100).toFixed(1)}%`,
                    '最大損失': `¥${Math.round(maxLoss).toLocaleString()}`,
                    'リスク管理': score >= 70 ? '優秀' : score >= 50 ? '良好' : '要改善'
                }
            };
        }

        function calculateProfitStability(trades) {
            if (trades.length === 0) {
                return { 
                    score: 0, 
                    metrics: { 
                        '安定度': 'データなし', 
                        '平均月利': '¥0', 
                        '標準偏差': '¥0' 
                    } 
                };
            }
            
            const dateRange = trades[trades.length - 1].openTime.getTime() - trades[0].openTime.getTime();
            const daysDiff = dateRange / (1000 * 60 * 60 * 24);
            
            if (daysDiff < 30) {
                return calculateWeeklyStability(trades, daysDiff);
            } else if (daysDiff < 90) {
                return calculatePartialMonthlyStability(trades, daysDiff);
            } else {
                return calculateFullMonthlyStability(trades, daysDiff);
            }
        }
        
        function calculateWeeklyStability(trades, daysDiff) {
            const weeklyProfits = {};
            trades.forEach(trade => {
                const weekKey = Math.floor((trade.openTime.getTime() - trades[0].openTime.getTime()) / (7 * 24 * 60 * 60 * 1000));
                if (!weeklyProfits[weekKey]) weeklyProfits[weekKey] = 0;
                weeklyProfits[weekKey] += trade.profit;
            });
            
            const profits = Object.values(weeklyProfits);
            if (profits.length < 2) {
                const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
                return { 
                    score: totalProfit >= 0 ? 5.0 : 2.5, 
                    metrics: { 
                        '期間': `${daysDiff.toFixed(0)}日間`,
                        '総損益': `¥${Math.round(totalProfit).toLocaleString()}`,
                        '安定度': '期間不足'
                    } 
                };
            }
            
            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else {
                stability = 0.1;
            }
            
            const plusWeeks = profits.filter(p => p > 0).length;
            const plusRatio = plusWeeks / profits.length;
            
            const finalScore = Math.min((stability * 60 + plusRatio * 40), 100) / 10;
            
            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    '週次安定度': `${(stability * 100).toFixed(1)}%`,
                    '平均週利': `¥${Math.round(mean).toLocaleString()}`,
                    'プラス週率': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }
        
        function calculatePartialMonthlyStability(trades, daysDiff) {
            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            const profits = Object.values(monthlyProfits);
            const monthCount = profits.length;
            
            if (monthCount < 2) {
                const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
                return { 
                    score: totalProfit >= 0 ? 5.5 : 3.0, 
                    metrics: { 
                        '期間': `${(daysDiff / 30).toFixed(1)}ヶ月`,
                        '総損益': `¥${Math.round(totalProfit).toLocaleString()}`,
                        '安定度': '期間やや不足'
                    } 
                };
            }

            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else {
                stability = 0.1;
            }
            
            const plusMonths = profits.filter(p => p > 0).length;
            const plusRatio = plusMonths / monthCount;
            
            const finalScore = Math.min((stability * 65 + plusRatio * 35), 100) / 10;

            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    '月次安定度': `${(stability * 100).toFixed(1)}%`,
                    '平均月利': `¥${Math.round(mean).toLocaleString()}`,
                    'プラス月率': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }
        
        function calculateFullMonthlyStability(trades, daysDiff) {
            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            const profits = Object.values(monthlyProfits);
            const monthCount = profits.length;

            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else if (mean === 0) {
                stability = stdDev < 1000 ? 0.5 : 0.2;
            } else {
                stability = 0.1;
            }
            
            const plusMonths = profits.filter(p => p > 0).length;
            const plusRatio = plusMonths / monthCount;
            
            const periodBonus = Math.min((monthCount - 3) * 2, 10) / 10;
            
            const finalScore = Math.min((stability * 70 + plusRatio * 30), 100) / 10 + periodBonus;

            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    '月次安定度': `${(stability * 100).toFixed(1)}%`,
                    '平均月利': `¥${Math.round(mean).toLocaleString()}`,
                    'プラス月率': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }

        function calculateAndDisplayScores(trades) {
            const scores = calculateScores(trades);
            
            const overallScore = (
                scores.entryAccuracy.score +
                scores.drawdownResistance.score +
                scores.riskRewardPower.score +
                scores.riskManagement.score +
                scores.profitStability.score
            ) / 5;

            let rating = '';
            if (overallScore >= 8) rating = 'S級トレーダー（卓越）';
            else if (overallScore >= 7) rating = 'A級トレーダー（優秀）';
            else if (overallScore >= 6) rating = 'B級トレーダー（良好）';
            else if (overallScore >= 5) rating = 'C級トレーダー（平均）';
            else if (overallScore >= 4) rating = 'D級トレーダー（要改善）';
            else rating = 'E級トレーダー（大幅改善必要）';

            overallScoreEl.textContent = overallScore.toFixed(1);
            overallRatingEl.textContent = rating;

            createScoreCards(scores);
            createRadarChart(scores);
            createTrendChart(trades, scores);

            analysisResultsEl.style.display = 'block';
        }

        function createScoreCards(scores) {
            const scoreData = [
                { name: 'エントリー技術', data: scores.entryAccuracy },
                { name: 'ドローダウン耐性', data: scores.drawdownResistance },
                { name: 'リスクリワード力', data: scores.riskRewardPower },
                { name: 'リスク管理力', data: scores.riskManagement },
                { name: '収益安定力', data: scores.profitStability }
            ];

            scoreGridEl.innerHTML = scoreData.map((item, index) => {
                const scoreLevel = item.data.score >= 7 ? 'high' : item.data.score >= 4 ? 'mid' : 'low';
                return `
                <div class="score-card" onclick="showDetailModal('${item.name}', ${item.data.score}, ${index})">
                    <div class="score-header">
                        <div class="score-title">${item.name}</div>
                        <div class="score-value" data-score-level="${scoreLevel}">${item.data.score}</div>
                    </div>
                    <div class="score-metrics">
                        ${Object.entries(item.data.metrics).map(([key, value]) => `
                            <div class="metric-item">
                                <span class="metric-label">${key}:</span>
                                <span class="metric-value">${value}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            }).join('');
        }

        function createRadarChart(scores) {
            const ctx = document.getElementById('radarChart').getContext('2d');
            
            activeCharts.forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            activeCharts = [];

            if (typeof Chart === 'undefined') {
                console.error('Chart.js が読み込まれていません');
                return;
            }

            const isDark = document.body.classList.contains('dark-mode');
            const gridColor = isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.1)';
            const textColor = isDark ? '#aaa' : '#666';

            const chartLabels = [
                'エントリー技術',
                'ドローダウン耐性', 
                'リスクリワード力',
                'リスク管理力',
                '収益安定力'
            ];

            const chart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: '評価スコア',
                        data: [
                            scores.entryAccuracy.score,
                            scores.drawdownResistance.score,
                            scores.riskRewardPower.score,
                            scores.riskManagement.score,
                            scores.profitStability.score
                        ],
                        fill: true,
                        backgroundColor: isDark ? 'rgba(0, 200, 255, 0.2)' : 'rgba(0, 126, 255, 0.2)',
                        borderColor: isDark ? 'rgba(0, 200, 255, 1)' : 'rgba(0, 126, 255, 1)',
                        pointBackgroundColor: isDark ? 'rgba(0, 200, 255, 1)' : 'rgba(0, 126, 255, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: isDark ? 'rgba(0, 200, 255, 1)' : 'rgba(0, 126, 255, 1)',
                        borderWidth: 2,
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 10,
                            ticks: {
                                stepSize: 2,
                                font: {
                                    size: 11
                                },
                                color: textColor
                            },
                            grid: {
                                color: gridColor
                            },
                            angleLines: {
                                color: gridColor
                            },
                            pointLabels: {
                                font: {
                                    size: 12,
                                    weight: '500'
                                },
                                color: textColor
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            activeCharts.push(chart);
        }

        function createTrendChart(trades, scores) {
            const timeAxisInfo = determineTimeAxis(trades);
            const periodScores = calculatePeriodScores(trades, timeAxisInfo);
            
            updateTrendButtons(timeAxisInfo);
            
            // 既存のイベントリスナーを削除してから新規追加
            document.querySelectorAll('.trend-button').forEach(button => {
                // 古いリスナーを削除（クローンで置き換え）
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);
                
                newButton.addEventListener('click', function() {
                    document.querySelectorAll('.trend-button').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    currentTrendMetric = this.dataset.metric;
                    updateTrendChart(periodScores, timeAxisInfo);
                });
            });
            
            updateTrendChart(periodScores, timeAxisInfo);
        }

        function determineTimeAxis(trades) {
            if (!trades || trades.length === 0) {
                return { type: 'demo', unit: '期間', periods: 4 };
            }

            const startDate = new Date(Math.min(...trades.map(t => t.openTime.getTime())));
            const endDate = new Date(Math.max(...trades.map(t => t.openTime.getTime())));
            const daysDiff = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);
            
            console.log(`Data period: ${daysDiff.toFixed(0)} days`);

            if (daysDiff <= 7) {
                return { 
                    type: 'daily', 
                    unit: '日別', 
                    periods: Math.max(3, Math.ceil(daysDiff)),
                    startDate,
                    endDate
                };
            } else if (daysDiff <= 35) {
                return { 
                    type: 'weekly', 
                    unit: '週別', 
                    periods: Math.max(3, Math.ceil(daysDiff / 7)),
                    startDate,
                    endDate
                };
            } else if (daysDiff <= 120) {
                return { 
                    type: 'monthly', 
                    unit: '月別', 
                    periods: Math.max(2, Math.ceil(daysDiff / 30)),
                    startDate,
                    endDate
                };
            } else {
                return { 
                    type: 'quarterly', 
                    unit: '四半期別', 
                    periods: Math.max(2, Math.ceil(daysDiff / 90)),
                    startDate,
                    endDate
                };
            }
        }

        function updateTrendButtons(timeAxisInfo) {
            const trendButtonsContainer = document.querySelector('.trend-buttons');
            trendButtonsContainer.innerHTML = `
                <button class="trend-button active" data-metric="overall">総合スコア</button>
                <button class="trend-button" data-metric="entry">エントリー技術</button>
                <button class="trend-button" data-metric="drawdown">ドローダウン耐性</button>
                <button class="trend-button" data-metric="riskreward">リスクリワード力</button>
                <button class="trend-button" data-metric="riskmanagement">リスク管理力</button>
                <button class="trend-button" data-metric="stability">収益安定力</button>
            `;
            
            const chartTitle = document.querySelector('.chart-container h3');
            if (chartTitle && chartTitle.textContent.includes('スコア推移分析')) {
                chartTitle.innerHTML = `スコア推移分析（${timeAxisInfo.unit}推移）<span class="help-icon" onclick="showHelp('スコア推移')">?</span>`;
            }
        }

        function calculatePeriodScores(trades, timeAxisInfo) {
            if (!trades || trades.length === 0 || timeAxisInfo.type === 'demo') {
                return null;
            }

            const periodData = {};
            
            trades.forEach(trade => {
                let periodKey;
                
                switch(timeAxisInfo.type) {
                    case 'daily':
                        periodKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}-${String(trade.openTime.getDate()).padStart(2, '0')}`;
                        break;
                    case 'weekly':
                        const weekStart = new Date(trade.openTime);
                        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                        periodKey = `${weekStart.getFullYear()}-W${Math.ceil(weekStart.getDate() / 7)}`;
                        break;
                    case 'monthly':
                        periodKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                        break;
                    case 'quarterly':
                        const quarter = Math.ceil((trade.openTime.getMonth() + 1) / 3);
                        periodKey = `${trade.openTime.getFullYear()}-Q${quarter}`;
                        break;
                }
                
                if (!periodData[periodKey]) {
                    periodData[periodKey] = [];
                }
                periodData[periodKey].push(trade);
            });

            const periodScores = {};
            Object.entries(periodData).forEach(([period, periodTrades]) => {
                if (periodTrades.length >= 3) {
                    const scores = calculateScores(periodTrades);
                    periodScores[period] = {
                        overall: (scores.entryAccuracy.score + scores.drawdownResistance.score + 
                                scores.riskRewardPower.score + scores.riskManagement.score + 
                                scores.profitStability.score) / 5,
                        entry: scores.entryAccuracy.score,
                        drawdown: scores.drawdownResistance.score,
                        riskreward: scores.riskRewardPower.score,
                        riskmanagement: scores.riskManagement.score,
                        stability: scores.profitStability.score,
                        tradeCount: periodTrades.length,
                        totalProfit: periodTrades.reduce((sum, t) => sum + t.profit, 0)
                    };
                }
            });

            console.log('Period scores calculated:', periodScores);
            return periodScores;
        }

        function updateTrendChart(periodScores = null, timeAxisInfo = null) {
            const ctx = document.getElementById('trendChart').getContext('2d');
            
            if (typeof Chart === 'undefined') {
                console.error('Chart.js が読み込まれていません');
                return;
            }
            
            const existingChart = activeCharts.find(chart => chart && chart.canvas && chart.canvas.id === 'trendChart');
            if (existingChart && typeof existingChart.destroy === 'function') {
                existingChart.destroy();
                activeCharts = activeCharts.filter(chart => !chart || !chart.canvas || chart.canvas.id !== 'trendChart');
            }
            
            let data, labels, label, color;
            
            if (periodScores && Object.keys(periodScores).length > 0 && timeAxisInfo) {
                const periods = Object.keys(periodScores).sort();
                
                data = periods.map(period => {
                    const periodData = periodScores[period];
                    return periodData ? periodData[currentTrendMetric] || 0 : 0;
                });
                
                labels = periods.map(period => formatPeriodLabel(period, timeAxisInfo.type));
                
                console.log('Using real data:', { periods, data, labels });
            } else {
                data = getDemoTrendData(currentTrendMetric);
                labels = ['期間1', '期間2', '期間3', '期間4'];
                console.log('Using demo data');
            }
            
            switch(currentTrendMetric) {
                case 'entry':
                    label = 'エントリー技術';
                    color = 'rgba(34, 197, 94, 1)';
                    break;
                case 'drawdown':
                    label = 'ドローダウン耐性';
                    color = 'rgba(239, 68, 68, 1)';
                    break;
                case 'riskreward':
                    label = 'リスクリワード力';
                    color = 'rgba(168, 85, 247, 1)';
                    break;
                case 'riskmanagement':
                    label = 'リスク管理力';
                    color = 'rgba(245, 158, 11, 1)';
                    break;
                case 'stability':
                    label = '収益安定力';
                    color = 'rgba(6, 182, 212, 1)';
                    break;
                default:
                    label = '総合スコア';
                    color = 'rgba(102, 126, 234, 1)';
            }
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        borderColor: color,
                        backgroundColor: color.replace('1)', '0.1)'),
                        tension: 0.4,
                        fill: true,
                        pointBackgroundColor: color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 10,
                            title: {
                                display: true,
                                text: 'スコア',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: timeAxisInfo ? timeAxisInfo.unit : '期間',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    if (periodScores && timeAxisInfo) {
                                        const periods = Object.keys(periodScores).sort();
                                        const period = periods[context.dataIndex];
                                        const periodData = periodScores[period];
                                        if (periodData) {
                                            return [
                                                `取引数: ${periodData.tradeCount}回`,
                                                `損益: ¥${Math.round(periodData.totalProfit).toLocaleString()}`
                                            ];
                                        }
                                    }
                                    return [];
                                }
                            }
                        }
                    }
                }
            });

            activeCharts.push(chart);
        }

        function formatPeriodLabel(period, type) {
            switch(type) {
                case 'daily':
                    const [year, month, day] = period.split('-');
                    return `${month}/${day}`;
                case 'weekly':
                    const [weekYear, week] = period.split('-W');
                    return `${weekYear}年${week}週`;
                case 'monthly':
                    const [monthYear, monthNum] = period.split('-');
                    return `${monthYear}/${monthNum}`;
                case 'quarterly':
                    const [qYear, quarter] = period.split('-Q');
                    return `${qYear}年Q${quarter}`;
                default:
                    return period;
            }
        }

        function getDemoTrendData(metric) {
            const demoData = {
                overall: [6.2, 6.8, 7.1, 7.5],
                entry: [7.2, 7.5, 7.6, 7.8],
                drawdown: [5.8, 6.0, 6.1, 6.2],
                riskreward: [8.0, 8.2, 8.3, 8.4],
                riskmanagement: [5.2, 5.5, 5.7, 5.8],
                stability: [6.5, 6.7, 6.8, 6.9]
            };
            return demoData[metric] || demoData.overall;
        }

        // デモデータ生成関数
        function generateGoodPerformanceData() {
            const trades = [];
            for (let i = 0; i < 150; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 43200000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.25) * 15000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY'][Math.floor(Math.random() * 3)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        function generateAveragePerformanceData() {
            const trades = [];
            for (let i = 0; i < 100; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 86400000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.45) * 12000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY'][Math.floor(Math.random() * 4)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        function generatePoorPerformanceData() {
            const trades = [];
            for (let i = 0; i < 80; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 172800000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.65) * 18000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY', 'USDCHF'][Math.floor(Math.random() * 5)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        // ユーティリティ関数
        function resetAnalysisView() {
            analysisResultsEl.style.display = 'none';
            errorEl.style.display = 'none';
            fileInfoEl.style.display = 'none';
            
            // より確実なチャート削除とメモリ解放
            activeCharts.forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    try {
                        chart.destroy();
                        // canvas要素もクリア
                        if (chart.canvas) {
                            const ctx = chart.canvas.getContext('2d');
                            ctx.clearRect(0, 0, chart.canvas.width, chart.canvas.height);
                        }
                    } catch (e) {
                        console.warn('チャート削除エラー:', e);
                    }
                }
            });
            activeCharts = [];
            
            // ファイル入力もリセット
            fileInput.value = '';
            fileNameEl.textContent = '';
        }

        function setLoading(isLoading) {
            loadingEl.style.display = isLoading ? 'block' : 'none';
        }

        function showError(message) {
            errorEl.style.display = 'block';
            errorEl.textContent = message;
        }

        function showHelp(title) {
            const helpTexts = {
                'レーダーチャート': '5つの評価軸で全期間の総合的なトレード能力を0-10点で評価します。全取引データを統合して算出した包括的な評価です。',
                'スコア推移': '期間別のスコア変化を表示します。データ量に応じて日別・週別・月別・四半期別で自動調整されます。右肩上がりなら改善傾向を示しています。'
            };
            alert(helpTexts[title] || '説明が見つかりません。');
        }

        // 詳細モーダル表示機能
        function showDetailModal(scoreName, scoreValue, scoreIndex) {
            modalScoreTitle.textContent = scoreName;
            modalScoreValue.textContent = scoreValue;
            
            const detailContent = generateDetailContent(scoreName, scoreValue, scoreIndex);
            modalBody.innerHTML = detailContent;
            
            detailModal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function closeDetailModal() {
            detailModal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function generateDetailContent(scoreName, scoreValue, scoreIndex) {
            const analysisData = getAnalysisData(scoreIndex, allTrades);
            
            return `
                <div class="detail-section">
                    <h3><span class="detail-section-icon">${scoreIndex + 1}</span>採点根拠の詳細</h3>
                    ${analysisData.calculations.map(calc => `
                        <div class="analysis-block">
                            <h4>📊 ${calc.title}</h4>
                            <div class="analysis-text">${calc.content}</div>
                            ${calc.examples ? calc.examples.map(example => `
                                <div class="example-trade">
                                    <div class="example-trade-header">${example.title}</div>
                                    <div class="example-trade-content">${example.content}</div>
                                </div>
                            `).join('') : ''}
                        </div>
                    `).join('')}
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">📈</span>パフォーマンス評価</h3>
                    <div class="strength-weakness-grid">
                        <div class="strength-card">
                            <h4>🎯 あなたの強み</h4>
                            <ul>
                                ${analysisData.strengths.map(strength => `<li>${strength}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="weakness-card">
                            <h4>⚠️ 改善すべき課題</h4>
                            <ul>
                                ${analysisData.weaknesses.map(weakness => `<li>${weakness}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">🚀</span>スコア向上のためのアドバイス</h3>
                    <div class="improvement-tips">
                        <h4>💡 具体的な改善策</h4>
                        <ul class="improvement-list">
                            ${analysisData.improvements.map(tip => `<li>${tip}</li>`).join('')}
                        </ul>
                    </div>
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">📋</span>スコア説明</h3>
                    <div class="analysis-block">
                        <div class="analysis-text">${analysisData.description}</div>
                    </div>
                </div>
            `;
        }

        function getAnalysisData(scoreIndex, trades = []) {
            if (!trades || trades.length === 0) {
                return getTemplateAnalysisData(scoreIndex);
            }

            const stats = calculateRealTimeStats(trades);
            
            switch(scoreIndex) {
                case 0: return getEntryAnalysis(stats, trades);
                case 1: return getDrawdownAnalysis(stats, trades);
                case 2: return getRiskRewardAnalysis(stats, trades);
                case 3: return getRiskManagementAnalysis(stats, trades);
                case 4: return getStabilityAnalysis(stats, trades);
                default: return getTemplateAnalysisData(scoreIndex);
            }
        }

        function calculateRealTimeStats(trades) {
            const winTrades = trades.filter(t => t.isWin);
            const lossTrades = trades.filter(t => !t.isWin);
            const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
            const winRate = trades.length > 0 ? (winTrades.length / trades.length) : 0;
            
            const hourlyStats = {};
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (!hourlyStats[hour]) hourlyStats[hour] = { total: 0, wins: 0, profit: 0 };
                hourlyStats[hour].total++;
                if (trade.isWin) hourlyStats[hour].wins++;
                hourlyStats[hour].profit += trade.profit;
            });

            let tokyoTrades = 0, londonTrades = 0, nyTrades = 0, otherTrades = 0;
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (hour >= 9 && hour <= 15) tokyoTrades++;
                else if (hour >= 16 && hour <= 18) londonTrades++;
                else if (hour >= 22 || hour <= 1) nyTrades++;
                else otherTrades++;
            });

            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            let peak = 0, maxDrawdown = 0, cumulative = 0;
            trades.forEach(trade => {
                cumulative += trade.profit;
                if (cumulative > peak) peak = cumulative;
                const drawdown = peak - cumulative;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });

            const profits = winTrades.map(t => t.profit);
            const losses = lossTrades.map(t => Math.abs(t.profit));
            
            // 空配列対策を追加
            const maxWin = profits.length > 0 ? Math.max(...profits) : 0;
            const maxLoss = losses.length > 0 ? Math.max(...losses) : 0;
            const avgWin = profits.length > 0 ? profits.reduce((sum, p) => sum + p, 0) / profits.length : 0;
            const avgLoss = losses.length > 0 ? losses.reduce((sum, p) => sum + p, 0) / losses.length : 0;

            return {
                totalTrades: trades.length,
                winTrades: winTrades.length,
                lossTrades: lossTrades.length,
                totalProfit,
                winRate,
                maxWin,
                maxLoss,
                avgWin,
                avgLoss,
                maxDrawdown,
                peak,
                hourlyStats,
                sessions: { tokyo: tokyoTrades, london: londonTrades, ny: nyTrades, other: otherTrades },
                monthlyProfits: Object.values(monthlyProfits),
                dateRange: {
                    start: trades.length > 0 ? trades[0].openTime : null,
                    end: trades.length > 0 ? trades[trades.length - 1].openTime : null
                }
            };
        }

        function getEntryAnalysis(stats, trades) {
            const sessionTotal = stats.sessions.tokyo + stats.sessions.london + stats.sessions.ny;
            const sessionRatio = (sessionTotal / stats.totalTrades * 100).toFixed(1);
            
            const bestHours = Object.entries(stats.hourlyStats)
                .filter(([hour, data]) => data.total >= 3)
                .sort((a, b) => (b[1].wins / b[1].total) - (a[1].wins / a[1].total))
                .slice(0, 3);

            return {
                calculations: [
                    {
                        title: "勝率分析",
                        content: `あなたの勝率は<span class="highlight-number">${(stats.winRate * 100).toFixed(1)}%</span>（${stats.winTrades}勝${stats.lossTrades}敗）です。<br>・総取引数: ${stats.totalTrades}回<br>・一般的な目安の50%と比較して${stats.winRate >= 0.5 ? '上回る優秀' : '改善が必要'}な数値<br>・勝ち取引平均: ¥${Math.round(stats.avgWin).toLocaleString()}<br>→ 勝率スコア: <span class="highlight-number">${Math.min(stats.winRate * 150, 100).toFixed(1)}/100点</span>`,
                        examples: bestHours.length > 0 ? [
                            {
                                title: "最も成績の良い時間帯",
                                content: `${bestHours[0][0]}時台: 勝率${(bestHours[0][1].wins / bestHours[0][1].total * 100).toFixed(1)}% (${bestHours[0][1].wins}勝${bestHours[0][1].total - bestHours[0][1].wins}敗)`
                            }
                        ] : []
                    },
                    {
                        title: "市場セッション適合度",
                        content: `主要市場時間での取引分析：<br>・東京時間（9-15時）: ${stats.sessions.tokyo}回取引（${(stats.sessions.tokyo / stats.totalTrades * 100).toFixed(1)}%）<br>・ロンドン時間（16-18時）: ${stats.sessions.london}回取引（${(stats.sessions.london / stats.totalTrades * 100).toFixed(1)}%）<br>・NY時間（22-1時）: ${stats.sessions.ny}回取引（${(stats.sessions.ny / stats.totalTrades * 100).toFixed(1)}%）<br>・その他時間帯: ${stats.sessions.other}回取引（${(stats.sessions.other / stats.totalTrades * 100).toFixed(1)}%）<br><br>→ <span class="highlight-number">${sessionRatio}%</span>が主要セッション時間での取引<br>→ セッション適合度: <span class="highlight-number">${Math.min(sessionTotal / stats.totalTrades * 120, 100).toFixed(1)}/100点</span>`
                    }
                ],
                strengths: [
                    stats.winRate >= 0.6 ? `勝率${(stats.winRate * 100).toFixed(1)}%という高い精度を維持` : `${stats.totalTrades}回の取引データを蓄積`,
                    sessionTotal / stats.totalTrades >= 0.7 ? "主要市場時間を狙った戦略的取引" : "取引時間の分散ができている",
                    stats.avgWin > stats.avgLoss ? "平均利益が平均損失を上回る" : "損失管理を意識した取引"
                ],
                weaknesses: [
                    stats.sessions.other / stats.totalTrades > 0.3 ? `閑散時間帯での取引が${(stats.sessions.other / stats.totalTrades * 100).toFixed(1)}%存在` : "時間帯の偏りが見られる",
                    stats.winRate < 0.5 ? "勝率が50%を下回っている" : "勝率にさらなる向上余地",
                    "エントリータイミングの最適化余地"
                ],
                improvements: [
                    sessionTotal / stats.totalTrades < 0.8 ? "主要セッション時間でのエントリー機会を増やす" : "現在の時間帯戦略を継続",
                    "経済指標発表時間を事前チェックして戦略的にエントリー",
                    stats.sessions.other > 5 ? "閑散時間帯（深夜2-6時）の取引を控える" : "取引時間の最適化を継続",
                    `月次目標勝率を${Math.max(60, (stats.winRate * 100) + 5).toFixed(0)}%に設定して意識向上`
                ],
                description: `エントリー技術は、あなたの「売買タイミングの的確さ」を評価します。現在のスコアは実際の取引データ${stats.totalTrades}回分から算出されており、勝率${(stats.winRate * 100).toFixed(1)}%と市場セッション適合度${sessionRatio}%を基に評価しています。`
            };
        }

        function getDrawdownAnalysis(stats, trades) {
            const drawdownRatio = stats.peak > 0 ? (stats.maxDrawdown / stats.peak * 100) : 0;
            
            return {
                calculations: [
                    {
                        title: "最大ドローダウン分析",
                        content: `資産推移の詳細分析：<br>・最高到達利益: <span class="highlight-number">¥${Math.round(stats.peak).toLocaleString()}</span><br>・最大ドローダウン: <span class="highlight-number">¥${Math.round(stats.maxDrawdown).toLocaleString()}</span><br>・ドローダウン率: <span class="highlight-number">${drawdownRatio.toFixed(1)}%</span><br>・現在の総損益: ¥${Math.round(stats.totalProfit).toLocaleString()}<br><br>${drawdownRatio > 30 ? '大きなドローダウンが発生しています' : drawdownRatio > 15 ? '中程度のドローダウンです' : '良好なドローダウン管理です'}`,
                        examples: stats.maxLoss > 0 ? [
                            {
                                title: "リスク管理の参考値",
                                content: `最大損失額: ¥${Math.round(stats.maxLoss).toLocaleString()}`
                            }
                        ] : []
                    }
                ],
                strengths: [
                    drawdownRatio <= 15 ? "優秀なドローダウン管理（15%以下）" : drawdownRatio <= 30 ? "適切なリスク管理を実施" : "大きな資金減少からの回復経験",
                    stats.totalProfit > 0 ? "最終的にプラス収支を達成" : "継続的な取引実績"
                ],
                weaknesses: [
                    drawdownRatio > 30 ? "大幅なドローダウンが発生" : drawdownRatio > 15 ? "ドローダウンの改善余地あり" : "さらなるリスク管理の強化",
                    "資金管理ルールの見直し必要"
                ],
                improvements: [
                    "1取引あたりのリスクを資金の2%以下に設定",
                    drawdownRatio > 20 ? "ドローダウン20%で取引量を半減させるルール導入" : "現在のリスク管理を継続",
                    "連敗時の冷却期間を設ける（3連敗で1日休む等）",
                    "週次・月次での最大損失額を事前に決めておく"
                ],
                description: `ドローダウン耐性は、資金の最大減少幅を評価します。優れたトレーダーは15%以下、一般的には30%以下が望ましいとされます。あなたのドローダウン率は${drawdownRatio.toFixed(1)}%です。`
            };
        }

        function getRiskRewardAnalysis(stats, trades) {
            const rrRatio = stats.avgLoss > 0 ? stats.avgWin / stats.avgLoss : 0;
            
            return {
                calculations: [
                    {
                        title: "リスクリワード比率の詳細",
                        content: `収益性の分析：<br>・平均利益: <span class="highlight-number">¥${Math.round(stats.avgWin).toLocaleString()}</span><br>・平均損失: <span class="highlight-number">¥${Math.round(stats.avgLoss).toLocaleString()}</span><br>・リスクリワード比: <span class="highlight-number">${rrRatio.toFixed(2)}</span><br><br>${rrRatio >= 2 ? '優秀なリスクリワード比' : rrRatio >= 1 ? '適正なリスクリワード比' : '改善が必要なリスクリワード比'}`,
                        examples: [
                            {
                                title: "最大利益と最大損失",
                                content: `最大利益: ¥${Math.round(stats.maxWin).toLocaleString()}<br>最大損失: ¥${Math.round(stats.maxLoss).toLocaleString()}`
                            }
                        ]
                    }
                ],
                strengths: [
                    rrRatio >= 2 ? "理想的なリスクリワード比（2以上）" : rrRatio >= 1 ? "プラスのリスクリワード比" : "改善の余地あり",
                    stats.maxWin > stats.maxLoss * 2 ? "大きな利益を狙える取引スタイル" : "安定した取引スタイル"
                ],
                weaknesses: [
                    rrRatio < 1 ? "損失が利益を上回る傾向" : rrRatio < 2 ? "リスクリワード比の改善余地" : "さらなる向上の可能性",
                    "利益確定のタイミング最適化"
                ],
                improvements: [
                    "利益目標を損切り幅の2倍以上に設定",
                    rrRatio < 1.5 ? "部分利益確定戦略の導入（半分は早めに確定）" : "現在の利確戦略を継続",
                    "トレーリングストップの活用で利益を伸ばす",
                    "エントリー前にリスクリワード比を必ず確認"
                ],
                description: `リスクリワード力は、1回の損失に対してどれだけの利益を得ているかを評価します。理想は2.0以上、最低でも1.0以上が必要です。あなたの比率は${rrRatio.toFixed(2)}です。`
            };
        }

        function getRiskManagementAnalysis(stats, trades) {
            const consistencyScore = stats.lossTrades > 0 ? 
                (1 - (stats.maxLoss - stats.avgLoss) / stats.avgLoss) * 100 : 100;
            
            return {
                calculations: [
                    {
                        title: "損失管理の一貫性",
                        content: `リスク管理の分析：<br>・平均損失: <span class="highlight-number">¥${Math.round(stats.avgLoss).toLocaleString()}</span><br>・最大損失: <span class="highlight-number">¥${Math.round(stats.maxLoss).toLocaleString()}</span><br>・損失の一貫性: <span class="highlight-number">${consistencyScore.toFixed(1)}%</span><br><br>${consistencyScore >= 70 ? '一貫したリスク管理' : '損失額にばらつきがあります'}`
                    }
                ],
                strengths: [
                    consistencyScore >= 70 ? "一貫した損切り実行" : "損切りルールの存在",
                    stats.lossTrades < stats.winTrades ? "勝ち取引が負け取引を上回る" : "継続的な取引実施"
                ],
                weaknesses: [
                    consistencyScore < 70 ? "損失額のばらつきが大きい" : "さらなる一貫性の向上",
                    stats.maxLoss > stats.avgLoss * 2 ? "大きな損失が発生" : "リスク管理の最適化余地"
                ],
                improvements: [
                    "全取引で固定％の損切りルール徹底",
                    "ポジションサイジング計算ツールの活用",
                    consistencyScore < 80 ? "感情的な損切り回避を防ぐため自動損切り設定" : "現在の損切りルールを継続",
                    "取引日誌で損切り理由を記録・分析"
                ],
                description: `リスク管理力は、損失を一定範囲内に抑える能力を評価します。優れたトレーダーは常に一貫した損切りを実行します。あなたの一貫性スコアは${consistencyScore.toFixed(1)}%です。`
            };
        }

        function getStabilityAnalysis(stats, trades) {
            const profitableMonths = stats.monthlyProfits.filter(p => p > 0).length;
            const totalMonths = stats.monthlyProfits.length;
            const profitRate = totalMonths > 0 ? (profitableMonths / totalMonths * 100) : 0;
            
            return {
                calculations: [
                    {
                        title: "収益の安定性分析",
                        content: `期間別収益の分析：<br>・分析期間: ${totalMonths}ヶ月<br>・プラス月: <span class="highlight-number">${profitableMonths}ヶ月</span><br>・マイナス月: ${totalMonths - profitableMonths}ヶ月<br>・プラス月率: <span class="highlight-number">${profitRate.toFixed(1)}%</span><br><br>${profitRate >= 70 ? '安定した収益性' : profitRate >= 50 ? '改善の余地あり' : '収益の安定化が必要'}`
                    }
                ],
                strengths: [
                    profitRate >= 70 ? "高い月次プラス率" : profitRate >= 50 ? "半数以上の月でプラス" : "継続的な取引実績",
                    stats.totalProfit > 0 ? "トータルでプラス収支" : "経験の蓄積"
                ],
                weaknesses: [
                    profitRate < 70 ? "月次収益の安定性向上が必要" : "さらなる安定性の追求",
                    "収益のばらつき削減"
                ],
                improvements: [
                    "月間取引回数の目標設定（最低20回等）",
                    profitRate < 60 ? "負け月の原因分析と対策立案" : "現在の取引スタイルを継続",
                    "複数の取引戦略を組み合わせてリスク分散",
                    "市場環境に応じた取引量調整ルールの導入"
                ],
                description: `収益安定力は、継続的に利益を出す能力を評価します。プロトレーダーは70%以上の月でプラスを維持します。あなたのプラス月率は${profitRate.toFixed(1)}%です。`
            };
        }

        function getTemplateAnalysisData(scoreIndex) {
            // デフォルトのテンプレートデータ
            const templates = [
                {
                    calculations: [{
                        title: "エントリー技術の評価",
                        content: "データが不足しているため、詳細な分析ができません。取引データをアップロードしてください。"
                    }],
                    strengths: ["分析するデータがありません"],
                    weaknesses: ["データをアップロードしてください"],
                    improvements: ["取引履歴ファイルをアップロードして分析を開始"],
                    description: "エントリー技術の詳細分析にはデータが必要です。"
                }
            ];
            
            return templates[0];
        }
    </script>
</body>
</html>
