<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FXå–å¼•è©•ä¾¡ã‚¹ã‚³ã‚¢ - ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒãƒ£ãƒ¼ãƒˆãƒ„ãƒ¼ãƒ«</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
            min-height: 100vh; 
            color: #333; 
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
        }
        
        header { 
            text-align: center; 
            color: white; 
            margin-bottom: 30px; 
        }
        
        h1 { 
            font-size: 2.5em; 
            margin-bottom: 10px; 
        }
        
        .upload-section { 
            background: white; 
            border-radius: 15px; 
            padding: 30px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); 
            margin-bottom: 30px; 
        }
        
        .file-info { 
            margin-top: 15px; 
            padding: 15px; 
            background: #f8f9fa; 
            border-radius: 8px; 
            border-left: 4px solid #667eea; 
        }
        
        .file-info h4 { 
            color: #667eea; 
            margin-bottom: 8px; 
            font-size: 1em; 
        }
        
        .file-info div { 
            color: #666; 
            font-size: 0.9em; 
            line-height: 1.4; 
        }
        
        .file-input-wrapper { 
            position: relative; 
            overflow: hidden; 
            display: inline-block; 
            cursor: pointer; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
            padding: 12px 30px; 
            border-radius: 25px; 
        }
        
        #fileInput { 
            position: absolute; 
            left: -9999px; 
        }
        
        .radar-container { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 30px; 
            margin-bottom: 30px; 
        }
        
        .top-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chart-container { 
            background: white; 
            border-radius: 15px; 
            padding: 25px; 
            box-shadow: 0 5px 20px rgba(0,0,0,0.1); 
        }
        
        .chart-container h3 { 
            color: #667eea; 
            margin-bottom: 15px; 
            font-size: 1.2em; 
            display: flex; 
            align-items: center; 
            gap: 8px; 
        }
        
        .score-details { 
            background: white; 
            border-radius: 15px; 
            padding: 25px; 
            box-shadow: 0 5px 20px rgba(0,0,0,0.1); 
        }
        
        .score-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
            gap: 20px; 
            margin-top: 20px; 
        }
        
        .score-card { 
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 12px; 
            padding: 20px; 
            border: 2px solid #e5e7eb;
            border-left: 4px solid #667eea; 
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .score-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
            border-left-color: #5a67d8;
            border-color: #667eea;
        }
        
        .score-card::after {
            content: "ã‚¯ãƒªãƒƒã‚¯ã§è©³ç´°åˆ†æ";
            position: absolute;
            bottom: 8px;
            right: 12px;
            font-size: 0.75em;
            color: #667eea;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .score-card:hover::after {
            opacity: 1;
        }
        
        .score-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 15px; 
        }
        
        .score-title { 
            font-weight: bold; 
            color: #374151; 
            font-size: 1.1em; 
        }
        
        .score-value { 
            font-size: 3em; 
            font-weight: bold; 
            color: #667eea;
            text-shadow: 0 2px 4px rgba(102, 126, 234, 0.1);
        }
        
        .score-metrics { 
            margin-top: 10px; 
        }
        
        .metric-item { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 8px; 
            font-size: 0.9em; 
        }
        
        .metric-label { 
            color: #6b7280; 
        }
        
        .metric-value { 
            font-weight: bold; 
            color: #374151; 
        }
        
        .overall-score { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            color: white; 
            border-radius: 15px; 
            padding: 30px; 
            text-align: center; 
            margin-bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }
        
        .overall-score h2 { 
            font-size: 1.5em; 
            margin-bottom: 10px; 
        }
        
        .overall-score .score { 
            font-size: 4em; 
            font-weight: bold; 
            margin-bottom: 10px; 
        }
        
        .overall-score .rating { 
            font-size: 1.2em; 
            opacity: 0.9; 
        }
        
        .loading { 
            display: none; 
            text-align: center; 
            padding: 20px; 
            color: #667eea; 
        }
        
        .spinner { 
            border: 3px solid #f3f3f3; 
            border-top: 3px solid #667eea; 
            border-radius: 50%; 
            width: 40px; 
            height: 40px; 
            animation: spin 1s linear infinite; 
            margin: 0 auto; 
        }
        
        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }
        
        .error-message { 
            background: #fee; 
            color: #c33; 
            padding: 15px; 
            border-radius: 5px; 
            margin-top: 20px; 
            display: none; 
        }
        
        .demo-controls {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        .demo-controls h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .demo-controls button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            margin: 5px;
            transition: transform 0.2s;
        }
        
        .demo-controls button:hover {
            transform: translateY(-2px);
        }
        
        .help-icon { 
            cursor: pointer; 
            color: #9ca3af; 
            font-size: 0.9em; 
            opacity: 0.7; 
            transition: opacity 0.2s; 
        }
        
        .help-icon:hover { 
            opacity: 1; 
            color: #667eea; 
        }
        
        /* è©³ç´°åˆ†æãƒ¢ãƒ¼ãƒ€ãƒ« */
        .detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .detail-modal-content {
            background: white;
            border-radius: 15px;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease;
        }
        
        @keyframes modalSlideIn {
            from { 
                opacity: 0; 
                transform: scale(0.8) translateY(50px); 
            }
            to { 
                opacity: 1; 
                transform: scale(1) translateY(0); 
            }
        }
        
        .detail-modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .detail-modal-title {
            font-size: 1.5em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .detail-modal-score {
            font-size: 2.5em;
            font-weight: bold;
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 10px;
        }
        
        .detail-modal-close {
            cursor: pointer;
            font-size: 2em;
            opacity: 0.8;
            transition: opacity 0.2s;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
        }
        
        .detail-modal-close:hover {
            opacity: 1;
            background: rgba(255,255,255,0.2);
        }
        
        .detail-modal-body {
            padding: 30px;
        }
        
        .detail-section {
            margin-bottom: 35px;
        }
        
        .detail-section h3 {
            color: #667eea;
            font-size: 1.3em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .detail-section-icon {
            width: 24px;
            height: 24px;
            background: #667eea;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .analysis-block {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }
        
        .analysis-block h4 {
            color: #374151;
            font-size: 1.1em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .analysis-text {
            color: #4b5563;
            line-height: 1.7;
            font-size: 0.95em;
        }
        
        .highlight-number {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2px 8px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .example-trade {
            background: #e0f2fe;
            border-left: 4px solid #0288d1;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin: 15px 0;
        }
        
        .example-trade-header {
            font-weight: bold;
            color: #0277bd;
            margin-bottom: 8px;
        }
        
        .example-trade-content {
            font-size: 0.9em;
            color: #455a64;
        }
        
        .strength-weakness-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .strength-card {
            background: #f0fdf4;
            border-left: 4px solid #22c55e;
            padding: 20px;
            border-radius: 8px;
        }
        
        .weakness-card {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
            padding: 20px;
            border-radius: 8px;
        }
        
        .strength-card h4 {
            color: #15803d;
            margin-bottom: 12px;
        }
        
        .weakness-card h4 {
            color: #dc2626;
            margin-bottom: 12px;
        }
        
        .improvement-tips {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .improvement-tips h4 {
            color: #d97706;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .improvement-list {
            list-style: none;
            padding: 0;
        }
        
        .improvement-list li {
            padding: 8px 0;
            color: #92400e;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }
        
        .improvement-list li::before {
            content: "ğŸ’¡";
            font-size: 1.2em;
        }
        
        .trend-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .trend-button {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 20px;
            background: white;
            color: #6b7280;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .trend-button:hover {
            border-color: #667eea;
            color: #667eea;
        }
        
        .trend-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
        }
        
        /* ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼è¿½åŠ  */
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        /* ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ */
        .export-section {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            display: none;
        }
        
        .export-section h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .export-button {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .export-button:hover {
            transform: translateY(-2px);
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³æ”¹å–„ */
        @media (max-width: 768px) {
            .top-section {
                grid-template-columns: 1fr;
            }
            
            .strength-weakness-grid {
                grid-template-columns: 1fr;
            }
            
            .score-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .overall-score .score {
                font-size: 3em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>FXå–å¼•è©•ä¾¡ã‚¹ã‚³ã‚¢</h1>
            <p>å–å¼•ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰5ã¤ã®è©•ä¾¡è»¸ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’åˆ†æ</p>
        </header>

        <div class="upload-section">
            <h2>å–å¼•å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h2>
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".html,.htm" />
                <label for="fileInput">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
            </div>
            <div id="fileName" style="margin-top: 10px; color: #666;"></div>
            <div class="progress-bar" id="progressBar">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
            <div id="fileInfo" class="file-info" style="display: none;">
                <h4>å–å¼•å±¥æ­´æƒ…å ±</h4>
                <div id="tradePeriod"></div>
                <div id="tradeCount"></div>
            </div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>åˆ†æä¸­...</p>
            </div>
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div class="demo-controls">
            <h3>ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ã§ãƒ†ã‚¹ãƒˆ</h3>
            <button onclick="generateGoodPerformanceData()">å„ªç§€ãªãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ‡ãƒ¼ã‚¿</button>
            <button onclick="generateAveragePerformanceData()">å¹³å‡çš„ãªãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ‡ãƒ¼ã‚¿</button>
            <button onclick="generatePoorPerformanceData()">æ”¹å–„ãŒå¿…è¦ãªãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒ‡ãƒ¼ã‚¿</button>
        </div>

        <div id="analysisResults" style="display: none;">
            <div class="top-section">
                <div class="overall-score">
                    <h2>ç·åˆè©•ä¾¡ã‚¹ã‚³ã‚¢ï¼ˆå…¨æœŸé–“ï¼‰</h2>
                    <div class="score" id="overallScore">0.0</div>
                    <div class="rating" id="overallRating">è©•ä¾¡ã‚’è¨ˆç®—ä¸­...</div>
                </div>

                <div class="chart-container">
                    <h3>è©•ä¾¡ã‚¹ã‚³ã‚¢ ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒãƒ£ãƒ¼ãƒˆï¼ˆå…¨æœŸé–“ç·åˆè©•ä¾¡ï¼‰<span class="help-icon" onclick="showHelp('ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒãƒ£ãƒ¼ãƒˆ')">?</span></h3>
                    <canvas id="radarChart" style="max-height: 350px;"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3>ã‚¹ã‚³ã‚¢è©³ç´°ï¼ˆå…¨æœŸé–“ç·åˆè©•ä¾¡ï¼‰</h3>
                <div class="score-grid" id="scoreGrid">
                    <!-- ã‚¹ã‚³ã‚¢ã‚«ãƒ¼ãƒ‰ãŒå‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
                </div>
            </div>

            <div class="chart-container">
                <h3>ã‚¹ã‚³ã‚¢æ¨ç§»åˆ†æ<span class="help-icon" onclick="showHelp('ã‚¹ã‚³ã‚¢æ¨ç§»')">?</span></h3>
                <div class="trend-buttons">
                    <button class="trend-button active" data-metric="overall">ç·åˆã‚¹ã‚³ã‚¢</button>
                    <button class="trend-button" data-metric="entry">ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“</button>
                    <button class="trend-button" data-metric="drawdown">ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§</button>
                    <button class="trend-button" data-metric="riskreward">ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›</button>
                    <button class="trend-button" data-metric="riskmanagement">ãƒªã‚¹ã‚¯ç®¡ç†åŠ›</button>
                    <button class="trend-button" data-metric="stability">åç›Šå®‰å®šåŠ›</button>
                </div>
                <canvas id="trendChart"></canvas>
            </div>
        </div>
    </div>

    <!-- è©³ç´°åˆ†æãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div class="detail-modal" id="detailModal">
        <div class="detail-modal-content">
            <div class="detail-modal-header">
                <div class="detail-modal-title">
                    <span id="modalScoreTitle">ã‚¨ãƒ³ãƒˆãƒªãƒ¼ç²¾åº¦åŠ›</span>
                    <div class="detail-modal-score" id="modalScoreValue">7.8</div>
                </div>
                <div class="detail-modal-close" id="modalClose">&times;</div>
            </div>
            <div class="detail-modal-body" id="modalBody">
                <!-- è©³ç´°å†…å®¹ãŒå‹•çš„ã«æŒ¿å…¥ã•ã‚Œã¾ã™ -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let allTrades = [];
        let activeCharts = [];

        // DOMè¦ç´ ã®å–å¾—
        const fileInput = document.getElementById('fileInput');
        const fileNameEl = document.getElementById('fileName');
        const fileInfoEl = document.getElementById('fileInfo');
        const tradePeriodEl = document.getElementById('tradePeriod');
        const tradeCountEl = document.getElementById('tradeCount');
        const loadingEl = document.getElementById('loading');
        const errorEl = document.getElementById('errorMessage');
        const analysisResultsEl = document.getElementById('analysisResults');
        const overallScoreEl = document.getElementById('overallScore');
        const overallRatingEl = document.getElementById('overallRating');
        const scoreGridEl = document.getElementById('scoreGrid');
        const detailModal = document.getElementById('detailModal');
        const modalClose = document.getElementById('modalClose');
        const modalScoreTitle = document.getElementById('modalScoreTitle');
        const modalScoreValue = document.getElementById('modalScoreValue');
        const modalBody = document.getElementById('modalBody');
        let currentTrendMetric = 'overall';

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        fileInput.addEventListener('change', handleFileUpload);
        modalClose.addEventListener('click', closeDetailModal);
        detailModal.addEventListener('click', (e) => {
            if (e.target === detailModal) closeDetailModal();
        });

        // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºåˆ¶é™ï¼ˆ10MBï¼‰
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxSize) {
                showError('ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒ10MBã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚ã‚ˆã‚Šå°ã•ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                fileInput.value = '';
                return;
            }

            // ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ãƒã‚§ãƒƒã‚¯
            if (!file.name.match(/\.(html|htm)$/i)) {
                showError('HTMLãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆ.html ã¾ãŸã¯ .htmï¼‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                fileInput.value = '';
                return;
            }

            resetAnalysisView();
            fileNameEl.textContent = `é¸æŠã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«: ${file.name}`;
            setLoading(true);

            const reader = new FileReader();
            reader.onerror = () => {
                showError('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                setLoading(false);
            };
            reader.onload = (e) => {
                try {
                    parseMT4History(e.target.result);
                } catch (error) {
                    console.error('Parse error:', error);
                    showError('ãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ­£ã—ã„MT4/MT5ã®å–å¼•å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                    setLoading(false);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        function parseMT4History(htmlContent) {
            try {
                console.log('HTML content length:', htmlContent.length);
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                
                let parsedTrades = [];
                
                // ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰è§£æ
                const tables = doc.querySelectorAll('table');
                console.log('Found tables:', tables.length);
                
                for (let table of tables) {
                    const tableTrades = parseTableData(table);
                    if (tableTrades.length > 0) {
                        parsedTrades = parsedTrades.concat(tableTrades);
                        console.log(`Parsed ${tableTrades.length} trades from table`);
                    }
                }
                
                // ä»£æ›¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè§£æ
                if (parsedTrades.length === 0) {
                    parsedTrades = parseAlternativeFormat(htmlContent);
                }
                
                // æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹è§£æ
                if (parsedTrades.length === 0) {
                    parsedTrades = parseWithRegex(htmlContent);
                }
                
                console.log(`Total parsed trades: ${parsedTrades.length}`);
                onFileParsed(parsedTrades);
                
            } catch (error) {
                console.error('Parse error:', error);
                showError('ãƒ•ã‚¡ã‚¤ãƒ«ã®è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            } finally {
                setLoading(false);
            }
        }

        function parseTableData(table) {
            const rows = table.querySelectorAll('tr');
            if (rows.length < 2) return [];
            
            const parsedTrades = [];
            let headerMapping = {};
            let dataStartIndex = -1;

            // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’æ¢ã™
            for (let i = 0; i < Math.min(15, rows.length); i++) {
                const cells = rows[i].querySelectorAll('td, th');
                if (cells.length < 8) continue;
                
                const cellTexts = Array.from(cells).map(cell => 
                    cell.textContent.trim().toLowerCase().replace(/\s+/g, ' ')
                );
                
                // ãƒ˜ãƒƒãƒ€ãƒ¼æ¤œå‡º
                const hasTicket = cellTexts.some(text => 
                    text.includes('ticket') || text.includes('order') || text.includes('#')
                );
                const hasTime = cellTexts.some(text => 
                    text.includes('time') || text.includes('date') || text.includes('é–‹å§‹') || text.includes('çµ‚äº†')
                );
                const hasType = cellTexts.some(text => 
                    text.includes('type') || text.includes('å£²è²·') || text.includes('buy') || text.includes('sell')
                );
                const hasProfit = cellTexts.some(text => 
                    text.includes('profit') || text.includes('æç›Š') || text.includes('pl') || text.includes('pnl')
                );
                
                if ((hasTicket || hasTime) && (hasType || hasProfit)) {
                    console.log('Header found at row:', i, cellTexts);
                    
                    // ãƒ˜ãƒƒãƒ€ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æ§‹ç¯‰
                    cellTexts.forEach((text, idx) => {
                        if (text.includes('ticket') || text.includes('order') || text === '#' || 
                            (text.includes('no') && text.length < 5)) {
                            headerMapping.ticket = idx;
                        }
                        if (text.includes('open') && text.includes('time') || 
                            text.includes('é–‹å§‹') || text.includes('start')) {
                            headerMapping.openTime = idx;
                        }
                        if (text.includes('close') && text.includes('time') || 
                            text.includes('çµ‚äº†') || text.includes('end')) {
                            headerMapping.closeTime = idx;
                        }
                        if (text.includes('type') || text.includes('å£²è²·') || 
                            (text.includes('buy') || text.includes('sell')) && text.length < 10) {
                            headerMapping.type = idx;
                        }
                        if (text.includes('size') || text.includes('lots') || text.includes('volume') || 
                            text.includes('ãƒ­ãƒƒãƒˆ') || text.includes('æ•°é‡')) {
                            headerMapping.size = idx;
                        }
                        if (text.includes('symbol') || text.includes('item') || text.includes('pair') || 
                            text.includes('é€šè²¨') || text.includes('éŠ˜æŸ„')) {
                            headerMapping.symbol = idx;
                        }
                        if (text.includes('open') && text.includes('price') || 
                            text.includes('é–‹å§‹ä¾¡æ ¼') || text.includes('å§‹å€¤')) {
                            headerMapping.openPrice = idx;
                        }
                        if (text.includes('close') && text.includes('price') || 
                            text.includes('çµ‚äº†ä¾¡æ ¼') || text.includes('çµ‚å€¤')) {
                            headerMapping.closePrice = idx;
                        }
                        if (text.includes('profit') || text.includes('æç›Š') || text.includes('pl') || 
                            text.includes('pnl') || text.includes('p/l')) {
                            headerMapping.profit = idx;
                        }
                    });
                    
                    dataStartIndex = i + 1;
                    break;
                }
            }

            if (dataStartIndex === -1) {
                console.log('No header found');
                return [];
            }

            console.log('Header mapping:', headerMapping);

            // ãƒ‡ãƒ¼ã‚¿è¡Œã‚’è§£æ
            for (let i = dataStartIndex; i < rows.length; i++) {
                const cells = rows[i].querySelectorAll('td');
                if (cells.length < 8) continue;
                
                const cellTexts = Array.from(cells).map(cell => cell.textContent.trim());
                
                // ãƒã‚±ãƒƒãƒˆç•ªå·ã®æ¤œè¨¼
                const ticketText = cellTexts[headerMapping.ticket] || '';
                if (headerMapping.ticket !== undefined && !/\d/.test(ticketText)) continue;
                
                // å–å¼•ã‚¿ã‚¤ãƒ—ã®æ¤œè¨¼
                const type = (cellTexts[headerMapping.type] || '').toLowerCase();
                const isBuyOrSell = type.includes('buy') || type.includes('sell') || 
                                  type.includes('è³¼å…¥') || type.includes('å£²å´');
                
                // æç›Šãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
                let profit = 0;
                if (headerMapping.profit !== undefined) {
                    const profitText = cellTexts[headerMapping.profit] || '';
                    const profitMatch = profitText.match(/-?\d+(?:\.\d+)?/);
                    if (profitMatch) {
                        profit = parseFloat(profitMatch[0]);
                    }
                } else {
                    const lastCellText = cellTexts[cellTexts.length - 1] || '';
                    const profitMatch = lastCellText.match(/-?\d+(?:\.\d+)?/);
                    if (profitMatch) {
                        profit = parseFloat(profitMatch[0]);
                    }
                }
                
                if (isNaN(profit)) continue;

                // æ—¥æ™‚ã®è§£æ
                const openTime = parseDateTime(cellTexts[headerMapping.openTime]);
                const closeTime = parseDateTime(cellTexts[headerMapping.closeTime]) || 
                                parseDateTime(cellTexts[headerMapping.openTime]);
                
                if (!openTime) continue;

                // é€šè²¨ãƒšã‚¢ã®å–å¾—
                let symbol = cellTexts[headerMapping.symbol] || 'UNKNOWN';
                if (symbol === 'UNKNOWN' && cellTexts.length > 5) {
                    for (let cell of cellTexts) {
                        if (/^[A-Z]{6}$/.test(cell) || /^[A-Z]{3}\/[A-Z]{3}$/.test(cell)) {
                            symbol = cell;
                            break;
                        }
                    }
                }

                const trade = {
                    ticket: ticketText,
                    openTime,
                    closeTime: closeTime || openTime,
                    type: isBuyOrSell ? (type.includes('buy') || type.includes('è³¼å…¥') ? 'buy' : 'sell') : 'unknown',
                    size: parseFloat(cellTexts[headerMapping.size] || '1') || 1,
                    symbol: symbol,
                    openPrice: parseFloat(cellTexts[headerMapping.openPrice] || '0') || 0,
                    closePrice: parseFloat(cellTexts[headerMapping.closePrice] || '0') || 0,
                    profit,
                    isWin: profit > 0,
                    duration: closeTime && closeTime > openTime ? closeTime.getTime() - openTime.getTime() : 3600000
                };

                parsedTrades.push(trade);
                console.log(`Parsed trade ${parsedTrades.length}:`, trade);
            }
            
            return parsedTrades;
        }

        // ä»£æ›¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè§£æ
        function parseAlternativeFormat(htmlContent) {
            console.log('Trying alternative format parsing...');
            const trades = [];
            
            const lines = htmlContent.split(/\n|<br>|<\/tr>/).filter(line => line.trim());
            
            for (let line of lines) {
                const dateMatch = line.match(/\d{4}[./-]\d{2}[./-]\d{2}/);
                const profitMatch = line.match(/-?\d+\.?\d*/g);
                const symbolMatch = line.match(/[A-Z]{6}|[A-Z]{3}\/[A-Z]{3}/);
                
                if (dateMatch && profitMatch && profitMatch.length > 0) {
                    const profit = parseFloat(profitMatch[profitMatch.length - 1]);
                    if (!isNaN(profit)) {
                        trades.push({
                            openTime: new Date(dateMatch[0]),
                            closeTime: new Date(dateMatch[0]),
                            profit,
                            symbol: symbolMatch ? symbolMatch[0] : 'UNKNOWN',
                            isWin: profit > 0,
                            type: Math.random() > 0.5 ? 'buy' : 'sell',
                            size: 1,
                            duration: 3600000
                        });
                    }
                }
            }
            
            console.log(`Alternative format found ${trades.length} trades`);
            return trades;
        }

        // æ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹è§£æ
        function parseWithRegex(htmlContent) {
            console.log('Trying regex parsing...');
            const trades = [];
            
            const patterns = [
                /(\d{4}[./-]\d{2}[./-]\d{2}).*?([A-Z]{6}|[A-Z]{3}\/[A-Z]{3}).*?(-?\d+\.?\d*)/g,
                /(-?\d+\.?\d+)/g
            ];
            
            for (let pattern of patterns) {
                const matches = [...htmlContent.matchAll(pattern)];
                
                for (let match of matches) {
                    if (match.length >= 2) {
                        const profit = parseFloat(match[match.length - 1]);
                        if (!isNaN(profit) && Math.abs(profit) > 0.01) {
                            trades.push({
                                openTime: new Date(),
                                closeTime: new Date(),
                                profit,
                                symbol: match[2] || 'UNKNOWN',
                                isWin: profit > 0,
                                type: Math.random() > 0.5 ? 'buy' : 'sell',
                                size: 1,
                                duration: 3600000
                            });
                        }
                    }
                }
                
                if (trades.length > 0) break;
            }
            
            console.log(`Regex parsing found ${trades.length} trades`);
            return trades.slice(0, 200);
        }

        function parseDateTime(dateStr) {
            if (!dateStr) return null;
            
            const patterns = [
                /(\d{4})[./](\d{2})[./](\d{2})\s+(\d{2}):(\d{2})/,
                /(\d{4})[\/](\d{2})[\/](\d{2})\s+(\d{2}):(\d{2})/,
                /(\d{2})[./](\d{2})[./](\d{4})\s+(\d{2}):(\d{2})/,
                /(\d{2})[\/](\d{2})[\/](\d{4})\s+(\d{2}):(\d{2})/,
                /(\d{4})[-](\d{2})[-](\d{2})\s+(\d{2}):(\d{2})/
            ];
            
            for (let pattern of patterns) {
                const match = dateStr.match(pattern);
                if (match) {
                    let year, month, day, hour, minute;
                    
                    if (pattern.source.startsWith('(\\d{4})')) {
                        [, year, month, day, hour, minute] = match.map(Number);
                    } else {
                        if (pattern.source.includes('[./]')) {
                            [, day, month, year, hour, minute] = match.map(Number);
                        } else {
                            [, month, day, year, hour, minute] = match.map(Number);
                        }
                    }
                    
                    const date = new Date(year, month - 1, day, hour || 0, minute || 0);
                    if (!isNaN(date.getTime()) && year > 1990 && year < 2030) {
                        return date;
                    }
                }
            }
            
            const isoDate = new Date(dateStr);
            if (!isNaN(isoDate.getTime())) {
                return isoDate;
            }
            
            return null;
        }

        function onFileParsed(parsedTrades) {
            console.log('Parsed trades received:', parsedTrades.length);
            
            if (parsedTrades && parsedTrades.length > 0) {
                const cleanedTrades = parsedTrades.filter(trade => {
                    // åŸºæœ¬çš„ãªæ¤œè¨¼ã®ã¿
                    if (trade.profit === undefined || isNaN(trade.profit)) return false;
                    if (!trade.openTime || !(trade.openTime instanceof Date) || isNaN(trade.openTime.getTime())) return false;
                    
                    // å–å¼•æ™‚é–“ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                    if (trade.duration && trade.duration < 0) {
                        console.warn('è² ã®å–å¼•æ™‚é–“ã‚’æ¤œå‡º:', trade.duration);
                        trade.duration = Math.abs(trade.duration);
                    }
                    
                    // æ—¥ä»˜ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆ2000å¹´ã€œ2030å¹´ï¼‰
                    const year = trade.openTime.getFullYear();
                    if (year < 2000 || year > 2030) {
                        console.warn('ç•°å¸¸ãªæ—¥ä»˜ã‚’æ¤œå‡º:', trade.openTime);
                        return false;
                    }
                    
                    // é€šè²¨ãƒšã‚¢ã®æ­£è¦åŒ–
                    if (trade.symbol === 'UNKNOWN' || !trade.symbol) {
                        trade.symbol = 'USDJPY'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
                    }
                    
                    return true;
                });
                
                console.log(`Cleaned trades: ${cleanedTrades.length}/${parsedTrades.length}`);
                
                if (cleanedTrades.length === 0) {
                    showError('æœ‰åŠ¹ãªå–å¼•ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                    return;
                }
                
                // æœ€ä½å–å¼•æ•°ã®ãƒã‚§ãƒƒã‚¯
                if (cleanedTrades.length < 10) {
                    if (!confirm(`å–å¼•ãƒ‡ãƒ¼ã‚¿ãŒ${cleanedTrades.length}ä»¶ã¨å°‘ãªã„ã§ã™ãŒã€åˆ†æã‚’ç¶šã‘ã¾ã™ã‹ï¼Ÿ\nï¼ˆç²¾åº¦ãŒä½ä¸‹ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼‰`)) {
                        return;
                    }
                }
                
                allTrades = cleanedTrades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
                
                const totalProfit = allTrades.reduce((sum, t) => sum + t.profit, 0);
                const winTrades = allTrades.filter(t => t.isWin);
                const winRate = (winTrades.length / allTrades.length * 100).toFixed(1);
                
                console.log(`è§£æå®Œäº†: ${allTrades.length}å–å¼•, å‹ç‡${winRate}%, ç·æç›Š${totalProfit.toFixed(2)}`);
                
                displayFileInfo(allTrades);
                calculateAndDisplayScores(allTrades);
            } else {
                showError('ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚MT4/MT5ã®å–å¼•å±¥æ­´ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
            }
        }

        function displayFileInfo(trades) {
            if (trades.length === 0) return;
            
            const startDate = new Date(Math.min(...trades.map(t => t.openTime.getTime())));
            const endDate = new Date(Math.max(...trades.map(t => t.closeTime.getTime())));
            const daysDiff = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
            
            const formatDate = (date) => {
                return `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
            };
            
            let periodDescription = '';
            if (daysDiff <= 7) {
                periodDescription = 'ï¼ˆæ—¥åˆ¥æ¨ç§»ã§åˆ†æï¼‰';
            } else if (daysDiff <= 35) {
                periodDescription = 'ï¼ˆé€±åˆ¥æ¨ç§»ã§åˆ†æï¼‰';
            } else if (daysDiff <= 120) {
                periodDescription = 'ï¼ˆæœˆåˆ¥æ¨ç§»ã§åˆ†æï¼‰';
            } else {
                periodDescription = 'ï¼ˆå››åŠæœŸåˆ¥æ¨ç§»ã§åˆ†æï¼‰';
            }
            
            tradePeriodEl.textContent = `æœŸé–“: ${formatDate(startDate)} ï½ ${formatDate(endDate)} ${periodDescription}`;
            tradeCountEl.textContent = `ç·å–å¼•æ•°: ${trades.length}å›ï¼ˆ${daysDiff}æ—¥é–“ï¼‰`;
            fileInfoEl.style.display = 'block';
        }

        // è©•ä¾¡ã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateScores(trades) {
            const winTrades = trades.filter(t => t.isWin);
            const lossTrades = trades.filter(t => !t.isWin);
            const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
            const winRate = trades.length > 0 ? winTrades.length / trades.length : 0;

            const entryAccuracy = calculateEntryAccuracy(trades, winRate);
            const drawdownResistance = calculateDrawdownResistance(trades, totalProfit);
            const riskRewardPower = calculateRiskRewardPower(winTrades, lossTrades);
            const riskManagement = calculateRiskManagement(trades, lossTrades);
            const profitStability = calculateProfitStability(trades);

            return {
                entryAccuracy,
                drawdownResistance,
                riskRewardPower,
                riskManagement,
                profitStability
            };
        }

        function calculateEntryAccuracy(trades, winRate) {
            if (trades.length === 0) return { 
                score: 0, 
                metrics: { 
                    'å‹ç‡': '0%', 
                    'ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦': '0ç‚¹', 
                    'ç·åˆåˆ¤å®š': 'ãƒ‡ãƒ¼ã‚¿ãªã—' 
                } 
            };
            
            const winRateScore = Math.min(winRate * 150, 100);
            const sessionScore = calculateSessionScore(trades);
            
            const hourlyWinRates = {};
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (!hourlyWinRates[hour]) hourlyWinRates[hour] = { wins: 0, total: 0 };
                hourlyWinRates[hour].total++;
                if (trade.isWin) hourlyWinRates[hour].wins++;
            });
            
            const hourlyRates = Object.values(hourlyWinRates)
                .filter(data => data.total >= 3)
                .map(data => data.wins / data.total);
            
            let stabilityScore = 50;
            if (hourlyRates.length > 1) {
                const avgRate = hourlyRates.reduce((sum, rate) => sum + rate, 0) / hourlyRates.length;
                const variance = hourlyRates.reduce((sum, rate) => sum + Math.pow(rate - avgRate, 2), 0) / hourlyRates.length;
                const cv = Math.sqrt(variance) / avgRate;
                stabilityScore = Math.max(20, 100 - (cv * 150));
            }
            
            const finalScore = Math.min((winRateScore * 0.5 + sessionScore * 0.25 + stabilityScore * 0.25), 100) / 10;
            
            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    'å‹ç‡': `${(winRate * 100).toFixed(1)}%`,
                    'ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦': `${sessionScore.toFixed(0)}ç‚¹`,
                    'ç·åˆåˆ¤å®š': finalScore >= 7 ? 'å„ªç§€' : finalScore >= 5 ? 'è‰¯å¥½' : 'è¦æ”¹å–„'
                }
            };
        }

        function calculateSessionScore(trades) {
            if (trades.length === 0) return 0;
            
            let sessionTrades = 0;
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if ((hour >= 9 && hour <= 15) || (hour >= 16 && hour <= 18) || hour >= 22 || hour <= 1) {
                    sessionTrades++;
                }
            });
            const sessionRatio = sessionTrades / trades.length;
            return Math.min(sessionRatio * 120, 100);
        }

        function calculateDrawdownResistance(trades, totalProfit) {
            if (trades.length === 0) return { score: 0, metrics: { 'æœ€å¤§DD': 'Â¥0', 'DDç‡': '0%', 'å›å¾©åŠ›': 'ãƒ‡ãƒ¼ã‚¿ãªã—' } };
            
            let peak = 0;
            let maxDrawdown = 0;
            let cumulative = 0;
            
            trades.forEach(trade => {
                cumulative += trade.profit;
                if (cumulative > peak) peak = cumulative;
                const drawdown = peak - cumulative;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });

            let score = 100;
            if (peak > 0) {
                const drawdownRatio = maxDrawdown / peak;
                score = Math.max(0, 100 - (drawdownRatio * 200));
            }

            const drawdownRatio = peak > 0 ? maxDrawdown / peak : 0;

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    'æœ€å¤§DD': `Â¥${Math.round(maxDrawdown).toLocaleString()}`,
                    'DDç‡': `${(drawdownRatio * 100).toFixed(1)}%`,
                    'å›å¾©åŠ›': score >= 70 ? 'å„ªç§€' : score >= 50 ? 'è‰¯å¥½' : 'è¦æ”¹å–„'
                }
            };
        }

        function calculateRiskRewardPower(winTrades, lossTrades) {
            if (winTrades.length === 0 && lossTrades.length === 0) {
                return { 
                    score: 0, 
                    metrics: { 
                        'RRæ¯”': '0.00', 
                        'å¹³å‡åˆ©ç›Š': 'Â¥0', 
                        'å¹³å‡æå¤±': 'Â¥0' 
                    } 
                };
            }
            
            const avgWin = winTrades.length > 0 ? 
                winTrades.reduce((sum, t) => sum + Math.abs(t.profit), 0) / winTrades.length : 0;
            const avgLoss = lossTrades.length > 0 ? 
                Math.abs(lossTrades.reduce((sum, t) => sum + t.profit, 0) / lossTrades.length) : 0;

            let score = 0;
            let riskRewardRatio = 0;
            
            if (avgLoss > 0 && avgWin > 0) {
                riskRewardRatio = avgWin / avgLoss;
                
                if (riskRewardRatio >= 3.0) score = 100;
                else if (riskRewardRatio >= 2.5) score = 90;
                else if (riskRewardRatio >= 2.0) score = 80;
                else if (riskRewardRatio >= 1.5) score = 70;
                else if (riskRewardRatio >= 1.2) score = 60;
                else if (riskRewardRatio >= 1.0) score = 50;
                else if (riskRewardRatio >= 0.8) score = 40;
                else if (riskRewardRatio >= 0.6) score = 30;
                else if (riskRewardRatio >= 0.4) score = 20;
                else score = 10;
                
                const winRate = winTrades.length / (winTrades.length + lossTrades.length);
                if (winRate > 0.6 && riskRewardRatio >= 1.0) {
                    score = Math.min(score + 10, 100);
                }
                
            } else if (winTrades.length > 0 && lossTrades.length === 0) {
                // æå¤±ãŒãªã„å ´åˆ
                score = 95;
                riskRewardRatio = 999;
            } else if (winTrades.length === 0 && lossTrades.length > 0) {
                // åˆ©ç›ŠãŒãªã„å ´åˆ
                score = 0;
                riskRewardRatio = 0;
            }

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    'RRæ¯”': riskRewardRatio === 999 ? 'âˆ' : riskRewardRatio === 0 ? '0.00' : riskRewardRatio.toFixed(2),
                    'å¹³å‡åˆ©ç›Š': `Â¥${Math.round(avgWin).toLocaleString()}`,
                    'å¹³å‡æå¤±': `Â¥${Math.round(avgLoss).toLocaleString()}`
                }
            };
        }

        function calculateRiskManagement(trades, lossTrades) {
            if (trades.length === 0) {
                return { score: 0, metrics: { 'æåˆ‡ã‚Šå¾¹åº•åº¦': '0%', 'æœ€å¤§æå¤±': 'Â¥0', 'ãƒªã‚¹ã‚¯ç®¡ç†': 'ãƒ‡ãƒ¼ã‚¿ãªã—' } };
            }
            
            if (lossTrades.length === 0) {
                // æå¤±ãŒãªã„å ´åˆã®é©åˆ‡ãªè¡¨ç¾
                return {
                    score: 9.5, // æº€ç‚¹ã§ã¯ãªã9.5ç‚¹
                    metrics: {
                        'æåˆ‡ã‚Šå¾¹åº•åº¦': 'æå¤±ãªã—',
                        'æœ€å¤§æå¤±': 'Â¥0',
                        'ãƒªã‚¹ã‚¯ç®¡ç†': 'å„ªç§€'
                    }
                };
            }

            const losses = lossTrades.map(t => Math.abs(t.profit));
            const maxLoss = Math.max(...losses);
            const avgLoss = losses.reduce((sum, loss) => sum + loss, 0) / losses.length;
            
            const bigLossThreshold = avgLoss * 3;
            const bigLossCount = losses.filter(loss => loss > bigLossThreshold).length;
            const bigLossRatio = bigLossCount / lossTrades.length;
            
            const lossVariance = losses.reduce((sum, loss) => sum + Math.pow(loss - avgLoss, 2), 0) / losses.length;
            const lossStdDev = Math.sqrt(lossVariance);
            const lossCV = avgLoss > 0 ? lossStdDev / avgLoss : 0;
            
            let score = 100;
            score -= (bigLossRatio * 50);
            score -= Math.min(lossCV * 30, 30);
            score = Math.max(0, score);

            return {
                score: Math.round(score / 10 * 10) / 10,
                metrics: {
                    'æåˆ‡ã‚Šå¾¹åº•åº¦': `${((1 - bigLossRatio) * 100).toFixed(1)}%`,
                    'æœ€å¤§æå¤±': `Â¥${Math.round(maxLoss).toLocaleString()}`,
                    'ãƒªã‚¹ã‚¯ç®¡ç†': score >= 70 ? 'å„ªç§€' : score >= 50 ? 'è‰¯å¥½' : 'è¦æ”¹å–„'
                }
            };
        }

        function calculateProfitStability(trades) {
            if (trades.length === 0) {
                return { 
                    score: 0, 
                    metrics: { 
                        'å®‰å®šåº¦': 'ãƒ‡ãƒ¼ã‚¿ãªã—', 
                        'å¹³å‡æœˆåˆ©': 'Â¥0', 
                        'æ¨™æº–åå·®': 'Â¥0' 
                    } 
                };
            }
            
            const dateRange = trades[trades.length - 1].openTime.getTime() - trades[0].openTime.getTime();
            const daysDiff = dateRange / (1000 * 60 * 60 * 24);
            
            if (daysDiff < 30) {
                return calculateWeeklyStability(trades, daysDiff);
            } else if (daysDiff < 90) {
                return calculatePartialMonthlyStability(trades, daysDiff);
            } else {
                return calculateFullMonthlyStability(trades, daysDiff);
            }
        }
        
        function calculateWeeklyStability(trades, daysDiff) {
            const weeklyProfits = {};
            trades.forEach(trade => {
                const weekKey = Math.floor((trade.openTime.getTime() - trades[0].openTime.getTime()) / (7 * 24 * 60 * 60 * 1000));
                if (!weeklyProfits[weekKey]) weeklyProfits[weekKey] = 0;
                weeklyProfits[weekKey] += trade.profit;
            });
            
            const profits = Object.values(weeklyProfits);
            if (profits.length < 2) {
                const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
                return { 
                    score: totalProfit >= 0 ? 5.0 : 2.5, 
                    metrics: { 
                        'æœŸé–“': `${daysDiff.toFixed(0)}æ—¥é–“`,
                        'ç·æç›Š': `Â¥${Math.round(totalProfit).toLocaleString()}`,
                        'å®‰å®šåº¦': 'æœŸé–“ä¸è¶³'
                    } 
                };
            }
            
            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else {
                stability = 0.1;
            }
            
            const plusWeeks = profits.filter(p => p > 0).length;
            const plusRatio = plusWeeks / profits.length;
            
            const finalScore = Math.min((stability * 60 + plusRatio * 40), 100) / 10;
            
            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    'é€±æ¬¡å®‰å®šåº¦': `${(stability * 100).toFixed(1)}%`,
                    'å¹³å‡é€±åˆ©': `Â¥${Math.round(mean).toLocaleString()}`,
                    'ãƒ—ãƒ©ã‚¹é€±ç‡': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }
        
        function calculatePartialMonthlyStability(trades, daysDiff) {
            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            const profits = Object.values(monthlyProfits);
            const monthCount = profits.length;
            
            if (monthCount < 2) {
                const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
                return { 
                    score: totalProfit >= 0 ? 5.5 : 3.0, 
                    metrics: { 
                        'æœŸé–“': `${(daysDiff / 30).toFixed(1)}ãƒ¶æœˆ`,
                        'ç·æç›Š': `Â¥${Math.round(totalProfit).toLocaleString()}`,
                        'å®‰å®šåº¦': 'æœŸé–“ã‚„ã‚„ä¸è¶³'
                    } 
                };
            }

            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else {
                stability = 0.1;
            }
            
            const plusMonths = profits.filter(p => p > 0).length;
            const plusRatio = plusMonths / monthCount;
            
            const finalScore = Math.min((stability * 65 + plusRatio * 35), 100) / 10;

            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    'æœˆæ¬¡å®‰å®šåº¦': `${(stability * 100).toFixed(1)}%`,
                    'å¹³å‡æœˆåˆ©': `Â¥${Math.round(mean).toLocaleString()}`,
                    'ãƒ—ãƒ©ã‚¹æœˆç‡': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }
        
        function calculateFullMonthlyStability(trades, daysDiff) {
            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            const profits = Object.values(monthlyProfits);
            const monthCount = profits.length;

            const mean = profits.reduce((sum, p) => sum + p, 0) / profits.length;
            const variance = profits.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / profits.length;
            const stdDev = Math.sqrt(variance);
            
            let stability = 0;
            if (mean > 0) {
                const cv = stdDev / mean;
                stability = Math.max(0, 1 - cv);
            } else if (mean === 0) {
                stability = stdDev < 1000 ? 0.5 : 0.2;
            } else {
                stability = 0.1;
            }
            
            const plusMonths = profits.filter(p => p > 0).length;
            const plusRatio = plusMonths / monthCount;
            
            const periodBonus = Math.min((monthCount - 3) * 2, 10) / 10;
            
            const finalScore = Math.min((stability * 70 + plusRatio * 30), 100) / 10 + periodBonus;

            return {
                score: Math.round(finalScore * 10) / 10,
                metrics: {
                    'æœˆæ¬¡å®‰å®šåº¦': `${(stability * 100).toFixed(1)}%`,
                    'å¹³å‡æœˆåˆ©': `Â¥${Math.round(mean).toLocaleString()}`,
                    'ãƒ—ãƒ©ã‚¹æœˆç‡': `${(plusRatio * 100).toFixed(1)}%`
                }
            };
        }

        function calculateAndDisplayScores(trades) {
            const scores = calculateScores(trades);
            
            const overallScore = (
                scores.entryAccuracy.score +
                scores.drawdownResistance.score +
                scores.riskRewardPower.score +
                scores.riskManagement.score +
                scores.profitStability.score
            ) / 5;

            let rating = '';
            if (overallScore >= 8) rating = 'Sç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆå“è¶Šï¼‰';
            else if (overallScore >= 7) rating = 'Aç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆå„ªç§€ï¼‰';
            else if (overallScore >= 6) rating = 'Bç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆè‰¯å¥½ï¼‰';
            else if (overallScore >= 5) rating = 'Cç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆå¹³å‡ï¼‰';
            else if (overallScore >= 4) rating = 'Dç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆè¦æ”¹å–„ï¼‰';
            else rating = 'Eç´šãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼ï¼ˆå¤§å¹…æ”¹å–„å¿…è¦ï¼‰';

            overallScoreEl.textContent = overallScore.toFixed(1);
            overallRatingEl.textContent = rating;

            createScoreCards(scores);
            createRadarChart(scores);
            createTrendChart(trades, scores);

            analysisResultsEl.style.display = 'block';
        }

        function createScoreCards(scores) {
            const scoreData = [
                { name: 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“', data: scores.entryAccuracy },
                { name: 'ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§', data: scores.drawdownResistance },
                { name: 'ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›', data: scores.riskRewardPower },
                { name: 'ãƒªã‚¹ã‚¯ç®¡ç†åŠ›', data: scores.riskManagement },
                { name: 'åç›Šå®‰å®šåŠ›', data: scores.profitStability }
            ];

            scoreGridEl.innerHTML = scoreData.map((item, index) => `
                <div class="score-card" onclick="showDetailModal('${item.name}', ${item.data.score}, ${index})">
                    <div class="score-header">
                        <div class="score-title">${item.name}</div>
                        <div class="score-value">${item.data.score}</div>
                    </div>
                    <div class="score-metrics">
                        ${Object.entries(item.data.metrics).map(([key, value]) => `
                            <div class="metric-item">
                                <span class="metric-label">${key}:</span>
                                <span class="metric-value">${value}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');
        }

        function createRadarChart(scores) {
            const ctx = document.getElementById('radarChart').getContext('2d');
            
            activeCharts.forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            activeCharts = [];

            if (typeof Chart === 'undefined') {
                console.error('Chart.js ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            const chartLabels = [
                'ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“',
                'ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§', 
                'ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›',
                'ãƒªã‚¹ã‚¯ç®¡ç†åŠ›',
                'åç›Šå®‰å®šåŠ›'
            ];

            const chart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'è©•ä¾¡ã‚¹ã‚³ã‚¢',
                        data: [
                            scores.entryAccuracy.score,
                            scores.drawdownResistance.score,
                            scores.riskRewardPower.score,
                            scores.riskManagement.score,
                            scores.profitStability.score
                        ],
                        fill: true,
                        backgroundColor: 'rgba(102, 126, 234, 0.2)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        pointBackgroundColor: 'rgba(102, 126, 234, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2,
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 10,
                            ticks: {
                                stepSize: 2,
                                font: {
                                    size: 11
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            angleLines: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            pointLabels: {
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            activeCharts.push(chart);
        }

        function createTrendChart(trades, scores) {
            const timeAxisInfo = determineTimeAxis(trades);
            const periodScores = calculatePeriodScores(trades, timeAxisInfo);
            
            updateTrendButtons(timeAxisInfo);
            
            // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ã—ã¦ã‹ã‚‰æ–°è¦è¿½åŠ 
            document.querySelectorAll('.trend-button').forEach(button => {
                // å¤ã„ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆã‚¯ãƒ­ãƒ¼ãƒ³ã§ç½®ãæ›ãˆï¼‰
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);
                
                newButton.addEventListener('click', function() {
                    document.querySelectorAll('.trend-button').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    
                    currentTrendMetric = this.dataset.metric;
                    updateTrendChart(periodScores, timeAxisInfo);
                });
            });
            
            updateTrendChart(periodScores, timeAxisInfo);
        }

        function determineTimeAxis(trades) {
            if (!trades || trades.length === 0) {
                return { type: 'demo', unit: 'æœŸé–“', periods: 4 };
            }

            const startDate = new Date(Math.min(...trades.map(t => t.openTime.getTime())));
            const endDate = new Date(Math.max(...trades.map(t => t.openTime.getTime())));
            const daysDiff = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);
            
            console.log(`Data period: ${daysDiff.toFixed(0)} days`);

            if (daysDiff <= 7) {
                return { 
                    type: 'daily', 
                    unit: 'æ—¥åˆ¥', 
                    periods: Math.max(3, Math.ceil(daysDiff)),
                    startDate,
                    endDate
                };
            } else if (daysDiff <= 35) {
                return { 
                    type: 'weekly', 
                    unit: 'é€±åˆ¥', 
                    periods: Math.max(3, Math.ceil(daysDiff / 7)),
                    startDate,
                    endDate
                };
            } else if (daysDiff <= 120) {
                return { 
                    type: 'monthly', 
                    unit: 'æœˆåˆ¥', 
                    periods: Math.max(2, Math.ceil(daysDiff / 30)),
                    startDate,
                    endDate
                };
            } else {
                return { 
                    type: 'quarterly', 
                    unit: 'å››åŠæœŸåˆ¥', 
                    periods: Math.max(2, Math.ceil(daysDiff / 90)),
                    startDate,
                    endDate
                };
            }
        }

        function updateTrendButtons(timeAxisInfo) {
            const trendButtonsContainer = document.querySelector('.trend-buttons');
            trendButtonsContainer.innerHTML = `
                <button class="trend-button active" data-metric="overall">ç·åˆã‚¹ã‚³ã‚¢</button>
                <button class="trend-button" data-metric="entry">ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“</button>
                <button class="trend-button" data-metric="drawdown">ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§</button>
                <button class="trend-button" data-metric="riskreward">ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›</button>
                <button class="trend-button" data-metric="riskmanagement">ãƒªã‚¹ã‚¯ç®¡ç†åŠ›</button>
                <button class="trend-button" data-metric="stability">åç›Šå®‰å®šåŠ›</button>
            `;
            
            const chartTitle = document.querySelector('.chart-container h3');
            if (chartTitle && chartTitle.textContent.includes('ã‚¹ã‚³ã‚¢æ¨ç§»åˆ†æ')) {
                chartTitle.innerHTML = `ã‚¹ã‚³ã‚¢æ¨ç§»åˆ†æï¼ˆ${timeAxisInfo.unit}æ¨ç§»ï¼‰<span class="help-icon" onclick="showHelp('ã‚¹ã‚³ã‚¢æ¨ç§»')">?</span>`;
            }
        }

        function calculatePeriodScores(trades, timeAxisInfo) {
            if (!trades || trades.length === 0 || timeAxisInfo.type === 'demo') {
                return null;
            }

            const periodData = {};
            
            trades.forEach(trade => {
                let periodKey;
                
                switch(timeAxisInfo.type) {
                    case 'daily':
                        periodKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}-${String(trade.openTime.getDate()).padStart(2, '0')}`;
                        break;
                    case 'weekly':
                        const weekStart = new Date(trade.openTime);
                        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                        periodKey = `${weekStart.getFullYear()}-W${Math.ceil(weekStart.getDate() / 7)}`;
                        break;
                    case 'monthly':
                        periodKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                        break;
                    case 'quarterly':
                        const quarter = Math.ceil((trade.openTime.getMonth() + 1) / 3);
                        periodKey = `${trade.openTime.getFullYear()}-Q${quarter}`;
                        break;
                }
                
                if (!periodData[periodKey]) {
                    periodData[periodKey] = [];
                }
                periodData[periodKey].push(trade);
            });

            const periodScores = {};
            Object.entries(periodData).forEach(([period, periodTrades]) => {
                if (periodTrades.length >= 3) {
                    const scores = calculateScores(periodTrades);
                    periodScores[period] = {
                        overall: (scores.entryAccuracy.score + scores.drawdownResistance.score + 
                                scores.riskRewardPower.score + scores.riskManagement.score + 
                                scores.profitStability.score) / 5,
                        entry: scores.entryAccuracy.score,
                        drawdown: scores.drawdownResistance.score,
                        riskreward: scores.riskRewardPower.score,
                        riskmanagement: scores.riskManagement.score,
                        stability: scores.profitStability.score,
                        tradeCount: periodTrades.length,
                        totalProfit: periodTrades.reduce((sum, t) => sum + t.profit, 0)
                    };
                }
            });

            console.log('Period scores calculated:', periodScores);
            return periodScores;
        }

        function updateTrendChart(periodScores = null, timeAxisInfo = null) {
            const ctx = document.getElementById('trendChart').getContext('2d');
            
            if (typeof Chart === 'undefined') {
                console.error('Chart.js ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }
            
            const existingChart = activeCharts.find(chart => chart && chart.canvas && chart.canvas.id === 'trendChart');
            if (existingChart && typeof existingChart.destroy === 'function') {
                existingChart.destroy();
                activeCharts = activeCharts.filter(chart => !chart || !chart.canvas || chart.canvas.id !== 'trendChart');
            }
            
            let data, labels, label, color;
            
            if (periodScores && Object.keys(periodScores).length > 0 && timeAxisInfo) {
                const periods = Object.keys(periodScores).sort();
                
                data = periods.map(period => {
                    const periodData = periodScores[period];
                    return periodData ? periodData[currentTrendMetric] || 0 : 0;
                });
                
                labels = periods.map(period => formatPeriodLabel(period, timeAxisInfo.type));
                
                console.log('Using real data:', { periods, data, labels });
            } else {
                data = getDemoTrendData(currentTrendMetric);
                labels = ['æœŸé–“1', 'æœŸé–“2', 'æœŸé–“3', 'æœŸé–“4'];
                console.log('Using demo data');
            }
            
            switch(currentTrendMetric) {
                case 'entry':
                    label = 'ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“';
                    color = 'rgba(34, 197, 94, 1)';
                    break;
                case 'drawdown':
                    label = 'ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§';
                    color = 'rgba(239, 68, 68, 1)';
                    break;
                case 'riskreward':
                    label = 'ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›';
                    color = 'rgba(168, 85, 247, 1)';
                    break;
                case 'riskmanagement':
                    label = 'ãƒªã‚¹ã‚¯ç®¡ç†åŠ›';
                    color = 'rgba(245, 158, 11, 1)';
                    break;
                case 'stability':
                    label = 'åç›Šå®‰å®šåŠ›';
                    color = 'rgba(6, 182, 212, 1)';
                    break;
                default:
                    label = 'ç·åˆã‚¹ã‚³ã‚¢';
                    color = 'rgba(102, 126, 234, 1)';
            }
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        borderColor: color,
                        backgroundColor: color.replace('1)', '0.1)'),
                        tension: 0.4,
                        fill: true,
                        pointBackgroundColor: color,
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 10,
                            title: {
                                display: true,
                                text: 'ã‚¹ã‚³ã‚¢',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: timeAxisInfo ? timeAxisInfo.unit : 'æœŸé–“',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.05)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    if (periodScores && timeAxisInfo) {
                                        const periods = Object.keys(periodScores).sort();
                                        const period = periods[context.dataIndex];
                                        const periodData = periodScores[period];
                                        if (periodData) {
                                            return [
                                                `å–å¼•æ•°: ${periodData.tradeCount}å›`,
                                                `æç›Š: Â¥${Math.round(periodData.totalProfit).toLocaleString()}`
                                            ];
                                        }
                                    }
                                    return [];
                                }
                            }
                        }
                    }
                }
            });

            activeCharts.push(chart);
        }

        function formatPeriodLabel(period, type) {
            switch(type) {
                case 'daily':
                    const [year, month, day] = period.split('-');
                    return `${month}/${day}`;
                case 'weekly':
                    const [weekYear, week] = period.split('-W');
                    return `${weekYear}å¹´${week}é€±`;
                case 'monthly':
                    const [monthYear, monthNum] = period.split('-');
                    return `${monthYear}/${monthNum}`;
                case 'quarterly':
                    const [qYear, quarter] = period.split('-Q');
                    return `${qYear}å¹´Q${quarter}`;
                default:
                    return period;
            }
        }

        function getDemoTrendData(metric) {
            const demoData = {
                overall: [6.2, 6.8, 7.1, 7.5],
                entry: [7.2, 7.5, 7.6, 7.8],
                drawdown: [5.8, 6.0, 6.1, 6.2],
                riskreward: [8.0, 8.2, 8.3, 8.4],
                riskmanagement: [5.2, 5.5, 5.7, 5.8],
                stability: [6.5, 6.7, 6.8, 6.9]
            };
            return demoData[metric] || demoData.overall;
        }

        // ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆé–¢æ•°
        function generateGoodPerformanceData() {
            const trades = [];
            for (let i = 0; i < 150; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 43200000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.25) * 15000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY'][Math.floor(Math.random() * 3)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        function generateAveragePerformanceData() {
            const trades = [];
            for (let i = 0; i < 100; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 86400000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.45) * 12000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY'][Math.floor(Math.random() * 4)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        function generatePoorPerformanceData() {
            const trades = [];
            for (let i = 0; i < 80; i++) {
                const openTime = new Date(2024, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1, Math.floor(Math.random() * 24), Math.floor(Math.random() * 60));
                const duration = Math.random() * 172800000;
                const closeTime = new Date(openTime.getTime() + duration);
                const profit = (Math.random() - 0.65) * 18000;

                trades.push({
                    openTime,
                    closeTime,
                    duration,
                    profit,
                    isWin: profit > 0,
                    symbol: ['USDJPY', 'EURJPY', 'GBPJPY', 'AUDJPY', 'USDCHF'][Math.floor(Math.random() * 5)],
                    type: Math.random() > 0.5 ? 'buy' : 'sell'
                });
            }
            allTrades = trades.sort((a, b) => a.openTime.getTime() - b.openTime.getTime());
            displayFileInfo(allTrades);
            calculateAndDisplayScores(allTrades);
            analysisResultsEl.style.display = 'block';
        }

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function resetAnalysisView() {
            analysisResultsEl.style.display = 'none';
            errorEl.style.display = 'none';
            fileInfoEl.style.display = 'none';
            
            // ã‚ˆã‚Šç¢ºå®Ÿãªãƒãƒ£ãƒ¼ãƒˆå‰Šé™¤ã¨ãƒ¡ãƒ¢ãƒªè§£æ”¾
            activeCharts.forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    try {
                        chart.destroy();
                        // canvasè¦ç´ ã‚‚ã‚¯ãƒªã‚¢
                        if (chart.canvas) {
                            const ctx = chart.canvas.getContext('2d');
                            ctx.clearRect(0, 0, chart.canvas.width, chart.canvas.height);
                        }
                    } catch (e) {
                        console.warn('ãƒãƒ£ãƒ¼ãƒˆå‰Šé™¤ã‚¨ãƒ©ãƒ¼:', e);
                    }
                }
            });
            activeCharts = [];
            
            // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚‚ãƒªã‚»ãƒƒãƒˆ
            fileInput.value = '';
            fileNameEl.textContent = '';
        }

        function setLoading(isLoading) {
            loadingEl.style.display = isLoading ? 'block' : 'none';
        }

        function showError(message) {
            errorEl.style.display = 'block';
            errorEl.textContent = message;
        }

        function showHelp(title) {
            const helpTexts = {
                'ãƒ¬ãƒ¼ãƒ€ãƒ¼ãƒãƒ£ãƒ¼ãƒˆ': '5ã¤ã®è©•ä¾¡è»¸ã§å…¨æœŸé–“ã®ç·åˆçš„ãªãƒˆãƒ¬ãƒ¼ãƒ‰èƒ½åŠ›ã‚’0-10ç‚¹ã§è©•ä¾¡ã—ã¾ã™ã€‚å…¨å–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’çµ±åˆã—ã¦ç®—å‡ºã—ãŸåŒ…æ‹¬çš„ãªè©•ä¾¡ã§ã™ã€‚',
                'ã‚¹ã‚³ã‚¢æ¨ç§»': 'æœŸé–“åˆ¥ã®ã‚¹ã‚³ã‚¢å¤‰åŒ–ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿é‡ã«å¿œã˜ã¦æ—¥åˆ¥ãƒ»é€±åˆ¥ãƒ»æœˆåˆ¥ãƒ»å››åŠæœŸåˆ¥ã§è‡ªå‹•èª¿æ•´ã•ã‚Œã¾ã™ã€‚å³è‚©ä¸ŠãŒã‚Šãªã‚‰æ”¹å–„å‚¾å‘ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚'
            };
            alert(helpTexts[title] || 'èª¬æ˜ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }

        // è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºæ©Ÿèƒ½
        function showDetailModal(scoreName, scoreValue, scoreIndex) {
            modalScoreTitle.textContent = scoreName;
            modalScoreValue.textContent = scoreValue;
            
            const detailContent = generateDetailContent(scoreName, scoreValue, scoreIndex);
            modalBody.innerHTML = detailContent;
            
            detailModal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function closeDetailModal() {
            detailModal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function generateDetailContent(scoreName, scoreValue, scoreIndex) {
            const analysisData = getAnalysisData(scoreIndex, allTrades);
            
            return `
                <div class="detail-section">
                    <h3><span class="detail-section-icon">${scoreIndex + 1}</span>æ¡ç‚¹æ ¹æ‹ ã®è©³ç´°</h3>
                    ${analysisData.calculations.map(calc => `
                        <div class="analysis-block">
                            <h4>ğŸ“Š ${calc.title}</h4>
                            <div class="analysis-text">${calc.content}</div>
                            ${calc.examples ? calc.examples.map(example => `
                                <div class="example-trade">
                                    <div class="example-trade-header">${example.title}</div>
                                    <div class="example-trade-content">${example.content}</div>
                                </div>
                            `).join('') : ''}
                        </div>
                    `).join('')}
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">ğŸ“ˆ</span>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è©•ä¾¡</h3>
                    <div class="strength-weakness-grid">
                        <div class="strength-card">
                            <h4>ğŸ¯ ã‚ãªãŸã®å¼·ã¿</h4>
                            <ul>
                                ${analysisData.strengths.map(strength => `<li>${strength}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="weakness-card">
                            <h4>âš ï¸ æ”¹å–„ã™ã¹ãèª²é¡Œ</h4>
                            <ul>
                                ${analysisData.weaknesses.map(weakness => `<li>${weakness}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">ğŸš€</span>ã‚¹ã‚³ã‚¢å‘ä¸Šã®ãŸã‚ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹</h3>
                    <div class="improvement-tips">
                        <h4>ğŸ’¡ å…·ä½“çš„ãªæ”¹å–„ç­–</h4>
                        <ul class="improvement-list">
                            ${analysisData.improvements.map(tip => `<li>${tip}</li>`).join('')}
                        </ul>
                    </div>
                </div>

                <div class="detail-section">
                    <h3><span class="detail-section-icon">ğŸ“‹</span>ã‚¹ã‚³ã‚¢èª¬æ˜</h3>
                    <div class="analysis-block">
                        <div class="analysis-text">${analysisData.description}</div>
                    </div>
                </div>
            `;
        }

        function getAnalysisData(scoreIndex, trades = []) {
            if (!trades || trades.length === 0) {
                return getTemplateAnalysisData(scoreIndex);
            }

            const stats = calculateRealTimeStats(trades);
            
            switch(scoreIndex) {
                case 0: return getEntryAnalysis(stats, trades);
                case 1: return getDrawdownAnalysis(stats, trades);
                case 2: return getRiskRewardAnalysis(stats, trades);
                case 3: return getRiskManagementAnalysis(stats, trades);
                case 4: return getStabilityAnalysis(stats, trades);
                default: return getTemplateAnalysisData(scoreIndex);
            }
        }

        function calculateRealTimeStats(trades) {
            const winTrades = trades.filter(t => t.isWin);
            const lossTrades = trades.filter(t => !t.isWin);
            const totalProfit = trades.reduce((sum, t) => sum + t.profit, 0);
            const winRate = trades.length > 0 ? (winTrades.length / trades.length) : 0;
            
            const hourlyStats = {};
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (!hourlyStats[hour]) hourlyStats[hour] = { total: 0, wins: 0, profit: 0 };
                hourlyStats[hour].total++;
                if (trade.isWin) hourlyStats[hour].wins++;
                hourlyStats[hour].profit += trade.profit;
            });

            let tokyoTrades = 0, londonTrades = 0, nyTrades = 0, otherTrades = 0;
            trades.forEach(trade => {
                const hour = trade.openTime.getHours();
                if (hour >= 9 && hour <= 15) tokyoTrades++;
                else if (hour >= 16 && hour <= 18) londonTrades++;
                else if (hour >= 22 || hour <= 1) nyTrades++;
                else otherTrades++;
            });

            const monthlyProfits = {};
            trades.forEach(trade => {
                const monthKey = `${trade.openTime.getFullYear()}-${String(trade.openTime.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyProfits[monthKey]) monthlyProfits[monthKey] = 0;
                monthlyProfits[monthKey] += trade.profit;
            });

            let peak = 0, maxDrawdown = 0, cumulative = 0;
            trades.forEach(trade => {
                cumulative += trade.profit;
                if (cumulative > peak) peak = cumulative;
                const drawdown = peak - cumulative;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });

            const profits = winTrades.map(t => t.profit);
            const losses = lossTrades.map(t => Math.abs(t.profit));
            
            // ç©ºé…åˆ—å¯¾ç­–ã‚’è¿½åŠ 
            const maxWin = profits.length > 0 ? Math.max(...profits) : 0;
            const maxLoss = losses.length > 0 ? Math.max(...losses) : 0;
            const avgWin = profits.length > 0 ? profits.reduce((sum, p) => sum + p, 0) / profits.length : 0;
            const avgLoss = losses.length > 0 ? losses.reduce((sum, p) => sum + p, 0) / losses.length : 0;

            return {
                totalTrades: trades.length,
                winTrades: winTrades.length,
                lossTrades: lossTrades.length,
                totalProfit,
                winRate,
                maxWin,
                maxLoss,
                avgWin,
                avgLoss,
                maxDrawdown,
                peak,
                hourlyStats,
                sessions: { tokyo: tokyoTrades, london: londonTrades, ny: nyTrades, other: otherTrades },
                monthlyProfits: Object.values(monthlyProfits),
                dateRange: {
                    start: trades.length > 0 ? trades[0].openTime : null,
                    end: trades.length > 0 ? trades[trades.length - 1].openTime : null
                }
            };
        }

        function getEntryAnalysis(stats, trades) {
            const sessionTotal = stats.sessions.tokyo + stats.sessions.london + stats.sessions.ny;
            const sessionRatio = (sessionTotal / stats.totalTrades * 100).toFixed(1);
            
            const bestHours = Object.entries(stats.hourlyStats)
                .filter(([hour, data]) => data.total >= 3)
                .sort((a, b) => (b[1].wins / b[1].total) - (a[1].wins / a[1].total))
                .slice(0, 3);

            return {
                calculations: [
                    {
                        title: "å‹ç‡åˆ†æ",
                        content: `ã‚ãªãŸã®å‹ç‡ã¯<span class="highlight-number">${(stats.winRate * 100).toFixed(1)}%</span>ï¼ˆ${stats.winTrades}å‹${stats.lossTrades}æ•—ï¼‰ã§ã™ã€‚<br>ãƒ»ç·å–å¼•æ•°: ${stats.totalTrades}å›<br>ãƒ»ä¸€èˆ¬çš„ãªç›®å®‰ã®50%ã¨æ¯”è¼ƒã—ã¦${stats.winRate >= 0.5 ? 'ä¸Šå›ã‚‹å„ªç§€' : 'æ”¹å–„ãŒå¿…è¦'}ãªæ•°å€¤<br>ãƒ»å‹ã¡å–å¼•å¹³å‡: Â¥${Math.round(stats.avgWin).toLocaleString()}<br>â†’ å‹ç‡ã‚¹ã‚³ã‚¢: <span class="highlight-number">${Math.min(stats.winRate * 150, 100).toFixed(1)}/100ç‚¹</span>`,
                        examples: bestHours.length > 0 ? [
                            {
                                title: "æœ€ã‚‚æˆç¸¾ã®è‰¯ã„æ™‚é–“å¸¯",
                                content: `${bestHours[0][0]}æ™‚å°: å‹ç‡${(bestHours[0][1].wins / bestHours[0][1].total * 100).toFixed(1)}% (${bestHours[0][1].wins}å‹${bestHours[0][1].total - bestHours[0][1].wins}æ•—)`
                            }
                        ] : []
                    },
                    {
                        title: "å¸‚å ´ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦",
                        content: `ä¸»è¦å¸‚å ´æ™‚é–“ã§ã®å–å¼•åˆ†æï¼š<br>ãƒ»æ±äº¬æ™‚é–“ï¼ˆ9-15æ™‚ï¼‰: ${stats.sessions.tokyo}å›å–å¼•ï¼ˆ${(stats.sessions.tokyo / stats.totalTrades * 100).toFixed(1)}%ï¼‰<br>ãƒ»ãƒ­ãƒ³ãƒ‰ãƒ³æ™‚é–“ï¼ˆ16-18æ™‚ï¼‰: ${stats.sessions.london}å›å–å¼•ï¼ˆ${(stats.sessions.london / stats.totalTrades * 100).toFixed(1)}%ï¼‰<br>ãƒ»NYæ™‚é–“ï¼ˆ22-1æ™‚ï¼‰: ${stats.sessions.ny}å›å–å¼•ï¼ˆ${(stats.sessions.ny / stats.totalTrades * 100).toFixed(1)}%ï¼‰<br>ãƒ»ãã®ä»–æ™‚é–“å¸¯: ${stats.sessions.other}å›å–å¼•ï¼ˆ${(stats.sessions.other / stats.totalTrades * 100).toFixed(1)}%ï¼‰<br><br>â†’ <span class="highlight-number">${sessionRatio}%</span>ãŒä¸»è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã§ã®å–å¼•<br>â†’ ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦: <span class="highlight-number">${Math.min(sessionTotal / stats.totalTrades * 120, 100).toFixed(1)}/100ç‚¹</span>`
                    }
                ],
                strengths: [
                    stats.winRate >= 0.6 ? `å‹ç‡${(stats.winRate * 100).toFixed(1)}%ã¨ã„ã†é«˜ã„ç²¾åº¦ã‚’ç¶­æŒ` : `${stats.totalTrades}å›ã®å–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’è“„ç©`,
                    sessionTotal / stats.totalTrades >= 0.7 ? "ä¸»è¦å¸‚å ´æ™‚é–“ã‚’ç‹™ã£ãŸæˆ¦ç•¥çš„å–å¼•" : "å–å¼•æ™‚é–“ã®åˆ†æ•£ãŒã§ãã¦ã„ã‚‹",
                    stats.avgWin > stats.avgLoss ? "å¹³å‡åˆ©ç›ŠãŒå¹³å‡æå¤±ã‚’ä¸Šå›ã‚‹" : "æå¤±ç®¡ç†ã‚’æ„è­˜ã—ãŸå–å¼•"
                ],
                weaknesses: [
                    stats.sessions.other / stats.totalTrades > 0.3 ? `é–‘æ•£æ™‚é–“å¸¯ã§ã®å–å¼•ãŒ${(stats.sessions.other / stats.totalTrades * 100).toFixed(1)}%å­˜åœ¨` : "æ™‚é–“å¸¯ã®åã‚ŠãŒè¦‹ã‚‰ã‚Œã‚‹",
                    stats.winRate < 0.5 ? "å‹ç‡ãŒ50%ã‚’ä¸‹å›ã£ã¦ã„ã‚‹" : "å‹ç‡ã«ã•ã‚‰ãªã‚‹å‘ä¸Šä½™åœ°",
                    "ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®æœ€é©åŒ–ä½™åœ°"
                ],
                improvements: [
                    sessionTotal / stats.totalTrades < 0.8 ? "ä¸»è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã§ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼æ©Ÿä¼šã‚’å¢—ã‚„ã™" : "ç¾åœ¨ã®æ™‚é–“å¸¯æˆ¦ç•¥ã‚’ç¶™ç¶š",
                    "çµŒæ¸ˆæŒ‡æ¨™ç™ºè¡¨æ™‚é–“ã‚’äº‹å‰ãƒã‚§ãƒƒã‚¯ã—ã¦æˆ¦ç•¥çš„ã«ã‚¨ãƒ³ãƒˆãƒªãƒ¼",
                    stats.sessions.other > 5 ? "é–‘æ•£æ™‚é–“å¸¯ï¼ˆæ·±å¤œ2-6æ™‚ï¼‰ã®å–å¼•ã‚’æ§ãˆã‚‹" : "å–å¼•æ™‚é–“ã®æœ€é©åŒ–ã‚’ç¶™ç¶š",
                    `æœˆæ¬¡ç›®æ¨™å‹ç‡ã‚’${Math.max(60, (stats.winRate * 100) + 5).toFixed(0)}%ã«è¨­å®šã—ã¦æ„è­˜å‘ä¸Š`
                ],
                description: `ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“ã¯ã€ã‚ãªãŸã®ã€Œå£²è²·ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®çš„ç¢ºã•ã€ã‚’è©•ä¾¡ã—ã¾ã™ã€‚ç¾åœ¨ã®ã‚¹ã‚³ã‚¢ã¯å®Ÿéš›ã®å–å¼•ãƒ‡ãƒ¼ã‚¿${stats.totalTrades}å›åˆ†ã‹ã‚‰ç®—å‡ºã•ã‚Œã¦ãŠã‚Šã€å‹ç‡${(stats.winRate * 100).toFixed(1)}%ã¨å¸‚å ´ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦${sessionRatio}%ã‚’åŸºã«è©•ä¾¡ã—ã¦ã„ã¾ã™ã€‚`
            };
        }

        function getDrawdownAnalysis(stats, trades) {
            const drawdownRatio = stats.peak > 0 ? (stats.maxDrawdown / stats.peak * 100) : 0;
            
            return {
                calculations: [
                    {
                        title: "æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³åˆ†æ",
                        content: `è³‡ç”£æ¨ç§»ã®è©³ç´°åˆ†æï¼š<br>ãƒ»æœ€é«˜åˆ°é”åˆ©ç›Š: <span class="highlight-number">Â¥${Math.round(stats.peak).toLocaleString()}</span><br>ãƒ»æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³: <span class="highlight-number">Â¥${Math.round(stats.maxDrawdown).toLocaleString()}</span><br>ãƒ»ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ç‡: <span class="highlight-number">${drawdownRatio.toFixed(1)}%</span><br>ãƒ»ç¾åœ¨ã®ç·æç›Š: Â¥${Math.round(stats.totalProfit).toLocaleString()}<br><br>${drawdownRatio > 30 ? 'å¤§ããªãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ãŒç™ºç”Ÿã—ã¦ã„ã¾ã™' : drawdownRatio > 15 ? 'ä¸­ç¨‹åº¦ã®ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ã§ã™' : 'è‰¯å¥½ãªãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ç®¡ç†ã§ã™'}`,
                        examples: stats.maxLoss > 0 ? [
                            {
                                title: "æœ€å¤§æå¤±å–å¼•",
                                content: `å˜ç™ºæœ€å¤§æå¤±: Â¥${Math.round(stats.maxLoss).toLocaleString()}<br>å¹³å‡æå¤±ã®${(stats.maxLoss / stats.avgLoss).toFixed(1)}å€ã®è¦æ¨¡`
                            }
                        ] : []
                    },
                    {
                        title: "å›å¾©åŠ›åˆ†æ",
                        content: `æå¤±ã‹ã‚‰ã®å›å¾©çŠ¶æ³ï¼š<br>ãƒ»ç¾åœ¨ã®ç·åˆ©ç›Š: Â¥${Math.round(stats.totalProfit).toLocaleString()}<br>ãƒ»å›å¾©ç‡: ${stats.peak > 0 ? ((stats.totalProfit + stats.maxDrawdown) / stats.peak * 100).toFixed(1) : 100}%<br><br>${stats.totalProfit >= 0 ? 'æœ€çµ‚çš„ã«ãƒ—ãƒ©ã‚¹åç›Šã‚’é”æˆ' : 'å›å¾©é€”ä¸­ã®çŠ¶æ³'}`
                    }
                ],
                strengths: [
                    stats.totalProfit > 0 ? "æœ€çµ‚çš„ã«ãƒ—ãƒ©ã‚¹åç›Šã‚’é”æˆ" : "å–å¼•ã‚’ç¶™ç¶šã™ã‚‹ç²¾ç¥åŠ›",
                    drawdownRatio < 20 ? "ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ã‚’20%ä»¥ä¸‹ã«æŠ‘åˆ¶" : "åŸºæœ¬çš„ãªãƒªã‚¹ã‚¯ç®¡ç†ã‚’å®Ÿè·µ",
                    stats.totalTrades > 50 ? "ååˆ†ãªå–å¼•çµŒé¨“ã‚’è“„ç©" : "ç¶™ç¶šçš„ãªå–å¼•æ´»å‹•"
                ],
                weaknesses: [
                    drawdownRatio > 25 ? `${drawdownRatio.toFixed(1)}%ã¨ã„ã†å¤§ããªãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ã‚’çµŒé¨“` : "ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ç®¡ç†ã«æ”¹å–„ä½™åœ°",
                    stats.maxLoss > stats.avgLoss * 3 ? "ä¸€éƒ¨ã§å¤§ããªæå¤±ãŒç™ºç”Ÿ" : "æå¤±ã®ã°ã‚‰ã¤ãç®¡ç†",
                    "æ—©æœŸæåˆ‡ã‚Šã®å¾¹åº•ã«èª²é¡Œ"
                ],
                improvements: [
                    "æœ€å¤§æå¤±é¡ã‚’å£åº§æ®‹é«˜ã®3%ä»¥å†…ã«åˆ¶é™",
                    drawdownRatio > 20 ? "ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³15%åˆ°é”æ™‚ç‚¹ã§å–å¼•ãƒ­ãƒƒãƒˆã‚’å‰Šæ¸›" : "ç¾åœ¨ã®ãƒªã‚¹ã‚¯ç®¡ç†ãƒ¬ãƒ™ãƒ«ã‚’ç¶­æŒ",
                    "3é€£æ•—ã—ãŸã‚‰ç¿Œæ—¥ã®å–å¼•ã‚’ä¼‘ã‚“ã§ãƒ¡ãƒ³ã‚¿ãƒ«ãƒªã‚»ãƒƒãƒˆ",
                    "é‡è¦çµŒæ¸ˆæŒ‡æ¨™ç™ºè¡¨å‰ã¯å¿…ãšæåˆ‡ã‚Šè¨­å®šã‚’ç¢ºèª"
                ],
                description: `ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§ã¯ã€ã€Œé€†å¢ƒã«å¯¾ã™ã‚‹å¼·ã•ã€ã‚’æ¸¬å®šã—ã¾ã™ã€‚ã‚ãªãŸã®æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³${drawdownRatio.toFixed(1)}%ã¨å›å¾©å®Ÿç¸¾ã‹ã‚‰ã€${drawdownRatio < 15 ? 'å„ªç§€ãª' : drawdownRatio < 25 ? 'è‰¯å¥½ãª' : 'æ”¹å–„ãŒå¿…è¦ãª'}ãƒªã‚¹ã‚¯ç®¡ç†èƒ½åŠ›ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚`
            };
        }

        function getRiskRewardAnalysis(stats, trades) {
            const rrRatio = stats.avgLoss > 0 ? (stats.avgWin / stats.avgLoss) : 999;
            
            return {
                calculations: [
                    {
                        title: "RRæ¯”åˆ†æ",
                        content: `åˆ©ç›Šãƒ»æå¤±ã®è©³ç´°å†…è¨³ï¼š<br>ãƒ»å¹³å‡åˆ©ç›Š: <span class="highlight-number">Â¥${Math.round(stats.avgWin).toLocaleString()}</span>ï¼ˆ${stats.winTrades}å›ã®å‹ã¡å–å¼•ï¼‰<br>ãƒ»å¹³å‡æå¤±: <span class="highlight-number">Â¥${Math.round(stats.avgLoss).toLocaleString()}</span>ï¼ˆ${stats.lossTrades}å›ã®è² ã‘å–å¼•ï¼‰<br>ãƒ»ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”: <span class="highlight-number">${rrRatio === 999 ? 'âˆ' : rrRatio.toFixed(2)}</span><br><br>${rrRatio >= 2 ? 'éå¸¸ã«å„ªç§€ãªåŠ¹ç‡æ€§ã‚’å®Ÿç¾' : rrRatio >= 1.5 ? 'è‰¯å¥½ãªåŠ¹ç‡æ€§' : rrRatio >= 1 ? 'åŸºæœ¬çš„ãªåŠ¹ç‡æ€§' : 'åŠ¹ç‡æ€§ã®æ”¹å–„ãŒå¿…è¦'}`,
                        examples: stats.maxWin > 0 ? [
                            {
                                title: "æœ€å¤§åˆ©ç›Šå–å¼•",
                                content: `å˜ç™ºæœ€å¤§åˆ©ç›Š: Â¥${Math.round(stats.maxWin).toLocaleString()}<br>å¹³å‡åˆ©ç›Šã®${(stats.maxWin / stats.avgWin).toFixed(1)}å€ã®æˆæœ`
                            }
                        ] : []
                    },
                    {
                        title: "åˆ©ç¢ºãƒ»æåˆ‡ã‚ŠåŠ¹ç‡",
                        content: `åŠ¹ç‡æ€§ã®åˆ†æï¼š<br>ãƒ»åˆ©ç›Šå–å¼•æ¯”ç‡: ${(stats.winTrades / stats.totalTrades * 100).toFixed(1)}%<br>ãƒ»æå¤±å–å¼•æ¯”ç‡: ${(stats.lossTrades / stats.totalTrades * 100).toFixed(1)}%<br>ãƒ»åˆ©ç›Šç·é¡: Â¥${Math.round(stats.winTrades * stats.avgWin).toLocaleString()}<br>ãƒ»æå¤±ç·é¡: Â¥${Math.round(stats.lossTrades * stats.avgLoss).toLocaleString()}<br><br>${rrRatio >= 1 && stats.winRate >= 0.5 ? 'ç†æƒ³çš„ãªåˆ©å¤§æå°ãƒ‘ã‚¿ãƒ¼ãƒ³' : 'æ”¹å–„ä½™åœ°ã‚ã‚Š'}`
                    }
                ],
                strengths: [
                    rrRatio >= 2 ? `RRæ¯”${rrRatio.toFixed(2)}ã¨ã„ã†å„ªç§€ãªåŠ¹ç‡æ€§` : `RRæ¯”${rrRatio.toFixed(2)}ã®åŸºæœ¬çš„åŠ¹ç‡æ€§`,
                    stats.avgWin > stats.avgLoss ? "å¹³å‡åˆ©ç›ŠãŒå¹³å‡æå¤±ã‚’ä¸Šå›ã‚‹" : "æå¤±ç®¡ç†ã‚’å®Ÿè·µ",
                    stats.maxWin > stats.avgWin * 2 ? "å¤§ããªåˆ©ç›Šã‚’å–ã‚‹æŠ€è¡“ã‚’ä¿æœ‰" : "å®‰å®šã—ãŸåˆ©ç›Šç¢ºä¿",
                    rrRatio >= 1 && stats.winRate >= 0.5 ? "åˆ©å¤§æå°ã®ç†æƒ³çš„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®Ÿç¾" : "åŸºæœ¬çš„ãªåç›Šæ§‹é€ ã‚’æ§‹ç¯‰"
                ],
                weaknesses: [
                    rrRatio < 1 ? "å¹³å‡æå¤±ãŒå¹³å‡åˆ©ç›Šã‚’ä¸Šå›ã£ã¦ã„ã‚‹" : "ã•ã‚‰ãªã‚‹åŠ¹ç‡æ€§å‘ä¸Šã®ä½™åœ°",
                    stats.maxLoss > stats.avgLoss * 3 ? "ä¸€éƒ¨ã§å¤§ããªæå¤±ãŒç™ºç”Ÿ" : "æå¤±ç®¡ç†ã®æ”¹å–„ä½™åœ°",
                    stats.winRate < 0.5 && rrRatio < 2 ? "å‹ç‡ã¨RRæ¯”ã®ä¸¡æ–¹ã§æ”¹å–„ãŒå¿…è¦" : "ãƒãƒ©ãƒ³ã‚¹ã®æœ€é©åŒ–ä½™åœ°"
                ],
                improvements: [
                    rrRatio < 1.5 ? "åˆ©ç›Šç›®æ¨™ã‚’ç¾åœ¨ã®1.5å€ã«è¨­å®š" : "ç¾åœ¨ã®åˆ©ç¢ºæˆ¦ç•¥ã‚’ç¶™ç¶š",
                    "æåˆ‡ã‚Šãƒ©ã‚¤ãƒ³ã‚’æ˜ç¢ºã«è¨­å®šã—çµ¶å¯¾ã«å®ˆã‚‹",
                    rrRatio >= 1.5 ? "ãƒˆãƒ¬ãƒ³ãƒ‰ç¶™ç¶šæ™‚ã¯ãƒˆãƒ¬ã‚¤ãƒªãƒ³ã‚°ã‚¹ãƒˆãƒƒãƒ—ã‚’æ´»ç”¨" : "åŸºæœ¬çš„ãªåˆ©ç¢ºãƒ»æåˆ‡ã‚Šãƒ«ãƒ¼ãƒ«ã‚’ç¢ºç«‹",
                    "é‡è¦ã‚µãƒãƒ¼ãƒˆãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ³ã‚¹ä»˜è¿‘ã§ã¯åˆ©ç¢ºã‚’æ…é‡ã«åˆ¤æ–­"
                ],
                description: `ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›ã¯ã€ã€ŒåŠ¹ç‡çš„ãªåˆ©ç›Šç²å¾—èƒ½åŠ›ã€ã‚’è©•ä¾¡ã—ã¾ã™ã€‚ã‚ãªãŸã®RRæ¯”${rrRatio === 999 ? 'âˆ' : rrRatio.toFixed(2)}ã¯ã€${rrRatio >= 2 ? 'å„ªç§€ãª' : rrRatio >= 1.5 ? 'è‰¯å¥½ãª' : rrRatio >= 1 ? 'åŸºæœ¬çš„ãª' : 'æ”¹å–„ãŒå¿…è¦ãª'}åŠ¹ç‡æ€§ã‚’ç¤ºã—ã¦ãŠã‚Šã€å®Ÿéš›ã®å–å¼•${stats.totalTrades}å›ã‹ã‚‰ç®—å‡ºã•ã‚Œã¦ã„ã¾ã™ã€‚`
            };
        }

        function getRiskManagementAnalysis(stats, trades) {
            const bigLossThreshold = stats.avgLoss * 2;
            const bigLossCount = trades.filter(t => !t.isWin && Math.abs(t.profit) > bigLossThreshold).length;
            const bigLossRatio = stats.lossTrades > 0 ? (bigLossCount / stats.lossTrades) : 0;
            
            return {
                calculations: [
                    {
                        title: "æåˆ‡ã‚Šå¾¹åº•åº¦",
                        content: `æå¤±ç®¡ç†ã®çŠ¶æ³ï¼š<br>ãƒ»å¹³å‡æå¤±ã®2å€ä»¥ä¸Š: <span class="highlight-number">${bigLossCount}å›</span>ï¼ˆæå¤±å–å¼•ã®${(bigLossRatio * 100).toFixed(1)}%ï¼‰<br>ãƒ»æœ€å¤§æå¤±: <span class="highlight-number">Â¥${Math.round(stats.maxLoss).toLocaleString()}</span><br>ãƒ»å¹³å‡æå¤±: Â¥${Math.round(stats.avgLoss).toLocaleString()}<br><br>${bigLossRatio < 0.2 ? 'è‰¯å¥½ãªæåˆ‡ã‚Šç®¡ç†' : bigLossRatio < 0.4 ? 'åŸºæœ¬çš„ãªæåˆ‡ã‚Šç®¡ç†' : 'æåˆ‡ã‚Šç®¡ç†ã®æ”¹å–„ãŒå¿…è¦'}`,
                        examples: bigLossCount > 0 ? [
                            {
                                title: "å¤§ããªæå¤±ã®ä¾‹",
                                content: `å¤§æå¤±å–å¼•: ${bigLossCount}å›ç™ºç”Ÿ<br>ã“ã‚Œã‚‰ã¯å¹³å‡æå¤±ã®2å€ä»¥ä¸Šã®è¦æ¨¡`
                            }
                        ] : []
                    },
                    {
                        title: "ãƒªã‚¹ã‚¯åˆ†æ•£çŠ¶æ³",
                        content: `å–å¼•è¦æ¨¡ã®ä¸€è²«æ€§ï¼š<br>ãƒ»ç·å–å¼•æ•°: ${stats.totalTrades}å›<br>ãƒ»æå¤±å–å¼•æ•°: ${stats.lossTrades}å›<br>ãƒ»åˆ©ç›Šå–å¼•æ•°: ${stats.winTrades}å›<br>ãƒ»æå¤±ã®æ¨™æº–åå·®: ${stats.lossTrades > 1 ? 'è¨ˆç®—æ¸ˆã¿' : 'ä¸ååˆ†ãªãƒ‡ãƒ¼ã‚¿'}<br><br>${stats.totalTrades > 50 ? 'ååˆ†ãªå–å¼•æ•°ã§ãƒªã‚¹ã‚¯åˆ†æ•£' : 'å–å¼•æ•°ã®å¢—åŠ ãŒå¿…è¦'}`
                    }
                ],
                strengths: [
                    bigLossRatio < 0.3 ? "å¤§ããªæå¤±ã‚’é©åˆ‡ã«åˆ¶é™" : "åŸºæœ¬çš„ãªãƒªã‚¹ã‚¯ç®¡ç†ã‚’å®Ÿè·µ",
                    stats.totalTrades > 30 ? "ååˆ†ãªå–å¼•çµŒé¨“ã‚’è“„ç©" : "ç¶™ç¶šçš„ãªå–å¼•ã‚’å®Ÿè¡Œ",
                    stats.maxLoss < stats.avgLoss * 5 ? "æ¥µç«¯ãªæå¤±ã‚’å›é¿" : "æå¤±ç®¡ç†ã‚’æ„è­˜"
                ],
                weaknesses: [
                    bigLossRatio > 0.3 ? "å¤§ããªæå¤±ã®é »åº¦ãŒé«˜ã„" : "æåˆ‡ã‚Šã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®æ”¹å–„ä½™åœ°",
                    stats.maxLoss > stats.avgLoss * 3 ? "æœ€å¤§æå¤±ãŒå¹³å‡ã®3å€ä»¥ä¸Š" : "æå¤±ã®ã°ã‚‰ã¤ãç®¡ç†",
                    "ã‚ˆã‚Šä¸€è²«ã—ãŸãƒªã‚¹ã‚¯ç®¡ç†ãƒ«ãƒ¼ãƒ«ãŒå¿…è¦"
                ],
                improvements: [
                    "æåˆ‡ã‚Šãƒ©ã‚¤ãƒ³åˆ°é”æ™‚ã¯æ„Ÿæƒ…ã‚’æ’é™¤ã—ã¦æ©Ÿæ¢°çš„ã«å®Ÿè¡Œ",
                    bigLossRatio > 0.2 ? "å¤§ããªæå¤±ã‚’é¿ã‘ã‚‹ãŸã‚æåˆ‡ã‚Šå¹…ã‚’ç¸®å°" : "ç¾åœ¨ã®æåˆ‡ã‚Šæˆ¦ç•¥ã‚’ç¶™ç¶š",
                    "å–å¼•å‰ã«å¿…ãšæœ€å¤§è¨±å®¹æå¤±é¡ã‚’æ±ºå®š",
                    "é€±æœ«ã‚„é‡è¦æŒ‡æ¨™å‰å¾Œã¯ãƒã‚¸ã‚·ãƒ§ãƒ³æ•´ç†ã‚’å¾¹åº•"
                ],
                description: `ãƒªã‚¹ã‚¯ç®¡ç†åŠ›ã¯ã€ã€Œè¦å¾‹ã¨è‡ªåˆ¶å¿ƒã€ã®å¼·ã•ã‚’ç¤ºã—ã¾ã™ã€‚${stats.totalTrades}å›ã®å®Ÿå–å¼•ã‹ã‚‰ã€å¤§æå¤±æ¯”ç‡${(bigLossRatio * 100).toFixed(1)}%ã¨æœ€å¤§æå¤±Â¥${Math.round(stats.maxLoss).toLocaleString()}ã‚’åŸºã«ã€${bigLossRatio < 0.2 ? 'å„ªç§€ãª' : bigLossRatio < 0.4 ? 'è‰¯å¥½ãª' : 'æ”¹å–„ãŒå¿…è¦ãª'}ãƒªã‚¹ã‚¯ç®¡ç†èƒ½åŠ›ã‚’è©•ä¾¡ã—ã¦ã„ã¾ã™ã€‚`
            };
        }

        function getStabilityAnalysis(stats, trades) {
            const monthCount = stats.monthlyProfits.length;
            const plusMonths = stats.monthlyProfits.filter(p => p > 0).length;
            const avgMonthly = monthCount > 0 ? stats.monthlyProfits.reduce((sum, p) => sum + p, 0) / monthCount : 0;
            
            return {
                calculations: [
                    {
                        title: "åç›Šå®‰å®šæ€§åˆ†æ",
                        content: `æœŸé–“åˆ¥åç›Šã®åˆ†æï¼š<br>ãƒ»åˆ†ææœŸé–“: ${monthCount}ãƒ¶æœˆåˆ†ã®ãƒ‡ãƒ¼ã‚¿<br>ãƒ»ãƒ—ãƒ©ã‚¹æœˆ: <span class="highlight-number">${plusMonths}ãƒ¶æœˆ</span><br>ãƒ»ãƒã‚¤ãƒŠã‚¹æœˆ: ${monthCount - plusMonths}ãƒ¶æœˆ<br>ãƒ»å¹³å‡æœˆåˆ©: <span class="highlight-number">Â¥${Math.round(avgMonthly).toLocaleString()}</span><br>ãƒ»ç·åˆ©ç›Š: Â¥${Math.round(stats.totalProfit).toLocaleString()}<br><br>${plusMonths / monthCount >= 0.7 ? 'é«˜ã„å®‰å®šæ€§ã‚’å®Ÿç¾' : plusMonths / monthCount >= 0.5 ? 'åŸºæœ¬çš„ãªå®‰å®šæ€§' : 'å®‰å®šæ€§ã®æ”¹å–„ãŒå¿…è¦'}`,
                        examples: monthCount >= 2 ? [
                            {
                                title: monthCount >= 3 ? "æœˆæ¬¡ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹" : "æœŸé–“åˆ¥ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹",
                                content: `æœ€é«˜æœˆåˆ©: Â¥${Math.round(Math.max(...stats.monthlyProfits)).toLocaleString()}<br>æœ€ä½æœˆåˆ©: Â¥${Math.round(Math.min(...stats.monthlyProfits)).toLocaleString()}`
                            }
                        ] : []
                    },
                    {
                        title: "å–å¼•é »åº¦ã®å®‰å®šæ€§",
                        content: `å–å¼•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ†æï¼š<br>ãƒ»ç·å–å¼•æ•°: ${stats.totalTrades}å›<br>ãƒ»æœŸé–“: ${monthCount}ãƒ¶æœˆ<br>ãƒ»æœˆå¹³å‡å–å¼•æ•°: ${monthCount > 0 ? (stats.totalTrades / monthCount).toFixed(1) : 0}å›<br><br>${stats.totalTrades / monthCount > 15 ? 'é©åˆ‡ãªå–å¼•é »åº¦ã‚’ç¶­æŒ' : 'å–å¼•é »åº¦ã®å¢—åŠ ã‚’æ¤œè¨'}`
                    }
                ],
                strengths: [
                    plusMonths / monthCount >= 0.6 ? `${monthCount}ãƒ¶æœˆä¸­${plusMonths}ãƒ¶æœˆã§ãƒ—ãƒ©ã‚¹åç›Šã‚’é”æˆ` : "ç¶™ç¶šçš„ãªå–å¼•æ´»å‹•ã‚’å®Ÿè¡Œ",
                    avgMonthly > 0 ? `å¹³å‡æœˆåˆ©Â¥${Math.round(avgMonthly).toLocaleString()}ã®ãƒ—ãƒ©ã‚¹åç›Š` : "æå¤±ã‚’é™å®šçš„ã«æŠ‘åˆ¶",
                    stats.totalTrades > 50 ? "ååˆ†ãªå–å¼•æ•°ã§å®‰å®šæ€§ã‚’ç¢ºä¿" : "ç¶™ç¶šçš„ãªå–å¼•çµŒé¨“ã‚’è“„ç©"
                ],
                weaknesses: [
                    plusMonths / monthCount < 0.5 ? "ãƒ—ãƒ©ã‚¹æœˆã®å‰²åˆãŒ50%ã‚’ä¸‹å›ã‚‹" : "ã•ã‚‰ãªã‚‹å®‰å®šæ€§å‘ä¸Šã®ä½™åœ°",
                    monthCount < 3 ? "åˆ†ææœŸé–“ãŒçŸ­ãé•·æœŸå®‰å®šæ€§ãŒä¸æ˜" : "æœˆæ¬¡åç›Šã®ã°ã‚‰ã¤ãç®¡ç†",
                    avgMonthly < 0 ? "å¹³å‡æœˆåˆ©ãŒãƒã‚¤ãƒŠã‚¹" : "åç›Šã®æœ€é©åŒ–ä½™åœ°"
                ],
                improvements: [
                    `æœˆæ¬¡ç›®æ¨™ã‚’Â¥${Math.max(10000, Math.round(avgMonthly * 1.2)).toLocaleString()}ã«è¨­å®šã—ã€é”æˆå¾Œã¯æ…é‡ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿`,
                    plusMonths / monthCount < 0.6 ? "æœˆã®å‰åŠã§å¤§ããªæå¤±ãŒå‡ºãŸã‚‰å¾ŒåŠã¯å®ˆå‚™çš„æˆ¦ç•¥" : "ç¾åœ¨ã®æœˆæ¬¡æˆ¦ç•¥ã‚’ç¶™ç¶š",
                    "æœˆæœ«ã«æŒ¯ã‚Šè¿”ã‚Šã‚’è¡Œã„ã€ç¿Œæœˆã®æˆ¦ç•¥ã‚’ç«‹æ¡ˆ",
                    monthCount < 6 ? "ã‚ˆã‚Šé•·æœŸé–“ã®ãƒ‡ãƒ¼ã‚¿è“„ç©ã§å®‰å®šæ€§ã‚’ç¢ºèª" : "æ—¢å­˜ã®å®‰å®šæ€§ã‚’ç¶­æŒ"
                ],
                description: `åç›Šå®‰å®šåŠ›ã¯ã€ã€ŒæŒç¶šå¯èƒ½ãªåˆ©ç›Šå‰µå‡ºèƒ½åŠ›ã€ã‚’æ¸¬å®šã—ã¾ã™ã€‚${monthCount}ãƒ¶æœˆé–“ã®å®Ÿç¸¾ã§ãƒ—ãƒ©ã‚¹æœˆç‡${(plusMonths / monthCount * 100).toFixed(1)}%ã€å¹³å‡æœˆåˆ©Â¥${Math.round(avgMonthly).toLocaleString()}ã‹ã‚‰ã€${plusMonths / monthCount >= 0.6 ? 'è‰¯å¥½ãª' : 'æ”¹å–„ä½™åœ°ã®ã‚ã‚‹'}å®‰å®šæ€§ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚`
            };
        }

        // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
        function getTemplateAnalysisData(scoreIndex) {
            const analysisTemplates = [
                // ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“ (index 0)
                {
                    calculations: [
                        {
                            title: "å‹ç‡åˆ†æ",
                            content: `<u>ã‚ãªãŸã®å‹ç‡ã¯<span class="highlight-number">65.3%</span>ï¼ˆ98å‹52æ•—ï¼‰ã§ã™ã€‚</u><br><u>ãƒ»ä¸€èˆ¬çš„ãªç›®å®‰ã®50%ã‚’å¤§ããä¸Šå›ã‚‹å„ªç§€ãªæ•°å€¤</u><br><u>ãƒ»ç‰¹ã«4æœˆã¯å‹ç‡72%ã€5æœˆã¯68%ã¨é«˜ã„ç²¾åº¦ã‚’ç¶­æŒ</u><br><u>ãƒ»è² ã‘ã‚‹æ™‚ã‚‚å°ã•ãªæå¤±ã«æŠ‘ãˆã‚‰ã‚Œã¦ã„ã‚‹å‚¾å‘</u><br><u>â†’ å‹ç‡ã‚¹ã‚³ã‚¢: <span class="highlight-number">8.5/10ç‚¹</span></u>`,
                            examples: [
                                {
                                    title: "å„ªç§€ãªã‚¨ãƒ³ãƒˆãƒªãƒ¼ä¾‹",
                                    content: "<u>2024/4/15 9:15 USDJPYè²·ã„ â†’ +Â¥8,500</u><br><u>ï¼ˆæ±äº¬å¸‚å ´é–‹å§‹ç›´å¾Œã®å††å®‰ãƒˆãƒ¬ãƒ³ãƒ‰ã‚’æ‰ãˆãŸçš„ç¢ºãªã‚¨ãƒ³ãƒˆãƒªãƒ¼ï¼‰</u>"
                                }
                            ]
                        },
                        {
                            title: "å¸‚å ´ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦",
                            content: `<u>ä¸»è¦å¸‚å ´æ™‚é–“ã§ã®å–å¼•åˆ†æï¼š</u><br><u>ãƒ»æ±äº¬æ™‚é–“ï¼ˆ9-15æ™‚ï¼‰: 45å›å–å¼•ï¼ˆ30%ï¼‰</u><br><u>ãƒ»ãƒ­ãƒ³ãƒ‰ãƒ³æ™‚é–“ï¼ˆ16-18æ™‚ï¼‰: 38å›å–å¼•ï¼ˆ25.3%ï¼‰</u><br><u>ãƒ»NYæ™‚é–“ï¼ˆ22-1æ™‚ï¼‰: 42å›å–å¼•ï¼ˆ28%ï¼‰</u><br><u>ãƒ»ãã®ä»–æ™‚é–“å¸¯: 25å›å–å¼•ï¼ˆ16.7%ï¼‰</u><br><br><u>â†’ <span class="highlight-number">83.3%</span>ãŒä¸»è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã§ã®å–å¼•</u><br><u>â†’ ã‚»ãƒƒã‚·ãƒ§ãƒ³é©åˆåº¦: <span class="highlight-number">7.1/10ç‚¹</span></u>`
                        }
                    ],
                    strengths: [
                        "<u>å‹ç‡65.3%ã¨ã„ã†é«˜ã„ç²¾åº¦ã‚’ç¶­æŒ</u>",
                        "<u>ä¸»è¦å¸‚å ´æ™‚é–“ã‚’ç‹™ã£ãŸæˆ¦ç•¥çš„å–å¼•</u>",
                        "<u>å®‰å®šã—ãŸæœˆæ¬¡ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹</u>",
                        "<u>ãƒˆãƒ¬ãƒ³ãƒ‰åˆ¤æ–­åŠ›ãŒå„ªç§€</u>"
                    ],
                    weaknesses: [
                        "<u>é–‘æ•£æ™‚é–“å¸¯ã§ã®å–å¼•ãŒ16.7%å­˜åœ¨</u>",
                        "<u>ä¸€éƒ¨ã®æœˆã§å‹ç‡ãŒã°ã‚‰ã¤ãå‚¾å‘</u>",
                        "<u>ãƒ¬ãƒ³ã‚¸ç›¸å ´ã§ã®ç²¾åº¦ã«æ”¹å–„ä½™åœ°</u>"
                    ],
                    improvements: [
                        "<u>22æ™‚ä»¥é™ã®NYæ™‚é–“ã§ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼æ©Ÿä¼šã‚’å¢—ã‚„ã™</u>",
                        "<u>çµŒæ¸ˆæŒ‡æ¨™ç™ºè¡¨æ™‚é–“ã‚’äº‹å‰ãƒã‚§ãƒƒã‚¯ã—ã¦æˆ¦ç•¥çš„ã«ã‚¨ãƒ³ãƒˆãƒªãƒ¼</u>",
                        "<u>é–‘æ•£æ™‚é–“å¸¯ï¼ˆæ·±å¤œ2-6æ™‚ï¼‰ã®å–å¼•ã‚’æ§ãˆã‚‹</u>",
                        "<u>æœˆæ¬¡ç›®æ¨™å‹ç‡ã‚’70%ã«è¨­å®šã—ã¦æ„è­˜å‘ä¸Š</u>"
                    ],
                    description: "<u>ã‚¨ãƒ³ãƒˆãƒªãƒ¼æŠ€è¡“ã¯ã€ã‚ãªãŸã®ã€Œå£²è²·ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®çš„ç¢ºã•ã€ã‚’è©•ä¾¡ã—ã¾ã™ã€‚é«˜ã‚¹ã‚³ã‚¢ï¼ˆ8-10ç‚¹ï¼‰ã®ç‰¹å¾´ã¨ã—ã¦ã€å¸‚å ´ã®æµã‚Œã‚’æ­£ç¢ºã«èª­ã¿å–ã‚Šã€æœ€é©ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã§ãã¦ã„ã¾ã™ã€‚å‹ç‡ãŒé«˜ãã€ä¸»è¦ãªå¸‚å ´ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“ã‚’ç‹™ã£ãŸæˆ¦ç•¥çš„ãªå–å¼•ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚</u>"
                },
                // ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§ (index 1)
                {
                    calculations: [
                        {
                            title: "æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³åˆ†æ",
                            content: `<u>è³‡ç”£æ¨ç§»ã®è©³ç´°åˆ†æï¼š</u><br><u>ãƒ»æœ€é«˜åˆ°é”åˆ©ç›Š: <span class="highlight-number">Â¥345,000</span>ï¼ˆ4æœˆæœ«ï¼‰</u><br><u>ãƒ»ãã®å¾Œã®æœ€ä½ç‚¹: Â¥198,000ï¼ˆ5æœˆä¸­æ—¬ï¼‰</u><br><u>ãƒ»æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³: <span class="highlight-number">Â¥147,000</span>ï¼ˆ42.6%ã®ä¸‹è½ï¼‰</u><br><br><u>ã“ã®42.6%ã®ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ã¯ä»¥ä¸‹ã®å–å¼•ãŒåŸå› ï¼š</u><br><u>ãƒ»5/8 GBPJPY: -Â¥45,000ï¼ˆè‹±å›½é¸æŒ™ä¸å®‰ã§ã®æ€¥è½ï¼‰</u><br><u>ãƒ»5/12 EURJPY: -Â¥38,000ï¼ˆECBæ”¿ç­–å¤‰æ›´ï¼‰</u><br><u>ãƒ»5/15 USDJPY: -Â¥35,000ï¼ˆæ—¥éŠ€ä»‹å…¥å™‚ã§ã®æ€¥åè»¢ï¼‰</u>`,
                            examples: [
                                {
                                    title: "å•é¡Œã®ã‚ã£ãŸå–å¼•",
                                    content: "<u>5/8 GBPJPY: æåˆ‡ã‚Šè¨­å®šã‚’ç„¡è¦–ã—ã¦-45,000å††</u><br><u>é‡è¦ãªãƒ•ã‚¡ãƒ³ãƒ€ãƒ¡ãƒ³ã‚¿ãƒ«ã‚ºå¤‰åŒ–ã¸ã®å¯¾å¿œãŒé…ã‚ŒãŸä¾‹</u>"
                                }
                            ]
                        },
                        {
                            title: "å›å¾©åŠ›åˆ†æ",
                            content: `<u>5æœˆä¸­æ—¬ã®å¤§ããªæå¤±å¾Œã®å›å¾©çŠ¶æ³ï¼š</u><br><u>ãƒ»5æœˆæœ«: Â¥220,000ï¼ˆ22,000å††å›å¾©ï¼‰</u><br><u>ãƒ»6æœˆæœ«: Â¥287,500ï¼ˆæœ€çµ‚çš„ã«67,500å††å›å¾©ï¼‰</u><br><br><u>å›å¾©ã«è¦ã—ãŸæœŸé–“: <span class="highlight-number">ç´„6é€±é–“</span></u><br><u>â†’ ä¸­ç¨‹åº¦ã®å›å¾©åŠ›ã‚’ç¤ºã™ãŒã€ã‚ˆã‚Šæ—©æœŸã®æåˆ‡ã‚ŠãŒèª²é¡Œ</u>`
                        }
                    ],
                    strengths: [
                        "<u>å¤§ããªæå¤±å¾Œã‚‚å–å¼•ã‚’ç¶™ç¶šã™ã‚‹ç²¾ç¥åŠ›</u>",
                        "<u>æœ€çµ‚çš„ã«æå¤±ã‚’å›å¾©ã™ã‚‹èƒ½åŠ›</u>",
                        "<u>åŸºæœ¬çš„ãªãƒªã‚¹ã‚¯ç®¡ç†ã¯å®Ÿè·µæ¸ˆã¿</u>"
                    ],
                    weaknesses: [
                        "<u>é‡è¦å ´é¢ã§ã®æåˆ‡ã‚Šå®Ÿè¡Œã«èª²é¡Œ</u>",
                        "<u>42.6%ã¨ã„ã†å¤§ããªãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³ã‚’çµŒé¨“</u>",
                        "<u>ãƒ•ã‚¡ãƒ³ãƒ€ãƒ¡ãƒ³ã‚¿ãƒ«ã‚ºå¤‰åŒ–ã¸ã®å¯¾å¿œãŒé…ã„</u>"
                    ],
                    improvements: [
                        "<u>é‡è¦çµŒæ¸ˆæŒ‡æ¨™ç™ºè¡¨å‰ã¯å¿…ãšæåˆ‡ã‚Šè¨­å®šã‚’ç¢ºèª</u>",
                        "<u>æœ€å¤§æå¤±é¡ã‚’å£åº§æ®‹é«˜ã®5%ä»¥å†…ã«åˆ¶é™</u>",
                        "<u>3é€£æ•—ã—ãŸã‚‰1æ—¥å–å¼•ã‚’ä¼‘ã‚“ã§ãƒ¡ãƒ³ã‚¿ãƒ«ãƒªã‚»ãƒƒãƒˆ</u>",
                        "<u>ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³20%åˆ°é”æ™‚ç‚¹ã§å–å¼•ãƒ­ãƒƒãƒˆã‚’åŠåˆ†ã«å‰Šæ¸›</u>"
                    ],
                    description: "<u>ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³è€æ€§ã¯ã€ã€Œé€†å¢ƒã«å¯¾ã™ã‚‹å¼·ã•ã€ã‚’æ¸¬å®šã—ã¾ã™ã€‚ä¸­ã‚¹ã‚³ã‚¢ï¼ˆ5-7ç‚¹ï¼‰ã®ç‰¹å¾´ã¨ã—ã¦ã€ã‚ã‚‹ç¨‹åº¦ã®æå¤±ã«ã¯å¯¾å¿œã§ãã¦ã„ã¾ã™ãŒã€ã‚ˆã‚Šå …å®Ÿãªãƒªã‚¹ã‚¯ç®¡ç†ã«ã‚ˆã‚Šæ”¹å–„ã®ä½™åœ°ãŒã‚ã‚Šã¾ã™ã€‚</u>"
                },
                // ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰ (index 2)
                {
                    calculations: [
                        {
                            title: "RRæ¯”åˆ†æ",
                            content: `<u>åˆ©ç›Šãƒ»æå¤±ã®è©³ç´°å†…è¨³ï¼š</u><br><u>ãƒ»å¹³å‡åˆ©ç›Š: <span class="highlight-number">Â¥8,230</span>ï¼ˆ98å›ã®å‹ã¡å–å¼•ï¼‰</u><br><u>ãƒ»å¹³å‡æå¤±: <span class="highlight-number">Â¥3,460</span>ï¼ˆ52å›ã®è² ã‘å–å¼•ï¼‰</u><br><u>ãƒ»ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”: <span class="highlight-number">2.38</span></u><br><br><u>ã“ã‚Œã¯éå¸¸ã«å„ªç§€ãªæ•°å€¤ã§ã™ï¼š</u><br><u>ãƒ»1å›ã®æå¤±ã‚’2.38å›ã®åˆ©ç›Šã§è£œãˆã‚‹åŠ¹ç‡æ€§</u><br><u>ãƒ»ã€Œåˆ©å¤§æå°ã€ã®ç†æƒ³çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®Ÿç¾</u>`,
                            examples: [
                                {
                                    title: "å„ªç§€ãªRRæ¯”ã®å–å¼•ä¾‹",
                                    content: "<u>2024/5/3 22:30 EURJPYå£²ã‚Š</u><br><u>ã‚¨ãƒ³ãƒˆãƒªãƒ¼: 165.20ã€æ±ºæ¸ˆ: 162.85ï¼ˆ+235pipsï¼‰</u><br><u>ãƒªã‚¹ã‚¯50pips â†’ ãƒªã‚¿ãƒ¼ãƒ³235pipsï¼ˆRRæ¯” 4.7ï¼‰</u>"
                                }
                            ]
                        },
                        {
                            title: "åˆ©ç¢ºãƒ»æåˆ‡ã‚Šã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ†æ",
                            content: `<u>ã€åˆ©ç¢ºãƒ‘ã‚¿ãƒ¼ãƒ³ã€‘</u><br><u>ãƒ»5,000å††æœªæº€: 15å›ï¼ˆ15.3%ï¼‰â†’ æ—©æœŸåˆ©ç¢º</u><br><u>ãƒ»5,000-10,000å††: 58å›ï¼ˆ59.2%ï¼‰â†’ é©åˆ‡ãªåˆ©ç¢º</u><br><u>ãƒ»10,000å††ä»¥ä¸Š: 25å›ï¼ˆ25.5%ï¼‰â†’ åˆ©ç›Šã‚’ä¼¸ã°ã™æŠ€è¡“</u><br><br><u>ã€æåˆ‡ã‚Šãƒ‘ã‚¿ãƒ¼ãƒ³ã€‘</u><br><u>ãƒ»2,000å††æœªæº€: 8å›ï¼ˆ15.4%ï¼‰â†’ æ—©æœŸæ’¤é€€</u><br><u>ãƒ»2,000-5,000å††: 35å›ï¼ˆ67.3%ï¼‰â†’ é©åˆ‡ãªæåˆ‡ã‚Š</u><br><u>ãƒ»5,000å††ä»¥ä¸Š: 9å›ï¼ˆ17.3%ï¼‰â†’ æ”¹å–„ã®ä½™åœ°</u>`
                        }
                    ],
                    strengths: [
                        "<u>RRæ¯”2.38ã¨ã„ã†å„ªç§€ãªåŠ¹ç‡æ€§</u>",
                        "<u>åˆ©ç›Šã‚’ä¼¸ã°ã™æŠ€è¡“ãŒèº«ã«ã¤ã„ã¦ã„ã‚‹</u>",
                        "<u>é©åˆ‡ãªæåˆ‡ã‚ŠãŒã§ãã¦ã„ã‚‹ï¼ˆ67.3%ï¼‰</u>",
                        "<u>åˆ©å¤§æå°ã®ç†æƒ³çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®Ÿç¾</u>"
                    ],
                    weaknesses: [
                        "<u>5,000å††ä»¥ä¸Šã®å¤§ããªæåˆ‡ã‚ŠãŒ17.3%å­˜åœ¨</u>",
                        "<u>æ—©æœŸåˆ©ç¢ºãŒ15.3%ã‚ã‚‹ï¼ˆæ”¹å–„ä½™åœ°ï¼‰</u>"
                    ],
                    improvements: [
                        "<u>åˆ©ç›ŠãŒ5,000å††ã«é”ã—ãŸã‚‰åŠåˆ†åˆ©ç¢ºã€æ®‹ã‚Šã‚’ä¼¸ã°ã™æˆ¦ç•¥</u>",
                        "<u>æåˆ‡ã‚Šãƒ©ã‚¤ãƒ³ã¯çµ¶å¯¾ã«-5,000å††ã‚’è¶…ãˆãªã„</u>",
                        "<u>ãƒˆãƒ¬ãƒ³ãƒ‰ç¶™ç¶šæ™‚ã¯ãƒˆãƒ¬ã‚¤ãƒªãƒ³ã‚°ã‚¹ãƒˆãƒƒãƒ—ã‚’æ´»ç”¨</u>",
                        "<u>é‡è¦ã‚µãƒãƒ¼ãƒˆãƒ»ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ³ã‚¹ä»˜è¿‘ã§ã¯åˆ©ç¢ºã‚’æ…é‡ã«åˆ¤æ–­</u>"
                    ],
                    description: "<u>ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰åŠ›ã¯ã€ã€ŒåŠ¹ç‡çš„ãªåˆ©ç›Šç²å¾—èƒ½åŠ›ã€ã‚’è©•ä¾¡ã—ã¾ã™ã€‚é«˜ã‚¹ã‚³ã‚¢ï¼ˆ8-10ç‚¹ï¼‰ã®ç‰¹å¾´ã¨ã—ã¦ã€å°ã•ãªãƒªã‚¹ã‚¯ã§å¤§ããªãƒªã‚¿ãƒ¼ãƒ³ã‚’ç²å¾—ã™ã‚‹å„ªã‚ŒãŸæŠ€è¡“ã‚’æŒã£ã¦ã„ã¾ã™ã€‚åˆ©ç¢ºã¨æåˆ‡ã‚Šã®ãƒãƒ©ãƒ³ã‚¹ãŒç†æƒ³çš„ã§ã€åŠ¹ç‡çš„ãªè³‡ç”£å¢—åŠ ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚</u>"
                },
                // ãƒªã‚¹ã‚¯ç®¡ç†åŠ› (index 3)
                {
                    calculations: [
                        {
                            title: "æåˆ‡ã‚Šå¾¹åº•åº¦",
                            content: `<u>å¤§ããªæå¤±ã®ç™ºç”ŸçŠ¶æ³ï¼š</u><br><u>ãƒ»10,000å††ä»¥ä¸Šã®æå¤±: <span class="highlight-number">9å›</span>ï¼ˆå…¨æå¤±ã®17.3%ï¼‰</u><br><u>ãƒ»æœ€å¤§æå¤±: <span class="highlight-number">Â¥45,000</span>ï¼ˆ5/8 GBPJPYï¼‰</u><br><br><u>å•é¡Œã®ã‚ã‚‹å–å¼•ä¾‹ï¼š</u><br><u>ãƒ»5/8 GBPJPY: æåˆ‡ã‚Šè¨­å®šã‚’ç„¡è¦–ã—ã¦-45,000å††</u><br><u>ãƒ»5/12 EURJPY: ãƒŠãƒ³ãƒ”ãƒ³ã«ã‚ˆã‚Šæå¤±æ‹¡å¤§ã§-38,000å††</u><br><u>ãƒ»3/22 USDJPY: é€±æœ«æŒè¶Šã—ã§-28,000å††</u>`,
                            examples: [
                                {
                                    title: "è¦å¾‹é•åã®ä¾‹",
                                    content: "<u>5/12 EURJPY ãƒŠãƒ³ãƒ”ãƒ³ãƒˆãƒ¬ãƒ¼ãƒ‰</u><br><u>åˆå›ã‚¨ãƒ³ãƒˆãƒªãƒ¼: -8,000å††</u><br><u>2å›ç›®ãƒŠãƒ³ãƒ”ãƒ³: ã•ã‚‰ã«-15,000å††</u><br><u>3å›ç›®ãƒŠãƒ³ãƒ”ãƒ³: ã•ã‚‰ã«-15,000å††</u><br><u>åˆè¨ˆæå¤±: -38,000å††</u>"
                                }
                            ]
                        },
                        {
                            title: "ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºåˆ†æ",
                            content: `<u>å–å¼•é‡ã®ä¸€è²«æ€§ï¼š</u><br><u>ãƒ»æ¨™æº–ãƒ­ãƒƒãƒˆ: 100,000é€šè²¨ï¼ˆå…¨ä½“ã®78%ï¼‰</u><br><u>ãƒ»å¤§ãã‚ãƒ­ãƒƒãƒˆ: 150,000-200,000é€šè²¨ï¼ˆ18%ï¼‰</u><br><u>ãƒ»å°ã•ã‚ãƒ­ãƒƒãƒˆ: 50,000é€šè²¨ï¼ˆ4%ï¼‰</u><br><br><u>å¤§ãã‚ãƒ­ãƒƒãƒˆã§ã®æˆç¸¾ï¼š</u><br><u>ãƒ»27å›ä¸­15å›å‹ã¡ï¼ˆå‹ç‡<span class="highlight-number">55.6%</span>ï¼‰</u><br><u>ãƒ»æ¨™æº–ãƒ­ãƒƒãƒˆã‚ˆã‚Šå‹ç‡ãŒ<span class="highlight-number">10%ä½ä¸‹</span></u><br><br><u>â†’ ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºã®å½±éŸ¿ã§åˆ¤æ–­ãŒæ‚ªåŒ–ã™ã‚‹å‚¾å‘</u>`
                        }
                    ],
                    strengths: [
                        "<u>åŸºæœ¬çš„ãªæåˆ‡ã‚Šãƒ«ãƒ¼ãƒ«ã¯ç†è§£ã—ã¦ã„ã‚‹</u>",
                        "<u>78%ã®å–å¼•ã§é©æ­£ãªãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºã‚’ç¶­æŒ</u>",
                        "<u>å°é¡å–å¼•ã§ã®ç·´ç¿’ã‚‚å®Ÿæ–½</u>"
                    ],
                    weaknesses: [
                        "<u>é‡è¦å ´é¢ã§ã®æåˆ‡ã‚Šè¦å¾‹ãŒä¸ååˆ†</u>",
                        "<u>ãƒŠãƒ³ãƒ”ãƒ³å–å¼•ã«ã‚ˆã‚‹æå¤±æ‹¡å¤§</u>",
                        "<u>å¤§ãƒ­ãƒƒãƒˆå–å¼•æ™‚ã®åˆ¤æ–­ç²¾åº¦ä½ä¸‹</u>",
                        "<u>é€±æœ«æŒè¶Šã—ãƒªã‚¹ã‚¯ã®è»½è¦–</u>"
                    ],
                    improvements: [
                        "<u>æåˆ‡ã‚Šãƒ©ã‚¤ãƒ³åˆ°é”æ™‚ã¯æ„Ÿæƒ…ã‚’æ’é™¤ã—ã¦æ©Ÿæ¢°çš„ã«å®Ÿè¡Œ</u>",
                        "<u>ãƒŠãƒ³ãƒ”ãƒ³ã¯ç¦æ­¢ãƒ«ãƒ¼ãƒ«ã¨ã—ã¦å³æ ¼ã«é‹ç”¨</u>",
                        "<u>ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚µã‚¤ã‚ºã¯å¸¸ã«æ¨™æº–ãƒ­ãƒƒãƒˆï¼ˆ100,000é€šè²¨ï¼‰ã«å›ºå®š</u>",
                        "<u>é‡‘æ›œæ—¥å¤œã¯å¿…ãšãƒã‚¸ã‚·ãƒ§ãƒ³ã‚¯ãƒ­ãƒ¼ã‚º</u>",
                        "<u>é‡è¦æŒ‡æ¨™ç™ºè¡¨å‰å¾Œ24æ™‚é–“ã¯æ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ç¦æ­¢</u>"
                    ],
                    description: "<u>ãƒªã‚¹ã‚¯ç®¡ç†åŠ›ã¯ã€ã€Œè¦å¾‹ã¨è‡ªåˆ¶å¿ƒã€ã®å¼·ã•ã‚’ç¤ºã—ã¾ã™ã€‚ä¸­ã‚¹ã‚³ã‚¢ï¼ˆ5-7ç‚¹ï¼‰ã®ç‰¹å¾´ã¨ã—ã¦ã€åŸºæœ¬çš„ãªãƒªã‚¹ã‚¯ç®¡ç†ã¯ã§ãã¦ã„ã¾ã™ãŒã€ã‚ˆã‚Šä¸€è²«ã—ãŸãƒ«ãƒ¼ãƒ«é©ç”¨ã«ã‚ˆã‚Šå®‰å…¨æ€§ã‚’é«˜ã‚ã‚‰ã‚Œã¾ã™ã€‚</u>"
                },
                // åç›Šå®‰å®šåŠ› (index 4)
                {
                    calculations: [
                        {
                            title: "æœˆæ¬¡æç›Šåˆ†æ",
                            content: `<u>æœˆåˆ¥ã®è©³ç´°åç›Šï¼š</u><br><u>ãƒ»1æœˆ: +Â¥45,000ï¼ˆå‹ç‡70%ã€22å›å–å¼•ï¼‰</u><br><u>ãƒ»2æœˆ: +Â¥62,000ï¼ˆå‹ç‡68%ã€25å›å–å¼•ï¼‰</u><br><u>ãƒ»3æœˆ: +Â¥38,000ï¼ˆå‹ç‡58%ã€26å›å–å¼•ï¼‰</u><br><u>ãƒ»4æœˆ: +Â¥89,000ï¼ˆå‹ç‡72%ã€28å›å–å¼•ï¼‰â˜…æœ€é«˜</u><br><u>ãƒ»5æœˆ: <span class="highlight-number">-Â¥18,000</span>ï¼ˆå‹ç‡45%ã€24å›å–å¼•ï¼‰â˜…æœ€ä½</u><br><u>ãƒ»6æœˆ: +Â¥71,500ï¼ˆå‹ç‡67%ã€25å›å–å¼•ï¼‰</u><br><br><u>æ¨™æº–åå·®: <span class="highlight-number">Â¥35,420</span></u><br><u>å¤‰å‹•ä¿‚æ•°: 0.73ï¼ˆã‚„ã‚„ä¸å®‰å®šï¼‰</u>`,
                            examples: [
                                {
                                    title: "5æœˆã®ä¸èª¿æœŸåˆ†æ",
                                    content: "<u>5æœˆã®-18,000å††ã®è¦å› ï¼š</u><br><u>ãƒ»å¤§å‹é€£ä¼‘ã§ã®å¸‚å ´å¤‰å‹•ã¸ã®å¯¾å¿œé…ã‚Œ</u><br><u>ãƒ»ECBæ”¿ç­–å¤‰æ›´ã®æƒ…å ±åé›†ä¸è¶³</u><br><u>ãƒ»3å›ã®å¤§ããªæå¤±ï¼ˆ-45,000å††ã€-38,000å††ã€-35,000å††ï¼‰</u>"
                                }
                            ]
                        },
                        {
                            title: "å–å¼•é »åº¦ã®ä¸€è²«æ€§",
                            content: `<u>æœˆåˆ¥å–å¼•å›æ•°ã®åˆ†æï¼š</u><br><u>ãƒ»æœ€å¤š: <span class="highlight-number">28å›</span>ï¼ˆ4æœˆï¼‰</u><br><u>ãƒ»æœ€å°‘: 22å›ï¼ˆ1æœˆï¼‰</u><br><u>ãƒ»å¹³å‡: 25å›/æœˆ</u><br><u>ãƒ»æ¨™æº–åå·®: 2.1å›</u><br><br><u>â†’ å–å¼•é »åº¦ã¯éå¸¸ã«å®‰å®šã—ã¦ã„ã‚‹</u><br><u>â†’ éåº¦ãªå–å¼•ã‚„å–å¼•ä¸è¶³ã¯ãªã—</u>`
                        }
                    ],
                    strengths: [
                        "<u>5ãƒ¶æœˆä¸­4ãƒ¶æœˆã§ãƒ—ãƒ©ã‚¹åç›Šã‚’é”æˆ</u>",
                        "<u>å–å¼•é »åº¦ãŒå®‰å®šã—ã¦ã„ã‚‹ï¼ˆæœˆ25å›å‰å¾Œï¼‰</u>",
                        "<u>æœ€çµ‚çš„ã«ãƒã‚¤ãƒŠã‚¹æœˆã‚‚å›å¾©ã—ã¦ã„ã‚‹</u>",
                        "<u>éåº¦ãªå–å¼•ã‚’ã›ãšè¦å¾‹ã‚’ä¿ã£ã¦ã„ã‚‹</u>"
                    ],
                    weaknesses: [
                        "<u>5æœˆã«-18,000å††ã®å¤§å¹…ãƒã‚¤ãƒŠã‚¹</u>",
                        "<u>æœˆæ¬¡åç›Šã®å¤‰å‹•ãŒã‚„ã‚„å¤§ãã„ï¼ˆå¤‰å‹•ä¿‚æ•°0.73ï¼‰</u>",
                        "<u>ä¸èª¿æœŸã®å¯¾å¿œç­–ãŒä¸ååˆ†</u>"
                    ],
                    improvements: [
                        "<u>æœˆæ¬¡ç›®æ¨™ã‚’50,000å††ã«è¨­å®šã—ã€é”æˆå¾Œã¯æ…é‡ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡æ›¿</u>",
                        "<u>æœˆã®å‰åŠã§å¤§ããªæå¤±ãŒå‡ºãŸã‚‰å¾ŒåŠã¯å®ˆå‚™çš„æˆ¦ç•¥</u>",
                        "<u>çµŒæ¸ˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’äº‹å‰ãƒã‚§ãƒƒã‚¯ã—ã€é‡è¦é€±ã¯å–å¼•é »åº¦ã‚’èª¿æ•´</u>",
                        "<u>ä¸èª¿æœŸï¼ˆ3é€£æ•—ï¼‰ã¯ç¿Œæ—¥ã®å–å¼•ã‚’ä¼‘ã‚“ã§ãƒªã‚»ãƒƒãƒˆ</u>",
                        "<u>æœˆæœ«ã«æŒ¯ã‚Šè¿”ã‚Šã‚’è¡Œã„ã€ç¿Œæœˆã®æˆ¦ç•¥ã‚’ç«‹æ¡ˆ</u>"
                    ],
                    description: "<u>åç›Šå®‰å®šåŠ›ã¯ã€ã€ŒæŒç¶šå¯èƒ½ãªåˆ©ç›Šå‰µå‡ºèƒ½åŠ›ã€ã‚’æ¸¬å®šã—ã¾ã™ã€‚ä¸­ã‚¹ã‚³ã‚¢ï¼ˆ6-7ç‚¹ï¼‰ã®ç‰¹å¾´ã¨ã—ã¦ã€æ¦‚ã­å®‰å®šã—ã¦ã„ã¾ã™ãŒã€æœˆã«ã‚ˆã£ã¦æˆç¸¾ã«ã°ã‚‰ã¤ããŒã‚ã‚Šã¾ã™ã€‚ã‚ˆã‚Šä¸€è²«ã—ãŸãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ç›®æŒ‡ã—ã¾ã—ã‚‡ã†ã€‚</u>"
                }
            ];

            return analysisTemplates[scoreIndex] || analysisTemplates[0];
        }
    </script>
</body>
</html>
